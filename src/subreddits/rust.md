# rust
## [1][Hey Rustaceans! Got an easy question? Ask here (31/2020)!](https://www.reddit.com/r/rust/comments/hynlfl/hey_rustaceans_got_an_easy_question_ask_here/)
- url: https://www.reddit.com/r/rust/comments/hynlfl/hey_rustaceans_got_an_easy_question_ask_here/
---
Mystified about strings? Borrow checker have you in a headlock? Seek help here! There are no stupid questions, only docs that haven't been written yet.

If you have a [StackOverflow](http://stackoverflow.com/) account, consider asking it there instead! StackOverflow shows up much higher in search results, so having your question there also helps future Rust users (be sure to give it [the "Rust" tag](http://stackoverflow.com/questions/tagged/rust) for maximum visibility). Note that this site is very interested in question quality. I've been asked to read a RFC I authored once. If you want your code reviewed or review other's code, there's a [codereview stackexchange](https://codereview.stackexchange.com/questions/tagged/rust), too. If you need to test your code, maybe [the Rust playground](https://play.rust-lang.org) is for you.

Here are some other venues where help may be found:

[/r/learnrust](https://www.reddit.com/r/learnrust) is a subreddit to share your questions and epiphanies learning Rust programming.

The official Rust user forums: [https://users.rust-lang.org/](https://users.rust-lang.org/).

The official Rust Programming Language Discord: [https://discord.gg/rust-lang](https://discord.gg/rust-lang)

The unofficial Rust community Discord: [https://bit.ly/rust-community](https://bit.ly/rust-community)

Also check out [last week's thread](https://reddit.com/r/rust/comments/hurj77/hey_rustaceans_got_an_easy_question_ask_here/) with many good questions and answers. And if you believe your question to be either very complex or worthy of larger dissemination, feel free to create a text post.

Also if you want to be mentored by experienced Rustaceans, tell us the area of expertise that you seek.
## [2][What's everyone working on this week (31/2020)?](https://www.reddit.com/r/rust/comments/hynlvw/whats_everyone_working_on_this_week_312020/)
- url: https://www.reddit.com/r/rust/comments/hynlvw/whats_everyone_working_on_this_week_312020/
---
New week, new Rust! What are you folks up to? Answer here or over at [rust-users](https://users.rust-lang.org/t/whats-everyone-working-on-this-week-31-2020/46441?u=llogiq)!
## [3][rust-analyzer changelog #35](https://www.reddit.com/r/rust/comments/hyq5tm/rustanalyzer_changelog_35/)
- url: https://rust-analyzer.github.io/thisweek/2020/07/27/changelog-35.html
---

## [4][Ballista Distributed Compute: One Year Later](https://www.reddit.com/r/rust/comments/hylldh/ballista_distributed_compute_one_year_later/)
- url: https://andygrove.io/2020/07/ballista-one-year-on/
---

## [5][Richter - a modern Quake engine](https://www.reddit.com/r/rust/comments/hypx17/richter_a_modern_quake_engine/)
- url: http://c-obrien.org/richter/
---

## [6][My first crate - a runtime-agnostic, 100% safe attempt at scoped asynchronous tasks](https://www.reddit.com/r/rust/comments/hyqyx2/my_first_crate_a_runtimeagnostic_100_safe_attempt/)
- url: https://docs.rs/safe-async-scoped/0.1.1/safe_async_scoped/
---

## [7][Oak: an infinitely portable language powered by secret, brainf*%! inspired technology.](https://www.reddit.com/r/rust/comments/hygtvb/oak_an_infinitely_portable_language_powered_by/)
- url: https://github.com/adam-mcdaniel/oakc
---

## [8][autograph v0.0.3](https://www.reddit.com/r/rust/comments/hyjlal/autograph_v003/)
- url: https://www.reddit.com/r/rust/comments/hyjlal/autograph_v003/
---
https://crates.io/crates/autograph

# Changes
  - datasets feature is now default
  - renamed layer as nn and moved autograd and optimizer into it

# New features
  - Optimizer trait
  - Sgd Optimizer
  - Saving of parameters and checkpoints
  - Variable / Tensor add() method
  - Layer can be derived 
  - impl_forward macro for generating Forward implementation
  - Sequential Layer
## [9][IntelliJ Rust Changelog #127](https://www.reddit.com/r/rust/comments/hys35n/intellij_rust_changelog_127/)
- url: https://intellij-rust.github.io/2020/07/27/changelog-127.html
---

## [10][How to iterate in parallel over two hashmaps?](https://www.reddit.com/r/rust/comments/hyrej9/how_to_iterate_in_parallel_over_two_hashmaps/)
- url: https://www.reddit.com/r/rust/comments/hyrej9/how_to_iterate_in_parallel_over_two_hashmaps/
---
I am in the process of making a simulation run in parallel on multiple cores. Rayon plus some Arcs and Mutexes got me most of the way there pretty fast, but now I run into the following issue.

One step of my simulation gets a `families_by_location: HashMap&lt;NodeId, Vec&lt;Family&gt;&gt;` generated by one submodel and a `patches: HashMap&lt;NodeId, Patch&gt;` from another submodel. Then some interaction happens on patches, so the core bit of that was something like

    for node_id, families in families_by_location.iter_mut() {
        match patches.get_mut(node_id) {
            None =&gt; continue,
            Some(patch) =&gt; families_exploit_patch(families, patch)
        }
    }

This can be naturally parallelized, but my naïve way is 

    let patches_wrapper = Arc::new(Mutex::new(patches));
    families_by_location.par_iter_mut().map(|(node_id, families)| {
        match patches_wrapper.lock().unwrap().get_mut(node_id) {
            None =&gt; {},
            Some(patch) =&gt; {
                families_exploit_patch(families, patch)
            }
        }
    }.for_each(|()| ());

and that's obviously a bit unhandy, because all the steps want a lock on the `patches_wrapper` at roughly the same time.

Stuffing the `Patch` structs into `families_by_location` is not optimal because currently these two objects are dealt with quite indepentently until this point. Is there a way to zip two HashSets in a convenient manner, which would allow a construction as

    families_by_location.with_zipped(patches).par_iter_mut().map(|(node_id, (maybe_families, maybe_patch))| {
        match maybe_patch {
            None =&gt; {continue},
            Some(patch) =&gt; {
                families_exploit_patch(maybe_families.unwrap(), patch)
            }
        }
    }.for_each(|()| ());

or such like? Or do I have to resort to one of the other options – and how do I then assess whether a big compound `HashMap&lt;NodeID, (Vec&lt;Family&gt;, Patch)&gt;` is better than an `Arc&lt;Mutex&lt;HashMap&lt;NodeID, Patch&gt;&gt;&gt;`?
## [11][PinePhone Gtk Rust Starter](https://www.reddit.com/r/rust/comments/hye132/pinephone_gtk_rust_starter/)
- url: https://github.com/richardanaya/pinephone-gtk-rs-starter
---

## [12][Per @ryan_levick: If you’re interested in making Windows applications with WinUI and XAML, let the team know by upvoting this issue!](https://www.reddit.com/r/rust/comments/hy65qk/per_ryan_levick_if_youre_interested_in_making/)
- url: https://github.com/microsoft/microsoft-ui-xaml/issues/2488
---

