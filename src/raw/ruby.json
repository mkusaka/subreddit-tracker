{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "## Prerequisite\n\n1. If using rails then use the gem `google-api-client`\n2. I am considering here that you already have the `access_token` of the user. I will write a different blog to explain how to get that.\n\n## 1) Do full initial synch of events\n\nIt has the following steps -\n\n* Fetch a new `access_token` if the token has expired.\n* Create the service authorization object which will be used for fetching the events.\n\nRef code for `service authorization`\n\n    def create_service_auth\n      #create service auth\n      @service = Google::Apis::CalendarV3::CalendarService.new\n      @service.authorization = token.google_secret.to_authorization\n      return unless token.expired?\n    \n      new_access_token = @service.authorization.refresh! #refresh access_token\n    end\n\n* Fetching all calendar events(past, present and future).\n   * The full sync is the original request for all the resources of the collection you want to synchronize.\n   * In the response to the list operation, you will find a field called nextSyncToken representing a sync token. You'll need to store the value of nextSyncToken. If the result set is too large and the response gets paginated, then the nextSyncToken field is present only on the very last page.\n   * Depending on what your use case is, it will be better to perform this job as a background task.\n   * [Events: list API](https://developers.google.com/calendar/v3/reference/events/list) is used for this. The gem provides an easier method called `list_events`\n\nRef code for `syncing events`\n\n      def get_events\n        @events_arr = []\n        @events_list = @service.list_events('primary', single_events: true, max_results: 500)\n        @sync_token = @events_list.next_sync_token\n        @page_token = @events_list.next_page_token\n        @events_arr &lt;&lt; @events_list.items\n        while @sync_token.blank?\n          @events_list = @service.list_events('primary', single_events: true, max_results: 500, page_token: @page_token)\n          @sync_token = @events_list.next_sync_token\n          @page_token = @events_list.next_page_token\n          @events_arr &lt;&lt; @events_list.items\n        end\n      end\n\n## 2) Create a webhook to receive push notifications\n\nAfter a full sync of events, the next step is to setup a Webhook so that google can inform us of the changes that we subscribe for. For every user that links their calendar to the app, we will create a subscription so that we can be informed whenever there is a change in their calendar.\n\nIt has the following steps -\n\n* Fetch a new `access_token` if the token has expired.\n* Create the service authorisation object which will be used for fetching the events, exactly same as shown above.\n* Set up a Channel - It creates a channel with google and specifies the callback URL or the web-hook URL.\n* Watch events - After the web-hook is set up, we need to specify what events we want to watch and also need to specify from which calendar.\n\n&amp;#8203;\n\n    def setup_channel\n      @channel = Google::Apis::CalendarV3::Channel.new(address: callback_url, id: channel_id, type: \"web_hook\")\n    end\n\n`callback_url` \\- It can't be localhost, it has to be a valid `https` url. For testing purposes you can use [ngrok](https://ngrok.com/). `channel_id` \\- This is a UUID - `SecureRandom.uuid`\n\n      def watch_events\n        time_min = DateTime.now.rfc3339\n        @webhook = @service.watch_event('primary', @channel, single_events: true, time_min: time_min)\n      end\n\n`primary` \\- refers to the `primary` calendar of the user. `single_events` \\- Setting it to true also gives all events belonging to 1 single recurring event.\n\nNow, whenever there will be any change in the primary calendar of the user google will hit the registered web-hook for the user.\n\nIn the request Google will pass `X-Goog-Resource-ID` and `X-Goog-Channel-ID`. We would have to hit the `list_events` API again to fetch the changed events data for that user.\n\nOnly difference will be that instead of passing the page token like we did earlier, we would pass the `sync_token`.\n\n      def get_events\n        @events_list = @service.list_events('primary', single_events: true, max_results: 2500, sync_token: sync_token)\n      end\n\n## 3) Saving X-Goog-Resource-ID &amp; X-Goog-Channel-ID\n\nWhen we created the web-hook google will return us with a `resource_id`, `resource_uri`, `id`(that we created). We need to save all this data so that we can get to know for which user the events have changed. Also the channel expires in around 1 week so we need to keep creating new web-hooks before it expires.\n\n## 3) Deleting the events with status cancelled\n\nThis is the flow that took me some time to understand. So what happens when a user changes the time of their event or has the user changed a single event or all the events in a recurring event. What google does is that\n\n* if the user changes a single event, then google keeps the `calendar_id` as same.\n* if the user changes a recurring event and selects `all` or `following events` as option then the `calendar_id` changes for all the events. Hence, in this case we need to delete the old events and add new events in our system. So, this is a check that you will have to add when saving the calendar events in your system.\n\nThat's it - It's quite messy if you are trying to figure it out from scratch and I hope this article will help you all.", "author_fullname": "t2_66mla47a", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Integrating with Google Calendar - The Right Way", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": "", "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_gv5hdk", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.93, "author_flair_background_color": null, "subreddit_type": "public", "ups": 12, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Blog post", "can_mod_post": false, "score": 12, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": 1591096907.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "self", "content_categories": null, "is_self": true, "mod_note": null, "created": 1591125520.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;h2&gt;Prerequisite&lt;/h2&gt;\n\n&lt;ol&gt;\n&lt;li&gt;If using rails then use the gem &lt;code&gt;google-api-client&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;I am considering here that you already have the &lt;code&gt;access_token&lt;/code&gt; of the user. I will write a different blog to explain how to get that.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;h2&gt;1) Do full initial synch of events&lt;/h2&gt;\n\n&lt;p&gt;It has the following steps -&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Fetch a new &lt;code&gt;access_token&lt;/code&gt; if the token has expired.&lt;/li&gt;\n&lt;li&gt;Create the service authorization object which will be used for fetching the events.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Ref code for &lt;code&gt;service authorization&lt;/code&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;def create_service_auth\n  #create service auth\n  @service = Google::Apis::CalendarV3::CalendarService.new\n  @service.authorization = token.google_secret.to_authorization\n  return unless token.expired?\n\n  new_access_token = @service.authorization.refresh! #refresh access_token\nend\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Fetching all calendar events(past, present and future).\n\n&lt;ul&gt;\n&lt;li&gt;The full sync is the original request for all the resources of the collection you want to synchronize.&lt;/li&gt;\n&lt;li&gt;In the response to the list operation, you will find a field called nextSyncToken representing a sync token. You&amp;#39;ll need to store the value of nextSyncToken. If the result set is too large and the response gets paginated, then the nextSyncToken field is present only on the very last page.&lt;/li&gt;\n&lt;li&gt;Depending on what your use case is, it will be better to perform this job as a background task.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://developers.google.com/calendar/v3/reference/events/list\"&gt;Events: list API&lt;/a&gt; is used for this. The gem provides an easier method called &lt;code&gt;list_events&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Ref code for &lt;code&gt;syncing events&lt;/code&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;  def get_events\n    @events_arr = []\n    @events_list = @service.list_events(&amp;#39;primary&amp;#39;, single_events: true, max_results: 500)\n    @sync_token = @events_list.next_sync_token\n    @page_token = @events_list.next_page_token\n    @events_arr &amp;lt;&amp;lt; @events_list.items\n    while @sync_token.blank?\n      @events_list = @service.list_events(&amp;#39;primary&amp;#39;, single_events: true, max_results: 500, page_token: @page_token)\n      @sync_token = @events_list.next_sync_token\n      @page_token = @events_list.next_page_token\n      @events_arr &amp;lt;&amp;lt; @events_list.items\n    end\n  end\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;2) Create a webhook to receive push notifications&lt;/h2&gt;\n\n&lt;p&gt;After a full sync of events, the next step is to setup a Webhook so that google can inform us of the changes that we subscribe for. For every user that links their calendar to the app, we will create a subscription so that we can be informed whenever there is a change in their calendar.&lt;/p&gt;\n\n&lt;p&gt;It has the following steps -&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Fetch a new &lt;code&gt;access_token&lt;/code&gt; if the token has expired.&lt;/li&gt;\n&lt;li&gt;Create the service authorisation object which will be used for fetching the events, exactly same as shown above.&lt;/li&gt;\n&lt;li&gt;Set up a Channel - It creates a channel with google and specifies the callback URL or the web-hook URL.&lt;/li&gt;\n&lt;li&gt;Watch events - After the web-hook is set up, we need to specify what events we want to watch and also need to specify from which calendar.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&amp;#8203;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;def setup_channel\n  @channel = Google::Apis::CalendarV3::Channel.new(address: callback_url, id: channel_id, type: &amp;quot;web_hook&amp;quot;)\nend\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;callback_url&lt;/code&gt; - It can&amp;#39;t be localhost, it has to be a valid &lt;code&gt;https&lt;/code&gt; url. For testing purposes you can use &lt;a href=\"https://ngrok.com/\"&gt;ngrok&lt;/a&gt;. &lt;code&gt;channel_id&lt;/code&gt; - This is a UUID - &lt;code&gt;SecureRandom.uuid&lt;/code&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;  def watch_events\n    time_min = DateTime.now.rfc3339\n    @webhook = @service.watch_event(&amp;#39;primary&amp;#39;, @channel, single_events: true, time_min: time_min)\n  end\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;primary&lt;/code&gt; - refers to the &lt;code&gt;primary&lt;/code&gt; calendar of the user. &lt;code&gt;single_events&lt;/code&gt; - Setting it to true also gives all events belonging to 1 single recurring event.&lt;/p&gt;\n\n&lt;p&gt;Now, whenever there will be any change in the primary calendar of the user google will hit the registered web-hook for the user.&lt;/p&gt;\n\n&lt;p&gt;In the request Google will pass &lt;code&gt;X-Goog-Resource-ID&lt;/code&gt; and &lt;code&gt;X-Goog-Channel-ID&lt;/code&gt;. We would have to hit the &lt;code&gt;list_events&lt;/code&gt; API again to fetch the changed events data for that user.&lt;/p&gt;\n\n&lt;p&gt;Only difference will be that instead of passing the page token like we did earlier, we would pass the &lt;code&gt;sync_token&lt;/code&gt;.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;  def get_events\n    @events_list = @service.list_events(&amp;#39;primary&amp;#39;, single_events: true, max_results: 2500, sync_token: sync_token)\n  end\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;3) Saving X-Goog-Resource-ID &amp;amp; X-Goog-Channel-ID&lt;/h2&gt;\n\n&lt;p&gt;When we created the web-hook google will return us with a &lt;code&gt;resource_id&lt;/code&gt;, &lt;code&gt;resource_uri&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;(that we created). We need to save all this data so that we can get to know for which user the events have changed. Also the channel expires in around 1 week so we need to keep creating new web-hooks before it expires.&lt;/p&gt;\n\n&lt;h2&gt;3) Deleting the events with status cancelled&lt;/h2&gt;\n\n&lt;p&gt;This is the flow that took me some time to understand. So what happens when a user changes the time of their event or has the user changed a single event or all the events in a recurring event. What google does is that&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;if the user changes a single event, then google keeps the &lt;code&gt;calendar_id&lt;/code&gt; as same.&lt;/li&gt;\n&lt;li&gt;if the user changes a recurring event and selects &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;following events&lt;/code&gt; as option then the &lt;code&gt;calendar_id&lt;/code&gt; changes for all the events. Hence, in this case we need to delete the old events and add new events in our system. So, this is a check that you will have to add when saving the calendar events in your system.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;That&amp;#39;s it - It&amp;#39;s quite messy if you are trying to figure it out from scratch and I hope this article will help you all.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/ygz_fclp_0WPUQBlhqXrdPh1Nd-kse3ARg-281Tuo58.jpg?auto=webp&amp;s=327e70ab8f939202417355e89115bcb6aacfd704", "width": 1200, "height": 630}, "resolutions": [{"url": "https://external-preview.redd.it/ygz_fclp_0WPUQBlhqXrdPh1Nd-kse3ARg-281Tuo58.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=4d800531def0068d8cc3e8bacd30ea6b6eb05a80", "width": 108, "height": 56}, {"url": "https://external-preview.redd.it/ygz_fclp_0WPUQBlhqXrdPh1Nd-kse3ARg-281Tuo58.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=178b71c441cd59609c3d604c27c6a87e1fb2a98d", "width": 216, "height": 113}, {"url": "https://external-preview.redd.it/ygz_fclp_0WPUQBlhqXrdPh1Nd-kse3ARg-281Tuo58.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=c58ebc0f776b8bffe3964f807f2e4c61b6250298", "width": 320, "height": 168}, {"url": "https://external-preview.redd.it/ygz_fclp_0WPUQBlhqXrdPh1Nd-kse3ARg-281Tuo58.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=fb354a0402d2b35c096d7d28450f47547d16c003", "width": 640, "height": 336}, {"url": "https://external-preview.redd.it/ygz_fclp_0WPUQBlhqXrdPh1Nd-kse3ARg-281Tuo58.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=0837541ec7890e363ada335e4587579ae6871534", "width": 960, "height": 504}, {"url": "https://external-preview.redd.it/ygz_fclp_0WPUQBlhqXrdPh1Nd-kse3ARg-281Tuo58.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=6a6e61f94d5a8d5f05625859410983455695ea7c", "width": 1080, "height": 567}], "variants": {}, "id": "BolT03JhjNp7AmOz5GnB329kjhm5G63ZCQszHrsJ4D0"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "c8896134-873c-11e9-8edb-0e1f22813c3e", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gv5hdk", "is_robot_indexable": true, "report_reasons": null, "author": "ydshmmt", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/gv5hdk/integrating_with_google_calendar_the_right_way/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/gv5hdk/integrating_with_google_calendar_the_right_way/", "subreddit_subscribers": 65520, "created_utc": 1591096720.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "", "author_fullname": "t2_3vuyt", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Writing better StimulusJS controllers", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": 140, "top_awarded_type": null, "hide_score": false, "name": "t3_gullws", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.92, "author_flair_background_color": null, "subreddit_type": "public", "ups": 53, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 53, "approved_by": null, "author_premium": false, "thumbnail": "https://b.thumbs.redditmedia.com/JvOtQOzHaO41Itk1Tk7cDhTVPcPi5oi9lD3ULGrYLkY.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "link", "content_categories": null, "is_self": false, "mod_note": null, "created": 1591050532.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "boringrails.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/jyJ8Aq4aN2iqFTjn9GeufiYcwPLGl9LMhhX4xFpgch8.jpg?auto=webp&amp;s=e2c97ac6cf5c4b47cac16260f06a95044f3ebcc0", "width": 400, "height": 400}, "resolutions": [{"url": "https://external-preview.redd.it/jyJ8Aq4aN2iqFTjn9GeufiYcwPLGl9LMhhX4xFpgch8.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=27c7fc92c5e6e2aeab9c92662861fd9012d18b08", "width": 108, "height": 108}, {"url": "https://external-preview.redd.it/jyJ8Aq4aN2iqFTjn9GeufiYcwPLGl9LMhhX4xFpgch8.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=3a05f229a3a32d138df926d02c501765402a33d8", "width": 216, "height": 216}, {"url": "https://external-preview.redd.it/jyJ8Aq4aN2iqFTjn9GeufiYcwPLGl9LMhhX4xFpgch8.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=2fbdfb0ab2e4c054f2e1ccd5ef71946e1d03c73b", "width": 320, "height": 320}], "variants": {}, "id": "Nqd_AZ9ctyNgtIuRXmlL5NmB4sZ_-RJGrjdDz1DdnpI"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gullws", "is_robot_indexable": true, "report_reasons": null, "author": "_swanson", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/gullws/writing_better_stimulusjs_controllers/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://boringrails.com/articles/better-stimulus-controllers/", "subreddit_subscribers": 65520, "created_utc": 1591021732.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "After forking from git hub, running rake or  ruby path\\_to\\_enlightenment.rb  in  koans returns \n\n    Thinking AboutAsserts\n      test_assert_truth has damaged your karma.\n    \n    You have not yet reached enlightenment ...\n    &lt;false&gt; is not true.\n    \n    Please meditate on the following code:\n    Traceback (most recent call last):\n            2: from /mnt/c/Users/skywalker/dev/flatiron/projects/ruby_koans/koans/edgecase.rb:265:in `block in &lt;top (required)&gt;'\n            1: from /mnt/c/Users/skywalker/dev/flatiron/projects/ruby_koans/koans/edgecase.rb:112:in `report'\n    /mnt/c/Users/skywalker/dev/flatiron/projects/ruby_koans/koans/edgecase.rb:102:in `assert_failed?': uninitialized constant EdgeCase::Sensei::AssertionError (NameError)\n\nwhat is this \n\n    uninitialized constant EdgeCase::Sensei::AssertionError (NameError)", "author_fullname": "t2_576gwujx", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "New error after forking ruby Koans from a not \"10 yr old repo\"", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_guyr6v", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.86, "author_flair_background_color": null, "subreddit_type": "public", "ups": 5, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 5, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591093891.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;After forking from git hub, running rake or  ruby path_to_enlightenment.rb  in  koans returns &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Thinking AboutAsserts\n  test_assert_truth has damaged your karma.\n\nYou have not yet reached enlightenment ...\n&amp;lt;false&amp;gt; is not true.\n\nPlease meditate on the following code:\nTraceback (most recent call last):\n        2: from /mnt/c/Users/skywalker/dev/flatiron/projects/ruby_koans/koans/edgecase.rb:265:in `block in &amp;lt;top (required)&amp;gt;&amp;#39;\n        1: from /mnt/c/Users/skywalker/dev/flatiron/projects/ruby_koans/koans/edgecase.rb:112:in `report&amp;#39;\n/mnt/c/Users/skywalker/dev/flatiron/projects/ruby_koans/koans/edgecase.rb:102:in `assert_failed?&amp;#39;: uninitialized constant EdgeCase::Sensei::AssertionError (NameError)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;what is this &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;uninitialized constant EdgeCase::Sensei::AssertionError (NameError)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "guyr6v", "is_robot_indexable": true, "report_reasons": null, "author": "brkk_thewrst_wlkaway", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/guyr6v/new_error_after_forking_ruby_koans_from_a_not_10/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/guyr6v/new_error_after_forking_ruby_koans_from_a_not_10/", "subreddit_subscribers": 65520, "created_utc": 1591065091.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "", "author_fullname": "t2_y496k", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "ActiveRecord's STI gotchas", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_gv2nuk", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.75, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "default", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1591111144.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "blog.capsens.eu", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gv2nuk", "is_robot_indexable": true, "report_reasons": null, "author": "younes_s", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/gv2nuk/activerecords_sti_gotchas/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://blog.capsens.eu/why-you-should-avoid-nested-sti-activerecord-rails-6-b180f1bcc029?source=friends_link&amp;sk=ad41cf73d1ec992f26ccede46400c1fa", "subreddit_subscribers": 65520, "created_utc": 1591082344.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "[https://github.com/VAGAScom/somecache](https://github.com/VAGAScom/somecache)", "author_fullname": "t2_4nimnxfd", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Somecache - A micro library to create and reuse cache configurations", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_guvelz", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.91, "author_flair_background_color": null, "subreddit_type": "public", "ups": 9, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 9, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "self", "content_categories": null, "is_self": true, "mod_note": null, "created": 1591081968.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;a href=\"https://github.com/VAGAScom/somecache\"&gt;https://github.com/VAGAScom/somecache&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/ChquxUszyg_3twWMR0U1jyuJnWCK87vJkoSrTx3tzwM.jpg?auto=webp&amp;s=7bc4094c309466f1665dbe2d907319600444b02b", "width": 200, "height": 200}, "resolutions": [{"url": "https://external-preview.redd.it/ChquxUszyg_3twWMR0U1jyuJnWCK87vJkoSrTx3tzwM.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=53ed8acff548d86ca921065284f502bc25859e3d", "width": 108, "height": 108}], "variants": {}, "id": "NJ3tjq26_XcMu-BDO6A03JgKD6kFTvwgGNsgeN73xFo"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "guvelz", "is_robot_indexable": true, "report_reasons": null, "author": "catks", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/guvelz/somecache_a_micro_library_to_create_and_reuse/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/guvelz/somecache_a_micro_library_to_create_and_reuse/", "subreddit_subscribers": 65520, "created_utc": 1591053168.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "", "author_fullname": "t2_32aqmyw", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Full page caching in Rails with Nginx and Redis", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": 140, "top_awarded_type": null, "hide_score": false, "name": "t3_guqwnm", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.83, "author_flair_background_color": null, "subreddit_type": "public", "ups": 8, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 8, "approved_by": null, "author_premium": false, "thumbnail": "https://a.thumbs.redditmedia.com/o6vxHCELaZvjuTacu0z_6470ZbbmxIk-SdM6kH_CYy8.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "link", "content_categories": null, "is_self": false, "mod_note": null, "created": 1591067757.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "vitobotta.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/NWycPipct6hgh1S_mTWLdFi09PRlK0m3o7Jiol4TU18.jpg?auto=webp&amp;s=ae01dd57aec4b336118c4c3a6886d4b7b50f5d6a", "width": 347, "height": 347}, "resolutions": [{"url": "https://external-preview.redd.it/NWycPipct6hgh1S_mTWLdFi09PRlK0m3o7Jiol4TU18.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=07cf964d733a327931f87ef9fbec63d14799d104", "width": 108, "height": 108}, {"url": "https://external-preview.redd.it/NWycPipct6hgh1S_mTWLdFi09PRlK0m3o7Jiol4TU18.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=2a91827b6db854e140d303511460033933afa9cf", "width": 216, "height": 216}, {"url": "https://external-preview.redd.it/NWycPipct6hgh1S_mTWLdFi09PRlK0m3o7Jiol4TU18.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=c79b207bdeebb54e416932e371bfa95ddae98b01", "width": 320, "height": 320}], "variants": {}, "id": "iBFdDOa-paizQmlySIH0LanyKLtOb4WTLUPL7LJT7D8"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "guqwnm", "is_robot_indexable": true, "report_reasons": null, "author": "Sky_Linx", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/guqwnm/full_page_caching_in_rails_with_nginx_and_redis/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://vitobotta.com/2020/06/01/full-page-caching-in-rails-with-nginx-and-redis/", "subreddit_subscribers": 65520, "created_utc": 1591038957.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "Hey, everyone.  Apologies in advance if this is a dumb question that has been answered a million times.\n\nI'm looking for an explanation of how Ruby/Bundler loads the correct version of sub-dependencies across multiple projects or gems on the same system (for example, multiple one-off projects on my local machine).  For example:\n\n\\- Project A requires gem B (v1)  \n\n\\- Project C requires gem B (v2)\n\nI can see multiple versions of the same gem installed (I apparently decided to use RVM at some point; not sure if that's affecting things), but if different versions of gem B need to be installed or used, how is the correct version chosen?  Is a common version chosen and installed, and projects A and C both use the version?  Or, is the system able to load different versions for projects A and C at runtime?\n\nI hunted around on Google, but was not able to find any good explanations of how it works.  If anyone could help me out, I would greatly appreciate it!", "author_fullname": "t2_3yey4kfe", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Question about gem dependencies and versions", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": "", "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_gurldl", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.89, "author_flair_background_color": null, "subreddit_type": "public", "ups": 7, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Question", "can_mod_post": false, "score": 7, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": 1591044576.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591069857.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hey, everyone.  Apologies in advance if this is a dumb question that has been answered a million times.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m looking for an explanation of how Ruby/Bundler loads the correct version of sub-dependencies across multiple projects or gems on the same system (for example, multiple one-off projects on my local machine).  For example:&lt;/p&gt;\n\n&lt;p&gt;- Project A requires gem B (v1)  &lt;/p&gt;\n\n&lt;p&gt;- Project C requires gem B (v2)&lt;/p&gt;\n\n&lt;p&gt;I can see multiple versions of the same gem installed (I apparently decided to use RVM at some point; not sure if that&amp;#39;s affecting things), but if different versions of gem B need to be installed or used, how is the correct version chosen?  Is a common version chosen and installed, and projects A and C both use the version?  Or, is the system able to load different versions for projects A and C at runtime?&lt;/p&gt;\n\n&lt;p&gt;I hunted around on Google, but was not able to find any good explanations of how it works.  If anyone could help me out, I would greatly appreciate it!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "d3392e70-873c-11e9-af37-0eea3fce36a6", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gurldl", "is_robot_indexable": true, "report_reasons": null, "author": "TheFakeZzig", "discussion_type": null, "num_comments": 7, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/gurldl/question_about_gem_dependencies_and_versions/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/gurldl/question_about_gem_dependencies_and_versions/", "subreddit_subscribers": 65520, "created_utc": 1591041057.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "I have been spending a bit of time in Python since discovering the Tornado framework, but I still can't get to love Python the way I love Ruby.\n\nI am looking for a Ruby framework that supports non-blocking HTTP requests and also WebSockets.\n\nFrom looking around, it seems like you have to cobble something together from different libraries. Or it is possible with an existing framework but that they don't mention it explicitly because it's a given that it would support it.", "author_fullname": "t2_6tztgtm", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Is there an equivalent framework to Tornado (Python) in Ruby?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_guhanp", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 21, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 21, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591031551.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I have been spending a bit of time in Python since discovering the Tornado framework, but I still can&amp;#39;t get to love Python the way I love Ruby.&lt;/p&gt;\n\n&lt;p&gt;I am looking for a Ruby framework that supports non-blocking HTTP requests and also WebSockets.&lt;/p&gt;\n\n&lt;p&gt;From looking around, it seems like you have to cobble something together from different libraries. Or it is possible with an existing framework but that they don&amp;#39;t mention it explicitly because it&amp;#39;s a given that it would support it.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "guhanp", "is_robot_indexable": true, "report_reasons": null, "author": "mydoghasticks", "discussion_type": null, "num_comments": 8, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/guhanp/is_there_an_equivalent_framework_to_tornado/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/guhanp/is_there_an_equivalent_framework_to_tornado/", "subreddit_subscribers": 65520, "created_utc": 1591002751.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": " \n\nJust starting with Ruby Koans as a way to practice aside from traditional homework.\n\nFollowing the outlined instructions on the Koans site it says to run\n\n    ruby path_to_enlightenment.rb\n\nwhich should return\n\n    [ ruby_koans ] $ ruby  path_to_enlightenment.rb (in /Users/person/dev/ruby_koans) cd koans  Thinking AboutAsserts test_assert_truth has damaged your karma. You have not yet reached enlightenment ... &lt;false&gt; is not true. Please meditate on the following code: ./about_asserts.rb:10:in `test_assert_truth' path_to_enlightenment.rb:27  mountains are merely mountains\n\nbut instead is returning\n\n    ruby path_to_enlightenment.rb  Thinking AboutAsserts test_assert_truth has damaged your karma. You have not yet reached enlightenment ... &lt;false&gt; is not true. Please meditate on the following code: Traceback (most recent call last): 2: from  /mnt/c/Users/skywalker/ruby_koans/koans/edgecase.rb:265:in `block in &lt;top (required)&gt;' 1: from /mnt/c/Users/skywalker/ruby_koans/koans/edgecase.rb:112:in `report' /mnt/c/Users/skywalker/ruby_koans/koans/edgecase.rb:102:in `assert_failed?': uninitialized constant  EdgeCase::Sensei::AssertionError (NameError)\n\nWould anyone know why im getting this unitialized constant error ?\n\n    uninitialized constant  EdgeCase::Sensei::AssertionError (NameError)\n\nI highly doubt the very first test would ask be to fix an unitialized constant error and no where in the read does it say to do so. Would you know why im getting this error and how i could fix it ?\n\nThe only thing i can think of is maybe Koans is not compatible with Ruby 2.6 ?", "author_fullname": "t2_576gwujx", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Is ruby koans compatible with ruby 2.6.1?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_gup0ot", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591061917.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Just starting with Ruby Koans as a way to practice aside from traditional homework.&lt;/p&gt;\n\n&lt;p&gt;Following the outlined instructions on the Koans site it says to run&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;ruby path_to_enlightenment.rb\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which should return&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;[ ruby_koans ] $ ruby  path_to_enlightenment.rb (in /Users/person/dev/ruby_koans) cd koans  Thinking AboutAsserts test_assert_truth has damaged your karma. You have not yet reached enlightenment ... &amp;lt;false&amp;gt; is not true. Please meditate on the following code: ./about_asserts.rb:10:in `test_assert_truth&amp;#39; path_to_enlightenment.rb:27  mountains are merely mountains\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;but instead is returning&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;ruby path_to_enlightenment.rb  Thinking AboutAsserts test_assert_truth has damaged your karma. You have not yet reached enlightenment ... &amp;lt;false&amp;gt; is not true. Please meditate on the following code: Traceback (most recent call last): 2: from  /mnt/c/Users/skywalker/ruby_koans/koans/edgecase.rb:265:in `block in &amp;lt;top (required)&amp;gt;&amp;#39; 1: from /mnt/c/Users/skywalker/ruby_koans/koans/edgecase.rb:112:in `report&amp;#39; /mnt/c/Users/skywalker/ruby_koans/koans/edgecase.rb:102:in `assert_failed?&amp;#39;: uninitialized constant  EdgeCase::Sensei::AssertionError (NameError)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Would anyone know why im getting this unitialized constant error ?&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;uninitialized constant  EdgeCase::Sensei::AssertionError (NameError)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I highly doubt the very first test would ask be to fix an unitialized constant error and no where in the read does it say to do so. Would you know why im getting this error and how i could fix it ?&lt;/p&gt;\n\n&lt;p&gt;The only thing i can think of is maybe Koans is not compatible with Ruby 2.6 ?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gup0ot", "is_robot_indexable": true, "report_reasons": null, "author": "brkk_thewrst_wlkaway", "discussion_type": null, "num_comments": 5, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/gup0ot/is_ruby_koans_compatible_with_ruby_261/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/gup0ot/is_ruby_koans_compatible_with_ruby_261/", "subreddit_subscribers": 65520, "created_utc": 1591033117.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "So, I have a lightweight ruby gRPC server running with docker and kubernetes. No threading or forking. I\u2019ve used rails / rack apps for a long time, and I\u2019m used to having some sense of concurrency via webrick, unicorn, puma, passenger. \n\nMy question is around concurrency. Since this service has such a small footprint, of like 10m cpu and 10mb of ram, would it be best to scale up the pods and let the cluster handle the load balancing? My searches for \u201cruby grpc concurrency\u201d were not fruitful, so there doesn\u2019t seem to be anything out of the box for going the \u201ctraditional\u201d way.", "author_fullname": "t2_8edif", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "gRPC concurrency", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": "", "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_guffav", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.92, "author_flair_background_color": null, "subreddit_type": "public", "ups": 9, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Question", "can_mod_post": false, "score": 9, "approved_by": null, "author_premium": true, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591022075.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;So, I have a lightweight ruby gRPC server running with docker and kubernetes. No threading or forking. I\u2019ve used rails / rack apps for a long time, and I\u2019m used to having some sense of concurrency via webrick, unicorn, puma, passenger. &lt;/p&gt;\n\n&lt;p&gt;My question is around concurrency. Since this service has such a small footprint, of like 10m cpu and 10mb of ram, would it be best to scale up the pods and let the cluster handle the load balancing? My searches for \u201cruby grpc concurrency\u201d were not fruitful, so there doesn\u2019t seem to be anything out of the box for going the \u201ctraditional\u201d way.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "d3392e70-873c-11e9-af37-0eea3fce36a6", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "guffav", "is_robot_indexable": true, "report_reasons": null, "author": "Mallanaga", "discussion_type": null, "num_comments": 6, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/guffav/grpc_concurrency/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/guffav/grpc_concurrency/", "subreddit_subscribers": 65520, "created_utc": 1590993275.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_guffav", "before": null}}