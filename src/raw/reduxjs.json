{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "", "author_fullname": "t2_qou9d", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Implementing Undo-Redo with NgRx or Redux", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f3q1rp", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 4, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 4, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581702807.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "nils-mehlhorn.de", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f3q1rp", "is_robot_indexable": true, "report_reasons": null, "author": "nilomatix", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/f3q1rp/implementing_undoredo_with_ngrx_or_redux/", "parent_whitelist_status": null, "stickied": false, "url": "https://nils-mehlhorn.de/posts/angular-undo-redo-ngrx-redux", "subreddit_subscribers": 3241, "created_utc": 1581674007.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "", "author_fullname": "t2_qtig0", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "React \u2014 state management without libraries (with hooks) PART 2", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f2ofaw", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 6, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 6, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581526706.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "medium.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f2ofaw", "is_robot_indexable": true, "report_reasons": null, "author": "Fewthp", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/f2ofaw/react_state_management_without_libraries_with/", "parent_whitelist_status": null, "stickied": false, "url": "https://medium.com//react-state-management-without-libraries-with-hooks-part-2-d087278185a9?source=friends_link&amp;sk=a184f029f305821c4c57d2c249d0042b", "subreddit_subscribers": 3241, "created_utc": 1581497906.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "", "author_fullname": "t2_14meq9", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Redux Controllers -&gt; Less verbose Redux for people who love typescript - State Observables | State Subscriptions | State Watchers | Async Actions | Inbuilt Caching | React | Angular | Node | Redux Effects | Provided States", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f2cesn", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581473939.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "npmjs.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f2cesn", "is_robot_indexable": true, "report_reasons": null, "author": "ragularuban", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/f2cesn/redux_controllers_less_verbose_redux_for_people/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.npmjs.com/package/redux-controllers", "subreddit_subscribers": 3241, "created_utc": 1581445139.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "I am watching a tutorial atm, and he said you can set up a Store if you like.\n\nBut he appears to be putting, what would be the Store, in the index.js file (in the client side).\n\nIs this common practice? Has anyone seen this 'style' of organization before?", "author_fullname": "t2_3d4nk8bf", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Do I need a Store?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f1061x", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581235250.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I am watching a tutorial atm, and he said you can set up a Store if you like.&lt;/p&gt;\n\n&lt;p&gt;But he appears to be putting, what would be the Store, in the index.js file (in the client side).&lt;/p&gt;\n\n&lt;p&gt;Is this common practice? Has anyone seen this &amp;#39;style&amp;#39; of organization before?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f1061x", "is_robot_indexable": true, "report_reasons": null, "author": "bigbobbyboy5", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/f1061x/do_i_need_a_store/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/f1061x/do_i_need_a_store/", "subreddit_subscribers": 3241, "created_utc": 1581206450.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "Would this be a sane way to ensure that for \\[\\] each time is true on reference equality. E.g. if that state.items remain undefined each time I use a fallback \\[\\] would fail reference equality - is useRef the right approach here? (rather not use shallowEquality)\n\n    const items = useSelector((state) =&gt; state.items || useRef([]).current);", "author_fullname": "t2_5kbr38a2", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Redux - useSelector empty array equality", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f0m1l4", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581162100.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Would this be a sane way to ensure that for [] each time is true on reference equality. E.g. if that state.items remain undefined each time I use a fallback [] would fail reference equality - is useRef the right approach here? (rather not use shallowEquality)&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const items = useSelector((state) =&amp;gt; state.items || useRef([]).current);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f0m1l4", "is_robot_indexable": true, "report_reasons": null, "author": "mattredux1", "discussion_type": null, "num_comments": 7, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/f0m1l4/redux_useselector_empty_array_equality/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/f0m1l4/redux_useselector_empty_array_equality/", "subreddit_subscribers": 3241, "created_utc": 1581133300.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "So currently I have an event called ITEM\\_DELETED.\n\nWhen this happens, I update the items part of the state to filter out the item that was deleted.\n\nBut I also want to reset a variable (in **another** part of the state) to 0, IF the item that was deleted is currently selected\n\nWhat's the best practice to do this when I'm using **combineReducers** and the state is separated out, so the reducer doesn't necessarily know if the item was originally selected.\n\nI'm currently thinking:\n\n1. Probably best, the action creator puts a boolean in the payload if the item deleted was selected, that way the reducers can still respond to the same action type.\n2. I can update the action creator to use thunk and dispatch two actions, the second with a different type and only being if the item was currently selected\n3. Something else? Make the state combined so one reducer can handle the action?\n\nThanks!", "author_fullname": "t2_jnlwhi0", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Conditional update in reducer based on other state. Best Practices?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f05rab", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581081132.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;So currently I have an event called ITEM_DELETED.&lt;/p&gt;\n\n&lt;p&gt;When this happens, I update the items part of the state to filter out the item that was deleted.&lt;/p&gt;\n\n&lt;p&gt;But I also want to reset a variable (in &lt;strong&gt;another&lt;/strong&gt; part of the state) to 0, IF the item that was deleted is currently selected&lt;/p&gt;\n\n&lt;p&gt;What&amp;#39;s the best practice to do this when I&amp;#39;m using &lt;strong&gt;combineReducers&lt;/strong&gt; and the state is separated out, so the reducer doesn&amp;#39;t necessarily know if the item was originally selected.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m currently thinking:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Probably best, the action creator puts a boolean in the payload if the item deleted was selected, that way the reducers can still respond to the same action type.&lt;/li&gt;\n&lt;li&gt;I can update the action creator to use thunk and dispatch two actions, the second with a different type and only being if the item was currently selected&lt;/li&gt;\n&lt;li&gt;Something else? Make the state combined so one reducer can handle the action?&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Thanks!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f05rab", "is_robot_indexable": true, "report_reasons": null, "author": "kcilc1", "discussion_type": null, "num_comments": 14, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/f05rab/conditional_update_in_reducer_based_on_other/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/f05rab/conditional_update_in_reducer_based_on_other/", "subreddit_subscribers": 3241, "created_utc": 1581052332.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "As you know, you can use object destructuring for an object to extract values with the same name:\n\n    const values = { 'name': 'John', 'age': 20, 'country': 'USA' }\n    const { name, age } = values\n\nBut when using Redux's useSelector hook, is it better to have them in their own calls or use the same logic?\n\nFor example, let's look at the initial state which is part of a reducer that will eventually be called userInfo in a combineReducers call:\n\n    const initialState = { 'name': '', 'age': 0, 'country': '' }\n\nIf I am in a component, is it better to do\n\n    const { name, age } = useSelector(state =&gt; state.userInfo)\n\nor\n\n    const name = useSelector(state =&gt; state.name)\n    const age = useSelector(state =&gt; state.age)\n    \nThe reason I ask is that the first example is one call but may initially bring in all the values for that userInfo state while the second example is more direct, but then also calls useSelector an additional time.\n\nTo be more performant and cut down on re-renders on data change, which one is the better method?", "author_fullname": "t2_atnwc", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Which is more performant for useSelector hook with multiple values?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_ezsw20", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581027112.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;As you know, you can use object destructuring for an object to extract values with the same name:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const values = { &amp;#39;name&amp;#39;: &amp;#39;John&amp;#39;, &amp;#39;age&amp;#39;: 20, &amp;#39;country&amp;#39;: &amp;#39;USA&amp;#39; }\nconst { name, age } = values\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;But when using Redux&amp;#39;s useSelector hook, is it better to have them in their own calls or use the same logic?&lt;/p&gt;\n\n&lt;p&gt;For example, let&amp;#39;s look at the initial state which is part of a reducer that will eventually be called userInfo in a combineReducers call:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const initialState = { &amp;#39;name&amp;#39;: &amp;#39;&amp;#39;, &amp;#39;age&amp;#39;: 0, &amp;#39;country&amp;#39;: &amp;#39;&amp;#39; }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If I am in a component, is it better to do&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const { name, age } = useSelector(state =&amp;gt; state.userInfo)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const name = useSelector(state =&amp;gt; state.name)\nconst age = useSelector(state =&amp;gt; state.age)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The reason I ask is that the first example is one call but may initially bring in all the values for that userInfo state while the second example is more direct, but then also calls useSelector an additional time.&lt;/p&gt;\n\n&lt;p&gt;To be more performant and cut down on re-renders on data change, which one is the better method?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ezsw20", "is_robot_indexable": true, "report_reasons": null, "author": "t3g", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/ezsw20/which_is_more_performant_for_useselector_hook/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/ezsw20/which_is_more_performant_for_useselector_hook/", "subreddit_subscribers": 3241, "created_utc": 1580998312.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "Hi!\n\nI am new to redux and was wondering if I am understanding the logic well.\n\nI have an API that returns a list of item (Object), with pagination and other filtering parameters.  \nI was thinking about modeling my state as follow:  \n\n\n    exampleParams = { search: \"name\", page: 1 };\n\n    after API call,\n    \n    state\n    {\n        items: {\n            [objectID]: Object,\n            ...\n        },\n        queries: {\n            [queryString.stringify(exampleParams)] = {\n                ids: Array[of objectID],\n                count: number,\n            },\n            ...\n        },\n    };\n\nI was thinking about implementing this in the case the user goes from page 1 to page 2, then comes back to page 1. Since i know the ids of the list returned by the API from a previous query, I wouldn't call the API again.\n\nIn this case, since i have the query results in the state, I can just use\n\n    queries[queryString.stringify(params)].ids.reduce((acc, id) =&gt; {...acc, [id]: items[id]}, {});\n\nwhen i come back to page 1.\n\nAm I thinking this the right way ? Is this the right use case of redux ?  \n\n\nThanks in advance for the feedbacks", "author_fullname": "t2_ir2sc", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How to structure the state", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_ez8t79", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1580934386.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hi!&lt;/p&gt;\n\n&lt;p&gt;I am new to redux and was wondering if I am understanding the logic well.&lt;/p&gt;\n\n&lt;p&gt;I have an API that returns a list of item (Object), with pagination and other filtering parameters.&lt;br/&gt;\nI was thinking about modeling my state as follow:  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;exampleParams = { search: &amp;quot;name&amp;quot;, page: 1 };\n\nafter API call,\n\nstate\n{\n    items: {\n        [objectID]: Object,\n        ...\n    },\n    queries: {\n        [queryString.stringify(exampleParams)] = {\n            ids: Array[of objectID],\n            count: number,\n        },\n        ...\n    },\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I was thinking about implementing this in the case the user goes from page 1 to page 2, then comes back to page 1. Since i know the ids of the list returned by the API from a previous query, I wouldn&amp;#39;t call the API again.&lt;/p&gt;\n\n&lt;p&gt;In this case, since i have the query results in the state, I can just use&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;queries[queryString.stringify(params)].ids.reduce((acc, id) =&amp;gt; {...acc, [id]: items[id]}, {});\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;when i come back to page 1.&lt;/p&gt;\n\n&lt;p&gt;Am I thinking this the right way ? Is this the right use case of redux ?  &lt;/p&gt;\n\n&lt;p&gt;Thanks in advance for the feedbacks&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ez8t79", "is_robot_indexable": true, "report_reasons": null, "author": "yugo9109", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/ez8t79/how_to_structure_the_state/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/ez8t79/how_to_structure_the_state/", "subreddit_subscribers": 3241, "created_utc": 1580905586.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "I have a bit of a love/hate relationship with Redux. I love the atomic state updates, persistable, replayable global state, and awesome middleware. However, like many others, I hate writing Redux - at least with the recommended design patterns. I experimented with various ways to write better Redux, but it took me a while to figure out the core problem...\n\n*The recommended way of using Redux breaks modular design.* Modular design is such a fundamental tool to scalable software engineering, of course Redux was a pain to use!\n\nOnce I had that insight, I was able to create a new, modular design pattern for using Redux that leveraged Redux's strengths while avoiding the weaknesses of previous design patterns.\n\nI'd love your feedback!\n\nModular Redux: [https://medium.com/@shanebdavis/modular-redux-a-design-pattern-for-mastering-scalable-shared-state-82d4abc0d7b3](https://medium.com/@shanebdavis/modular-redux-a-design-pattern-for-mastering-scalable-shared-state-82d4abc0d7b3)\n\n([cross-posted](https://www.reddit.com/r/reactjs/comments/eyuu7i/modular_redux_a_design_pattern_for_mastering/) on /r/reactjs)", "author_fullname": "t2_blgsn", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Modular Redux \u2014 a Design Pattern for Mastering Scalable, Shared State", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_eyuwgv", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 7, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 7, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1580842658.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1580871143.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I have a bit of a love/hate relationship with Redux. I love the atomic state updates, persistable, replayable global state, and awesome middleware. However, like many others, I hate writing Redux - at least with the recommended design patterns. I experimented with various ways to write better Redux, but it took me a while to figure out the core problem...&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;The recommended way of using Redux breaks modular design.&lt;/em&gt; Modular design is such a fundamental tool to scalable software engineering, of course Redux was a pain to use!&lt;/p&gt;\n\n&lt;p&gt;Once I had that insight, I was able to create a new, modular design pattern for using Redux that leveraged Redux&amp;#39;s strengths while avoiding the weaknesses of previous design patterns.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;d love your feedback!&lt;/p&gt;\n\n&lt;p&gt;Modular Redux: &lt;a href=\"https://medium.com/@shanebdavis/modular-redux-a-design-pattern-for-mastering-scalable-shared-state-82d4abc0d7b3\"&gt;https://medium.com/@shanebdavis/modular-redux-a-design-pattern-for-mastering-scalable-shared-state-82d4abc0d7b3&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;(&lt;a href=\"https://www.reddit.com/r/reactjs/comments/eyuu7i/modular_redux_a_design_pattern_for_mastering/\"&gt;cross-posted&lt;/a&gt; on &lt;a href=\"/r/reactjs\"&gt;/r/reactjs&lt;/a&gt;)&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "eyuwgv", "is_robot_indexable": true, "report_reasons": null, "author": "Shanebdavis", "discussion_type": null, "num_comments": 16, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/eyuwgv/modular_redux_a_design_pattern_for_mastering/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/eyuwgv/modular_redux_a_design_pattern_for_mastering/", "subreddit_subscribers": 3241, "created_utc": 1580842343.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "", "user_reports": [], "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "React Ninjas Newsletter #89: React Navigation v5 + React Native Paper = \u2764\ufe0f", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "parent_whitelist_status": null, "hide_score": false, "name": "t3_ez2ngi", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": "", "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "thumbnail": "", "edited": false, "author_flair_css_class": null, "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1580901027.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "domain": "reactninjs.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ez2ngi", "is_robot_indexable": true, "report_reasons": null, "author": "[deleted]", "discussion_type": null, "media": null, "send_replies": true, "contest_mode": false, "mod_reports": [], "author_flair_text_color": "dark", "permalink": "/r/reduxjs/comments/ez2ngi/react_ninjas_newsletter_89_react_navigation_v5/", "whitelist_status": null, "stickied": false, "url": "https://reactninjs.com/post/89-react-navigation-v5-react-native-paper", "subreddit_subscribers": 3241, "created_utc": 1580872227.0, "num_crossposts": 0, "num_comments": 0, "is_video": false}}], "after": "t3_ez2ngi", "before": null}}