{"kind": "Listing", "data": {"modhash": "", "dist": 11, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "typescript", "selftext": "The monthly thread for people to post openings at their companies.\n\n* Please state the job location and include the keywords REMOTE, INTERNS and/or VISA when the corresponding sort of candidate is welcome. When remote work is not an option, include ONSITE.\n\n* Please only post if you personally are part of the hiring company\u2014no recruiting firms or job boards **Please report recruiters or job boards**. \n\n* Only one post per company. \n\n* If it isn't a household name, explain what your company does. Sell it.\n\n* Please add the company email that applications should be sent to, or the companies application web form/job posting (needless to say this should be on the company website, not a third party site).\n\n\nCommenters: please don't reply to job posts to complain about something. It's off topic here.\n\nReaders: please only email if you are personally interested in the job. \n\nPosting top level comments that aren't job postings, [that's a paddlin](https://i.imgur.com/FxMKfnY.jpg)\n\n[Previous Hiring Threads](https://www.reddit.com/r/typescript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AMonthly%2BHiring%2BThread)", "author_fullname": "t2_6l4z3", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Who's hiring Typescript developers - May", "link_flair_richtext": [], "subreddit_name_prefixed": "r/typescript", "hidden": false, "pwls": null, "link_flair_css_class": "monthly-hiring", "downs": 0, "thumbnail_height": null, "hide_score": false, "name": "t3_gb7km3", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.94, "author_flair_background_color": null, "subreddit_type": "public", "ups": 31, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Monthly Hiring Thread", "can_mod_post": false, "score": 31, "approved_by": null, "author_premium": true, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "self", "content_categories": null, "is_self": true, "mod_note": null, "created": 1588320346.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.typescript", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;The monthly thread for people to post openings at their companies.&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Please state the job location and include the keywords REMOTE, INTERNS and/or VISA when the corresponding sort of candidate is welcome. When remote work is not an option, include ONSITE.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Please only post if you personally are part of the hiring company\u2014no recruiting firms or job boards &lt;strong&gt;Please report recruiters or job boards&lt;/strong&gt;. &lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Only one post per company. &lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If it isn&amp;#39;t a household name, explain what your company does. Sell it.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Please add the company email that applications should be sent to, or the companies application web form/job posting (needless to say this should be on the company website, not a third party site).&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Commenters: please don&amp;#39;t reply to job posts to complain about something. It&amp;#39;s off topic here.&lt;/p&gt;\n\n&lt;p&gt;Readers: please only email if you are personally interested in the job. &lt;/p&gt;\n\n&lt;p&gt;Posting top level comments that aren&amp;#39;t job postings, &lt;a href=\"https://i.imgur.com/FxMKfnY.jpg\"&gt;that&amp;#39;s a paddlin&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://www.reddit.com/r/typescript/search?sort=new&amp;amp;restrict_sr=on&amp;amp;q=flair%3AMonthly%2BHiring%2BThread\"&gt;Previous Hiring Threads&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/VyGnlbKCiZgJWJ1wbp_MHOxxVM8sKYuGRykp5LnDnGo.jpg?auto=webp&amp;s=e7ed7da8371b4e16c167355386ca2a5744ead415", "width": 500, "height": 361}, "resolutions": [{"url": "https://external-preview.redd.it/VyGnlbKCiZgJWJ1wbp_MHOxxVM8sKYuGRykp5LnDnGo.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=66a18e0a3c52817ab852fa4b7c250a55c579d165", "width": 108, "height": 77}, {"url": "https://external-preview.redd.it/VyGnlbKCiZgJWJ1wbp_MHOxxVM8sKYuGRykp5LnDnGo.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=2025ba1460e8c8c9834f11cb40ba4e3832a2d3e9", "width": 216, "height": 155}, {"url": "https://external-preview.redd.it/VyGnlbKCiZgJWJ1wbp_MHOxxVM8sKYuGRykp5LnDnGo.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=3329109c390c2bd989b508c72a7ebf0d2bad3697", "width": 320, "height": 231}], "variants": {}, "id": "L_ccfLuUd62HPSmub7C2gCgZ5motXBmWQ__1MAuL6is"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": "moderator", "subreddit_id": "t5_2v6gg", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gb7km3", "is_robot_indexable": true, "report_reasons": null, "author": "AutoModerator", "discussion_type": null, "num_comments": 1, "send_replies": false, "whitelist_status": null, "contest_mode": true, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/typescript/comments/gb7km3/whos_hiring_typescript_developers_may/", "parent_whitelist_status": null, "stickied": true, "url": "https://www.reddit.com/r/typescript/comments/gb7km3/whos_hiring_typescript_developers_may/", "subreddit_subscribers": 38751, "created_utc": 1588291546.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "typescript", "selftext": "Changelog: [https://gigobyte.github.io/purify/changelog/0.15](https://gigobyte.github.io/purify/changelog/0.15)\n\n**If you are not familiar with functional programming practices please take a look at the documentation, otherwise read below.**\n\nI've finalized the API for async error handling, I feel like this might be best DX for this kind of thing (working with Either and Maybe inside Promises). I'd very much appreciate any feedback on how easy it is to use on the back-end, especially in complicated async flows.\n\nI've already compared purify to fp-ts a [couple](https://www.reddit.com/r/functionalprogramming/comments/ebg4pc/purify_014_released_a_functional_programming/fb5uv16/) of [times](https://www.reddit.com/r/typescript/comments/8y20no/pure_010_released_a_functional_programming/e29e4yl/).", "author_fullname": "t2_gluz1", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Purify 0.15 released! - A Functional programming library for TypeScript", "link_flair_richtext": [], "subreddit_name_prefixed": "r/typescript", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "hide_score": false, "name": "t3_gb0qhw", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.91, "author_flair_background_color": null, "subreddit_type": "public", "ups": 28, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 28, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1588298408.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.typescript", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Changelog: &lt;a href=\"https://gigobyte.github.io/purify/changelog/0.15\"&gt;https://gigobyte.github.io/purify/changelog/0.15&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;If you are not familiar with functional programming practices please take a look at the documentation, otherwise read below.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;ve finalized the API for async error handling, I feel like this might be best DX for this kind of thing (working with Either and Maybe inside Promises). I&amp;#39;d very much appreciate any feedback on how easy it is to use on the back-end, especially in complicated async flows.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;ve already compared purify to fp-ts a &lt;a href=\"https://www.reddit.com/r/functionalprogramming/comments/ebg4pc/purify_014_released_a_functional_programming/fb5uv16/\"&gt;couple&lt;/a&gt; of &lt;a href=\"https://www.reddit.com/r/typescript/comments/8y20no/pure_010_released_a_functional_programming/e29e4yl/\"&gt;times&lt;/a&gt;.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2v6gg", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gb0qhw", "is_robot_indexable": true, "report_reasons": null, "author": "gigobyte", "discussion_type": null, "num_comments": 5, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/typescript/comments/gb0qhw/purify_015_released_a_functional_programming/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/typescript/comments/gb0qhw/purify_015_released_a_functional_programming/", "subreddit_subscribers": 38751, "created_utc": 1588269608.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "typescript", "selftext": "Dear Friends of TypeScript,\n\nEven though I have quite some experience with other languages I'm fairly new to TS and don't get all the parts just yet. I just wrote a function that checks if the value of an entry in a map is an array with more than one element and would like to get some feedback, especially since when testing, one particular line of code is marked as 'uncovered'. My question is if there's any other way to write that function to make sure that there are no uncovered lines?\n\nHere is the function:\n\n    /**\n     *\n     * @param wordMap - map with sorted word as index and array of words as value\n     */\n    function filterAnagrams(wordMap: Map&lt;string, string[]&gt;): string[] {\n      let anagrams: string[] = [];\n      for (let key of wordMap.keys()) {\n        let words: string[] = wordMap.get(key) || [];\n        if (words.length &gt; 1) {\n          anagrams.push(...words);\n        }\n      }\n      return anagrams;\n    }\n\nHere is the test:\n\n    describe(\"filterAnagrams\", function () {\n      it(\"should return the values from the map where elements &gt; 1\", function () {\n        let tempMap = new Map();\n        tempMap.set(\"foo\", [\"foo1\", \"foo2\"]);\n        tempMap.set(\"bar\", [\"bar1\"]);\n        let filteredValues: string[] = filterAnagrams(tempMap);\n        expect(filteredValues).toEqual([\"foo1\", \"foo2\"]);\n      });\n    \n      it(\"should return empty array since map is empty\", function () {\n        let tempMap = new Map();\n        let filteredValues: string[] = filterAnagrams(tempMap);\n        expect(filteredValues).toEqual([]);\n      });\n    });\n\nThe empty array at the end of line 3 in the \\`filterAnagrams\\` function  is marked as uncovered by jest:\n\n    let words: string[] = wordMap.get(key) || [];\n\nIf I remove the || \\[\\] part I receive the error\n\n    Type 'string[] | undefined' is not assignable to type 'string[]'.\n    Type 'undefined' is not assignable to type 'string[]'.ts(2322)", "author_fullname": "t2_14j5x0", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Uncovered lines in test when using `foo || []` - guidance from experienced devs needed", "link_flair_richtext": [], "subreddit_name_prefixed": "r/typescript", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "hide_score": false, "name": "t3_gbd0fm", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.75, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1588343165.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.typescript", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Dear Friends of TypeScript,&lt;/p&gt;\n\n&lt;p&gt;Even though I have quite some experience with other languages I&amp;#39;m fairly new to TS and don&amp;#39;t get all the parts just yet. I just wrote a function that checks if the value of an entry in a map is an array with more than one element and would like to get some feedback, especially since when testing, one particular line of code is marked as &amp;#39;uncovered&amp;#39;. My question is if there&amp;#39;s any other way to write that function to make sure that there are no uncovered lines?&lt;/p&gt;\n\n&lt;p&gt;Here is the function:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/**\n *\n * @param wordMap - map with sorted word as index and array of words as value\n */\nfunction filterAnagrams(wordMap: Map&amp;lt;string, string[]&amp;gt;): string[] {\n  let anagrams: string[] = [];\n  for (let key of wordMap.keys()) {\n    let words: string[] = wordMap.get(key) || [];\n    if (words.length &amp;gt; 1) {\n      anagrams.push(...words);\n    }\n  }\n  return anagrams;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here is the test:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;describe(&amp;quot;filterAnagrams&amp;quot;, function () {\n  it(&amp;quot;should return the values from the map where elements &amp;gt; 1&amp;quot;, function () {\n    let tempMap = new Map();\n    tempMap.set(&amp;quot;foo&amp;quot;, [&amp;quot;foo1&amp;quot;, &amp;quot;foo2&amp;quot;]);\n    tempMap.set(&amp;quot;bar&amp;quot;, [&amp;quot;bar1&amp;quot;]);\n    let filteredValues: string[] = filterAnagrams(tempMap);\n    expect(filteredValues).toEqual([&amp;quot;foo1&amp;quot;, &amp;quot;foo2&amp;quot;]);\n  });\n\n  it(&amp;quot;should return empty array since map is empty&amp;quot;, function () {\n    let tempMap = new Map();\n    let filteredValues: string[] = filterAnagrams(tempMap);\n    expect(filteredValues).toEqual([]);\n  });\n});\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The empty array at the end of line 3 in the `filterAnagrams` function  is marked as uncovered by jest:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;let words: string[] = wordMap.get(key) || [];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If I remove the || [] part I receive the error&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Type &amp;#39;string[] | undefined&amp;#39; is not assignable to type &amp;#39;string[]&amp;#39;.\nType &amp;#39;undefined&amp;#39; is not assignable to type &amp;#39;string[]&amp;#39;.ts(2322)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2v6gg", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gbd0fm", "is_robot_indexable": true, "report_reasons": null, "author": "wan888", "discussion_type": null, "num_comments": 4, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/typescript/comments/gbd0fm/uncovered_lines_in_test_when_using_foo_guidance/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/typescript/comments/gbd0fm/uncovered_lines_in_test_when_using_foo_guidance/", "subreddit_subscribers": 38751, "created_utc": 1588314365.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "typescript", "selftext": "", "author_fullname": "t2_qtig0", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Using fetch with Typescript and the Todoist API", "link_flair_richtext": [], "subreddit_name_prefixed": "r/typescript", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "thumbnail_height": 93, "hide_score": false, "name": "t3_gb66fp", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.82, "author_flair_background_color": null, "subreddit_type": "public", "ups": 7, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 7, "approved_by": null, "author_premium": false, "thumbnail": "https://b.thumbs.redditmedia.com/5XhF5VOQy_w7_0PMjet3S0xmMS0xxkNyST974VxD70o.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "link", "content_categories": null, "is_self": false, "mod_note": null, "created": 1588315661.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "medium.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/Hcb_iX90LqWWk39Vt1vMQbE41RpqKwibKAVXu9wuUtA.jpg?auto=webp&amp;s=7557eaef021773c02e4de6610e1f002440f4c7a0", "width": 1200, "height": 800}, "resolutions": [{"url": "https://external-preview.redd.it/Hcb_iX90LqWWk39Vt1vMQbE41RpqKwibKAVXu9wuUtA.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=b445c35b0802a9727738142a39d3e7e2267dacbe", "width": 108, "height": 72}, {"url": "https://external-preview.redd.it/Hcb_iX90LqWWk39Vt1vMQbE41RpqKwibKAVXu9wuUtA.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=300b7802a8ce09a8ac749e82e3d56808e755127c", "width": 216, "height": 144}, {"url": "https://external-preview.redd.it/Hcb_iX90LqWWk39Vt1vMQbE41RpqKwibKAVXu9wuUtA.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=5c2eea8c513848cf5a9ca4049043e85f14456385", "width": 320, "height": 213}, {"url": "https://external-preview.redd.it/Hcb_iX90LqWWk39Vt1vMQbE41RpqKwibKAVXu9wuUtA.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=181ece2ebb64a18196288f09a1f6aa77cbc10164", "width": 640, "height": 426}, {"url": "https://external-preview.redd.it/Hcb_iX90LqWWk39Vt1vMQbE41RpqKwibKAVXu9wuUtA.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=aa7ed7115e25132fc3ef962b3228a99aa6c5f6d2", "width": 960, "height": 640}, {"url": "https://external-preview.redd.it/Hcb_iX90LqWWk39Vt1vMQbE41RpqKwibKAVXu9wuUtA.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=471f1e2bb955eed14fee150b8b14b45dbdf9b308", "width": 1080, "height": 720}], "variants": {}, "id": "UER4e3UbSP-4EaypDldeVTUL_w9SHqDXcCd3DGFx0KQ"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2v6gg", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gb66fp", "is_robot_indexable": true, "report_reasons": null, "author": "Fewthp", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/typescript/comments/gb66fp/using_fetch_with_typescript_and_the_todoist_api/", "parent_whitelist_status": null, "stickied": false, "url": "https://medium.com//using-fetch-with-typescript-and-the-todoist-api-5203c5177ed5?source=friends_link&amp;sk=a16444467bf3dcfca20b102972fe8b43", "subreddit_subscribers": 38751, "created_utc": 1588286861.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "typescript", "selftext": "... I don't think this is possible in typescript.  Maybe I'm wrong.\n\nI have an API I'm trying to ship that I need a 'lens' to listen to a subscribe map and only update when specific fields have changed.\n\nI want it to return a synthetic type contrained on the input.\n\nthe input API is simple. \n\nI can use fields: ReadonlyArray&lt;keyof Foo&gt;\n\n... the problem I'm having is how to constrain the output to a map which only contains those input values.  \n\nSo if the map has keys name, address, city, state, zip, and the user specifies just city, state, and zip, I want a map with only city, state and zip.\n\nI want name and address to be removed so that the caller doesn't attempt to read from name and address which could be stale.", "author_fullname": "t2_pc7lu", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Typescript generics 'lens' to constrain a type to selected fields?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/typescript", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "hide_score": false, "name": "t3_gb81fz", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1588321978.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.typescript", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;... I don&amp;#39;t think this is possible in typescript.  Maybe I&amp;#39;m wrong.&lt;/p&gt;\n\n&lt;p&gt;I have an API I&amp;#39;m trying to ship that I need a &amp;#39;lens&amp;#39; to listen to a subscribe map and only update when specific fields have changed.&lt;/p&gt;\n\n&lt;p&gt;I want it to return a synthetic type contrained on the input.&lt;/p&gt;\n\n&lt;p&gt;the input API is simple. &lt;/p&gt;\n\n&lt;p&gt;I can use fields: ReadonlyArray&amp;lt;keyof Foo&amp;gt;&lt;/p&gt;\n\n&lt;p&gt;... the problem I&amp;#39;m having is how to constrain the output to a map which only contains those input values.  &lt;/p&gt;\n\n&lt;p&gt;So if the map has keys name, address, city, state, zip, and the user specifies just city, state, and zip, I want a map with only city, state and zip.&lt;/p&gt;\n\n&lt;p&gt;I want name and address to be removed so that the caller doesn&amp;#39;t attempt to read from name and address which could be stale.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2v6gg", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gb81fz", "is_robot_indexable": true, "report_reasons": null, "author": "brainhack3r", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/typescript/comments/gb81fz/typescript_generics_lens_to_constrain_a_type_to/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/typescript/comments/gb81fz/typescript_generics_lens_to_constrain_a_type_to/", "subreddit_subscribers": 38751, "created_utc": 1588293178.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "typescript", "selftext": "I'm working on something in react and can't use classes as 'this' keeps being thrown away.  I want to avoid constantly having to avoid foo.bind(myInstance) too.\n\nSo instead I'm returning an interface with callbacks in it ... they're just functions.\n\nso I'll have:\n\n    interface MyInterface {\n        myCallback1: () =&gt; void;\n        myCallback2: () =&gt; void;\n\n        ... etc\n  }\n\n\nand the way I'm returning this now is:\n\n    function myCallback1() {\n        // ... impl\n    } \n\n    function myCallback2() {\n        // ... impl\n    } \n\n    return {\n        myCallback1, myCallback2, etc...\n    } \n\n... but this yields a ton of boilerplate.  Is there a cleaner way to return / organize everything better?  I was thinking namespaces but you can't return one as an object.  Maybe a static class? Not sure you can return one though... will have to play with that.\n\n... EDIT.  Returning a static class seems to work but curious if that's the best strategy.\n\n... EDIT2. It actually won't work because this is discarded and there's the need to call other functions. Without 'this' they're all in the same namespace.\n\n.... EDIT3. It works if you give it a name like Foo then return Foo and only access functions by Foo and not 'this'", "author_fullname": "t2_pc7lu", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Easiest way to return an interface/map with a collection of functions ?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/typescript", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "hide_score": false, "name": "t3_gaywkz", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.6, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": 1588264599.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1588292768.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.typescript", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m working on something in react and can&amp;#39;t use classes as &amp;#39;this&amp;#39; keeps being thrown away.  I want to avoid constantly having to avoid foo.bind(myInstance) too.&lt;/p&gt;\n\n&lt;p&gt;So instead I&amp;#39;m returning an interface with callbacks in it ... they&amp;#39;re just functions.&lt;/p&gt;\n\n&lt;p&gt;so I&amp;#39;ll have:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;interface MyInterface {\n    myCallback1: () =&amp;gt; void;\n    myCallback2: () =&amp;gt; void;\n\n    ... etc\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;}&lt;/p&gt;\n\n&lt;p&gt;and the way I&amp;#39;m returning this now is:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;function myCallback1() {\n    // ... impl\n} \n\nfunction myCallback2() {\n    // ... impl\n} \n\nreturn {\n    myCallback1, myCallback2, etc...\n} \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;... but this yields a ton of boilerplate.  Is there a cleaner way to return / organize everything better?  I was thinking namespaces but you can&amp;#39;t return one as an object.  Maybe a static class? Not sure you can return one though... will have to play with that.&lt;/p&gt;\n\n&lt;p&gt;... EDIT.  Returning a static class seems to work but curious if that&amp;#39;s the best strategy.&lt;/p&gt;\n\n&lt;p&gt;... EDIT2. It actually won&amp;#39;t work because this is discarded and there&amp;#39;s the need to call other functions. Without &amp;#39;this&amp;#39; they&amp;#39;re all in the same namespace.&lt;/p&gt;\n\n&lt;p&gt;.... EDIT3. It works if you give it a name like Foo then return Foo and only access functions by Foo and not &amp;#39;this&amp;#39;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2v6gg", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gaywkz", "is_robot_indexable": true, "report_reasons": null, "author": "brainhack3r", "discussion_type": null, "num_comments": 15, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/typescript/comments/gaywkz/easiest_way_to_return_an_interfacemap_with_a/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/typescript/comments/gaywkz/easiest_way_to_return_an_interfacemap_with_a/", "subreddit_subscribers": 38751, "created_utc": 1588263968.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "typescript", "selftext": "I want to wrap `plainToClass` from `class-transformer` into an RxJS operator function so that I can use it in `pipe` to map a plain object to a class.\n\nThe original signature of `plainToClass` is:\n\n    function plainToClass&lt;T, V&gt;(cls: ClassType&lt;T&gt;, plain: V[], options?: ClassTransformOptions): T[];\n    function plainToClass&lt;T, V&gt;(cls: ClassType&lt;T&gt;, plain: V, options?: ClassTransformOptions): T;\n\nMy function would be:\n\n    const toClass = cls =&gt; map(plain =&gt; plainToClass(cls, plain));\n\nSimply, `plainToClass` takes a constructor and a literal object and uses that object to create an instance of your class. My function just wraps this in an RxJS `map` operator.\n\nHow should I write the type annotations for this, so that when `v` is a single object, it's return type will be a single instance, and when `v` is an array, the return type will be an array of instances?\n\nE.g.:\n\n    const toClass = &lt;T, V&gt;(cls: new() =&gt; T) =&gt; map&lt;V, T[] when V is Array else T&gt;((plain: V) =&gt; plainToClass(cls, plain));\n\n&amp;#x200B;", "author_fullname": "t2_zncee", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "class-transformer as RxJS operator", "link_flair_richtext": [], "subreddit_name_prefixed": "r/typescript", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "hide_score": false, "name": "t3_gaxnp9", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.76, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1588288921.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.typescript", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I want to wrap &lt;code&gt;plainToClass&lt;/code&gt; from &lt;code&gt;class-transformer&lt;/code&gt; into an RxJS operator function so that I can use it in &lt;code&gt;pipe&lt;/code&gt; to map a plain object to a class.&lt;/p&gt;\n\n&lt;p&gt;The original signature of &lt;code&gt;plainToClass&lt;/code&gt; is:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;function plainToClass&amp;lt;T, V&amp;gt;(cls: ClassType&amp;lt;T&amp;gt;, plain: V[], options?: ClassTransformOptions): T[];\nfunction plainToClass&amp;lt;T, V&amp;gt;(cls: ClassType&amp;lt;T&amp;gt;, plain: V, options?: ClassTransformOptions): T;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;My function would be:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const toClass = cls =&amp;gt; map(plain =&amp;gt; plainToClass(cls, plain));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Simply, &lt;code&gt;plainToClass&lt;/code&gt; takes a constructor and a literal object and uses that object to create an instance of your class. My function just wraps this in an RxJS &lt;code&gt;map&lt;/code&gt; operator.&lt;/p&gt;\n\n&lt;p&gt;How should I write the type annotations for this, so that when &lt;code&gt;v&lt;/code&gt; is a single object, it&amp;#39;s return type will be a single instance, and when &lt;code&gt;v&lt;/code&gt; is an array, the return type will be an array of instances?&lt;/p&gt;\n\n&lt;p&gt;E.g.:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const toClass = &amp;lt;T, V&amp;gt;(cls: new() =&amp;gt; T) =&amp;gt; map&amp;lt;V, T[] when V is Array else T&amp;gt;((plain: V) =&amp;gt; plainToClass(cls, plain));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2v6gg", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gaxnp9", "is_robot_indexable": true, "report_reasons": null, "author": "xroalx", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/typescript/comments/gaxnp9/classtransformer_as_rxjs_operator/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/typescript/comments/gaxnp9/classtransformer_as_rxjs_operator/", "subreddit_subscribers": 38751, "created_utc": 1588260121.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "typescript", "selftext": "", "author_fullname": "t2_34jiw", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Announcing TypeScript 3.9 RC", "link_flair_richtext": [], "subreddit_name_prefixed": "r/typescript", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "thumbnail_height": 87, "hide_score": false, "name": "t3_gaecct", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.95, "author_flair_background_color": null, "subreddit_type": "public", "ups": 87, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 87, "approved_by": null, "author_premium": false, "thumbnail": "https://b.thumbs.redditmedia.com/JV4bj9q8opxCvPR6KEUKf3jPEt1qxNZJ-O06DdX2Vnc.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "link", "content_categories": null, "is_self": false, "mod_note": null, "created": 1588212631.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "devblogs.microsoft.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/RfnVYnVd1OdKDWgZjnJe40-JZpsSLqamQ7SN0iBmLGA.jpg?auto=webp&amp;s=14e2ac4563a760db74d10febfe85290fec246ef5", "width": 562, "height": 350}, "resolutions": [{"url": "https://external-preview.redd.it/RfnVYnVd1OdKDWgZjnJe40-JZpsSLqamQ7SN0iBmLGA.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=aa2799b11813bc3150ec85fdc02198d51cc7de02", "width": 108, "height": 67}, {"url": "https://external-preview.redd.it/RfnVYnVd1OdKDWgZjnJe40-JZpsSLqamQ7SN0iBmLGA.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=51391b8547d45c0aa3521161a9751727540c159d", "width": 216, "height": 134}, {"url": "https://external-preview.redd.it/RfnVYnVd1OdKDWgZjnJe40-JZpsSLqamQ7SN0iBmLGA.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=03bbf25230c304c077428f6ef7a72413c8f7b203", "width": 320, "height": 199}], "variants": {}, "id": "VuFaSjtlPcLuMYjdwW1UjzANI4RMUDx4F8fNjZsRS3c"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2v6gg", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gaecct", "is_robot_indexable": true, "report_reasons": null, "author": "catapop", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/typescript/comments/gaecct/announcing_typescript_39_rc/", "parent_whitelist_status": null, "stickied": false, "url": "https://devblogs.microsoft.com/typescript/announcing-typescript-3-9-rc/", "subreddit_subscribers": 38751, "created_utc": 1588183831.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "typescript", "selftext": "", "author_fullname": "t2_2bk8e9zt", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "A collection of challenging TypeScript exercises", "link_flair_richtext": [], "subreddit_name_prefixed": "r/typescript", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "thumbnail_height": 140, "hide_score": false, "name": "t3_gabb46", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.89, "author_flair_background_color": null, "subreddit_type": "public", "ups": 57, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 57, "approved_by": null, "author_premium": false, "thumbnail": "https://b.thumbs.redditmedia.com/ECr8j3pGtikLde_E7klqKIzSJUU4i53xWPh-axqigLs.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "link", "content_categories": null, "is_self": false, "mod_note": null, "created": 1588202034.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/2tjuXKczPNP6OX8oezrTZTVPidURr-2iuaujqdPUnRQ.jpg?auto=webp&amp;s=a645d8ac1c7d753d7a09f46905d8872945810a5d", "width": 400, "height": 400}, "resolutions": [{"url": "https://external-preview.redd.it/2tjuXKczPNP6OX8oezrTZTVPidURr-2iuaujqdPUnRQ.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=108c8bf0f5a6b17772611bdeb1c802bf765b94c4", "width": 108, "height": 108}, {"url": "https://external-preview.redd.it/2tjuXKczPNP6OX8oezrTZTVPidURr-2iuaujqdPUnRQ.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=345f04481ebb526bb395f63c7f0d5e521be004b0", "width": 216, "height": 216}, {"url": "https://external-preview.redd.it/2tjuXKczPNP6OX8oezrTZTVPidURr-2iuaujqdPUnRQ.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=6d8ce705274240ff93ccc1e385cfbeb04a6dd5d2", "width": 320, "height": 320}], "variants": {}, "id": "7FT250VNpTRnNDNuCRrKqhk_NaWf9yvC7N2OsOQBxOE"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2v6gg", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gabb46", "is_robot_indexable": true, "report_reasons": null, "author": "mdevils", "discussion_type": null, "num_comments": 14, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/typescript/comments/gabb46/a_collection_of_challenging_typescript_exercises/", "parent_whitelist_status": null, "stickied": false, "url": "https://github.com/mdevils/typescript-exercises", "subreddit_subscribers": 38751, "created_utc": 1588173234.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "typescript", "selftext": "**Issue**\n\nI am mocking a function (only one) which is imported from another class which is being called inside the main class. I am able to mock the function and return the values which I provide. But I am not able to restore the mocked function back to normal for the subsequent tests.\n\nAny help would be appreciated!\n\nFramework Using: jest + ts-jest\n\n**Code**\n\n\\~main.ts\n\n\\`\\`\\`\n\nimport {SubClass} from './subclass.ts' \n\nexport class MainClass { \n\nlet sub: SubClass = new SubClass() \n\npublic async Car(){ \n\nlet start = await sub.key(); \n\nreturn start } }\n\n\\`\\`\\`\n\n\\~sub.ts\n\n\\`\\`\\`\n\nexport class SubClass{ \n\npublic async key(){ return \"you can start the car\" } }\n\n\\`\\`\\`\n\n\\`\\`\\`  \nimport {SubClass} from './subclass.ts' \n\nimport {MainClass} from './mainclass.ts' \n\nimport {mocked} from 'ts-jest/utils'  \n\njest.mock(./subclass.ts) \n\nlet main = new MainClass() \n\nlet sub = new SubClass() \n\nlet mockedFn = mocked(sub,true)  \n\nmockedFn.key = jest.fn().mockImplementation(() =&gt; console.log('mocking succesfull'))  \n\nafterEach(()=&gt;{ mockedFn.key.mockRestore() // tried mockClear(), mockReset() })\n\n  it('test for main func mocked result',async ()=&gt;{ \n\nconst result = await main.car()  \n\nexpect(result).toEqual(\"mocking succesfull\") } \n\nit('test for main func result',async ()=&gt;{ \n\nconst result = await main.car()  \n\nexpect(result).toEqual(\"you can start the car\") // getting result as undefined \n\n}\n\n\\`\\`\\`", "author_fullname": "t2_13dzlt", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Restore mock of imported class function in ts-jest while testing", "link_flair_richtext": [], "subreddit_name_prefixed": "r/typescript", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "hide_score": false, "name": "t3_gav2w0", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.67, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1588279884.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.typescript", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;strong&gt;Issue&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;I am mocking a function (only one) which is imported from another class which is being called inside the main class. I am able to mock the function and return the values which I provide. But I am not able to restore the mocked function back to normal for the subsequent tests.&lt;/p&gt;\n\n&lt;p&gt;Any help would be appreciated!&lt;/p&gt;\n\n&lt;p&gt;Framework Using: jest + ts-jest&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;~main.ts&lt;/p&gt;\n\n&lt;p&gt;```&lt;/p&gt;\n\n&lt;p&gt;import {SubClass} from &amp;#39;./subclass.ts&amp;#39; &lt;/p&gt;\n\n&lt;p&gt;export class MainClass { &lt;/p&gt;\n\n&lt;p&gt;let sub: SubClass = new SubClass() &lt;/p&gt;\n\n&lt;p&gt;public async Car(){ &lt;/p&gt;\n\n&lt;p&gt;let start = await sub.key(); &lt;/p&gt;\n\n&lt;p&gt;return start } }&lt;/p&gt;\n\n&lt;p&gt;```&lt;/p&gt;\n\n&lt;p&gt;~sub.ts&lt;/p&gt;\n\n&lt;p&gt;```&lt;/p&gt;\n\n&lt;p&gt;export class SubClass{ &lt;/p&gt;\n\n&lt;p&gt;public async key(){ return &amp;quot;you can start the car&amp;quot; } }&lt;/p&gt;\n\n&lt;p&gt;```&lt;/p&gt;\n\n&lt;p&gt;```&lt;br/&gt;\nimport {SubClass} from &amp;#39;./subclass.ts&amp;#39; &lt;/p&gt;\n\n&lt;p&gt;import {MainClass} from &amp;#39;./mainclass.ts&amp;#39; &lt;/p&gt;\n\n&lt;p&gt;import {mocked} from &amp;#39;ts-jest/utils&amp;#39;  &lt;/p&gt;\n\n&lt;p&gt;jest.mock(./subclass.ts) &lt;/p&gt;\n\n&lt;p&gt;let main = new MainClass() &lt;/p&gt;\n\n&lt;p&gt;let sub = new SubClass() &lt;/p&gt;\n\n&lt;p&gt;let mockedFn = mocked(sub,true)  &lt;/p&gt;\n\n&lt;p&gt;mockedFn.key = jest.fn().mockImplementation(() =&amp;gt; console.log(&amp;#39;mocking succesfull&amp;#39;))  &lt;/p&gt;\n\n&lt;p&gt;afterEach(()=&amp;gt;{ mockedFn.key.mockRestore() // tried mockClear(), mockReset() })&lt;/p&gt;\n\n&lt;p&gt;it(&amp;#39;test for main func mocked result&amp;#39;,async ()=&amp;gt;{ &lt;/p&gt;\n\n&lt;p&gt;const result = await main.car()  &lt;/p&gt;\n\n&lt;p&gt;expect(result).toEqual(&amp;quot;mocking succesfull&amp;quot;) } &lt;/p&gt;\n\n&lt;p&gt;it(&amp;#39;test for main func result&amp;#39;,async ()=&amp;gt;{ &lt;/p&gt;\n\n&lt;p&gt;const result = await main.car()  &lt;/p&gt;\n\n&lt;p&gt;expect(result).toEqual(&amp;quot;you can start the car&amp;quot;) // getting result as undefined &lt;/p&gt;\n\n&lt;p&gt;}&lt;/p&gt;\n\n&lt;p&gt;```&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2v6gg", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gav2w0", "is_robot_indexable": true, "report_reasons": null, "author": "danishjoseph", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/typescript/comments/gav2w0/restore_mock_of_imported_class_function_in_tsjest/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/typescript/comments/gav2w0/restore_mock_of_imported_class_function_in_tsjest/", "subreddit_subscribers": 38751, "created_utc": 1588251084.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "typescript", "selftext": "    /**\n     * @type {{[x:string] : (type1) =&gt; type2}}\n    */\n    const obj;\n\nThis does not give me intellisense for the properties of the `obj`.", "author_fullname": "t2_1ihbqq55", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How can I have intellisense for a dictionary object but also type definition.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/typescript", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "hide_score": false, "name": "t3_gakqj5", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1588233088.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.typescript", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;pre&gt;&lt;code&gt;/**\n * @type {{[x:string] : (type1) =&amp;gt; type2}}\n*/\nconst obj;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This does not give me intellisense for the properties of the &lt;code&gt;obj&lt;/code&gt;.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2v6gg", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gakqj5", "is_robot_indexable": true, "report_reasons": null, "author": "liaguris", "discussion_type": null, "num_comments": 27, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/typescript/comments/gakqj5/how_can_i_have_intellisense_for_a_dictionary/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/typescript/comments/gakqj5/how_can_i_have_intellisense_for_a_dictionary/", "subreddit_subscribers": 38751, "created_utc": 1588204288.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_gakqj5", "before": null}}