{"kind": "Listing", "data": {"modhash": "", "dist": 12, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "Mystified about strings? Borrow checker have you in a headlock? Seek help here! There are no stupid questions, only docs that haven't been written yet.\n\nIf you have a [StackOverflow](http://stackoverflow.com/) account, consider asking it there instead! StackOverflow shows up much higher in search results, so having your question there also helps future Rust users (be sure to give it [the \"Rust\" tag](http://stackoverflow.com/questions/tagged/rust) for maximum visibility). Note that this site is very interested in question quality. I've been asked to read a RFC I authored once. If you want your code reviewed or review other's code, there's a [codereview stackexchange](https://codereview.stackexchange.com/questions/tagged/rust), too. If you need to test your code, maybe [the Rust playground](https://play.rust-lang.org) is for you.\n\nHere are some other venues where help may be found:\n\n[/r/learnrust](https://www.reddit.com/r/learnrust) is a subreddit to share your questions and epiphanies learning Rust programming.\n\nThe official Rust user forums: [https://users.rust-lang.org/](https://users.rust-lang.org/).\n\nThe official Rust Programming Language Discord: [https://discord.gg/rust-lang](https://discord.gg/rust-lang)\n\nThe unofficial Rust community Discord: [https://bit.ly/rust-community](https://bit.ly/rust-community)\n\nAlso check out [last weeks' thread](https://reddit.com/r/rust/comments/i6yqng/hey_rustaceans_got_an_easy_question_ask_here/) with many good questions and answers. And if you believe your question to be either very complex or worthy of larger dissemination, feel free to create a text post.\n\nAlso if you want to be mentored by experienced Rustaceans, tell us the area of expertise that you seek.", "author_fullname": "t2_1kxp4", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Hey Rustaceans! Got an easy question? Ask here (35/2020)!", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": "easyquestions", "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_ifiec2", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.94, "author_flair_background_color": "", "subreddit_type": "public", "ups": 15, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "\ud83d\ude4b", "can_mod_post": false, "score": 15, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": "contrib", "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1598272392.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.rust", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Mystified about strings? Borrow checker have you in a headlock? Seek help here! There are no stupid questions, only docs that haven&amp;#39;t been written yet.&lt;/p&gt;\n\n&lt;p&gt;If you have a &lt;a href=\"http://stackoverflow.com/\"&gt;StackOverflow&lt;/a&gt; account, consider asking it there instead! StackOverflow shows up much higher in search results, so having your question there also helps future Rust users (be sure to give it &lt;a href=\"http://stackoverflow.com/questions/tagged/rust\"&gt;the &amp;quot;Rust&amp;quot; tag&lt;/a&gt; for maximum visibility). Note that this site is very interested in question quality. I&amp;#39;ve been asked to read a RFC I authored once. If you want your code reviewed or review other&amp;#39;s code, there&amp;#39;s a &lt;a href=\"https://codereview.stackexchange.com/questions/tagged/rust\"&gt;codereview stackexchange&lt;/a&gt;, too. If you need to test your code, maybe &lt;a href=\"https://play.rust-lang.org\"&gt;the Rust playground&lt;/a&gt; is for you.&lt;/p&gt;\n\n&lt;p&gt;Here are some other venues where help may be found:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://www.reddit.com/r/learnrust\"&gt;/r/learnrust&lt;/a&gt; is a subreddit to share your questions and epiphanies learning Rust programming.&lt;/p&gt;\n\n&lt;p&gt;The official Rust user forums: &lt;a href=\"https://users.rust-lang.org/\"&gt;https://users.rust-lang.org/&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;The official Rust Programming Language Discord: &lt;a href=\"https://discord.gg/rust-lang\"&gt;https://discord.gg/rust-lang&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;The unofficial Rust community Discord: &lt;a href=\"https://bit.ly/rust-community\"&gt;https://bit.ly/rust-community&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Also check out &lt;a href=\"https://reddit.com/r/rust/comments/i6yqng/hey_rustaceans_got_an_easy_question_ask_here/\"&gt;last weeks&amp;#39; thread&lt;/a&gt; with many good questions and answers. And if you believe your question to be either very complex or worthy of larger dissemination, feel free to create a text post.&lt;/p&gt;\n\n&lt;p&gt;Also if you want to be mentored by experienced Rustaceans, tell us the area of expertise that you seek.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": "new", "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "e86091d6-dfe6-11ea-a6d0-0eaf4ae01c99", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": "clippy \u00b7 twir \u00b7 rust \u00b7 mutagen \u00b7 flamer \u00b7 overflower \u00b7 bytecount", "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": "moderator", "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "#f7f5ff", "id": "ifiec2", "is_robot_indexable": true, "report_reasons": null, "author": "llogiq", "discussion_type": null, "num_comments": 78, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": "dark", "permalink": "/r/rust/comments/ifiec2/hey_rustaceans_got_an_easy_question_ask_here/", "parent_whitelist_status": "all_ads", "stickied": true, "url": "https://www.reddit.com/r/rust/comments/ifiec2/hey_rustaceans_got_an_easy_question_ask_here/", "subreddit_subscribers": 111727, "created_utc": 1598243592.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "", "author_fullname": "t2_eki22", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "This Week in Rust 353", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_ih8uai", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.97, "author_flair_background_color": "", "subreddit_type": "public", "ups": 90, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 90, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1598509215.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "this-week-in-rust.org", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://this-week-in-rust.org/blog/2020/08/26/this-week-in-rust-353/", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": "twir", "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ih8uai", "is_robot_indexable": true, "report_reasons": null, "author": "seino_chan", "discussion_type": null, "num_comments": 5, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": "dark", "permalink": "/r/rust/comments/ih8uai/this_week_in_rust_353/", "parent_whitelist_status": "all_ads", "stickied": true, "url": "https://this-week-in-rust.org/blog/2020/08/26/this-week-in-rust-353/", "subreddit_subscribers": 111727, "created_utc": 1598480415.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "GlueSQL is the new sql database that I am working on.\n\nIt's still in pretty early stage, but it supports basic SQL queries:  aggregation, join and nested select.\n\nPlease take a look: [https://github.com/gluesql/gluesql](https://github.com/gluesql/gluesql)\n\nKey features\n\n* Fully written in Rust\n* Pure functional execution layer\n* Easily-swappable storage (default storage is [sled](https://github.com/spacejam/sled))\n* WebAssembly support: [https://github.com/gluesql/gluesql-js](https://github.com/gluesql/gluesql-js)\n\nIn case of wasm, please try the Web Dashboard Demo: [https://gluesql.org/playground](https://gluesql.org/playground)\n\n&amp;#x200B;", "author_fullname": "t2_48axari1", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Announcing GlueSQL: SQL database fully written in Rust &amp; WebAssembly support", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_ihdx7o", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.99, "author_flair_background_color": null, "subreddit_type": "public", "ups": 233, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 233, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1598510873.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1598528688.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.rust", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;GlueSQL is the new sql database that I am working on.&lt;/p&gt;\n\n&lt;p&gt;It&amp;#39;s still in pretty early stage, but it supports basic SQL queries:  aggregation, join and nested select.&lt;/p&gt;\n\n&lt;p&gt;Please take a look: &lt;a href=\"https://github.com/gluesql/gluesql\"&gt;https://github.com/gluesql/gluesql&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Key features&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Fully written in Rust&lt;/li&gt;\n&lt;li&gt;Pure functional execution layer&lt;/li&gt;\n&lt;li&gt;Easily-swappable storage (default storage is &lt;a href=\"https://github.com/spacejam/sled\"&gt;sled&lt;/a&gt;)&lt;/li&gt;\n&lt;li&gt;WebAssembly support: &lt;a href=\"https://github.com/gluesql/gluesql-js\"&gt;https://github.com/gluesql/gluesql-js&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;In case of wasm, please try the Web Dashboard Demo: &lt;a href=\"https://gluesql.org/playground\"&gt;https://gluesql.org/playground&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ihdx7o", "is_robot_indexable": true, "report_reasons": null, "author": "taeh00n", "discussion_type": null, "num_comments": 33, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/ihdx7o/announcing_gluesql_sql_database_fully_written_in/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/rust/comments/ihdx7o/announcing_gluesql_sql_database_fully_written_in/", "subreddit_subscribers": 111727, "created_utc": 1598499888.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "", "author_fullname": "t2_mqigm", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "openrazer-rs, Rust bindings for the OpenRazer daemon", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_ihijbw", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.86, "author_flair_background_color": null, "subreddit_type": "public", "ups": 5, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 5, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1598552588.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "crates.io", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://crates.io/crates/openrazer", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ihijbw", "is_robot_indexable": true, "report_reasons": null, "author": "snejugal", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/ihijbw/openrazerrs_rust_bindings_for_the_openrazer_daemon/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://crates.io/crates/openrazer", "subreddit_subscribers": 111727, "created_utc": 1598523788.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "", "author_fullname": "t2_6yffg", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Fixing include_bytes!", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_ih7ecn", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.94, "author_flair_background_color": null, "subreddit_type": "public", "ups": 61, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 61, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1598504565.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "jack.wrenn.fyi", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://jack.wrenn.fyi/blog/include-transmute/", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ih7ecn", "is_robot_indexable": true, "report_reasons": null, "author": "jswrenn", "discussion_type": null, "num_comments": 17, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/ih7ecn/fixing_include_bytes/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://jack.wrenn.fyi/blog/include-transmute/", "subreddit_subscribers": 111727, "created_utc": 1598475765.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "Hello community ,I hope you're doing good . As a beginner on rust , I had the idea of learning the langage by participating into competitive programming  contest ( like binary search ,reverse strings etc ..).\n\nAnd I was wondering ,if it was the proper manner to learn  Rust. Should I keep on the cookbook made by Rust itself to master all the idea behind the langage , or should I learn by project or by training by participating into contest like competitive programming ?\n\n&amp;#x200B;", "author_fullname": "t2_7l9ti89m", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Is rust suitable for competitive programming ?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": true, "name": "t3_ihk7o8", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1598532689.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1598560475.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.rust", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hello community ,I hope you&amp;#39;re doing good . As a beginner on rust , I had the idea of learning the langage by participating into competitive programming  contest ( like binary search ,reverse strings etc ..).&lt;/p&gt;\n\n&lt;p&gt;And I was wondering ,if it was the proper manner to learn  Rust. Should I keep on the cookbook made by Rust itself to master all the idea behind the langage , or should I learn by project or by training by participating into contest like competitive programming ?&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ihk7o8", "is_robot_indexable": true, "report_reasons": null, "author": "rayanaay", "discussion_type": null, "num_comments": 7, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/ihk7o8/is_rust_suitable_for_competitive_programming/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/rust/comments/ihk7o8/is_rust_suitable_for_competitive_programming/", "subreddit_subscribers": 111727, "created_utc": 1598531675.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "When I started C I got scared of pointers. later i found out that how amazing and strong pointers are.\n\nNow I am learning Rust and  in rust references are like on steroids or are like sneaky. Coming from C reading rust references seems quite difficult for me.\n\n    enum List{\n        Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),\n        Nil,\n    }\n    \n    use crate::List::{Cons, Nil};\n    use std::cell::RefCell;\n    use std::rc::Rc;\n    \n    fn main() {\n        let value = Rc::new(RefCell::new(5));\n    \n        let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));\n    \n        let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));\n        let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));\n    \n        *value.borrow_mut() += 10;\n\nThis code is copied from Rust docs. on last line they used a single \\* , I understand that how coercion works but its quite confusing that i think since value is wrapped twice in smart pointers shouldn't it be like \\*\\*.\n\nAnyone can share any links that explains this concepts clearly. (videos would be even great or talks would be amazing)", "author_fullname": "t2_1viy3r54", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Rust Deref coercion confusion.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": true, "name": "t3_ihjnjo", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1598558137.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.rust", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;When I started C I got scared of pointers. later i found out that how amazing and strong pointers are.&lt;/p&gt;\n\n&lt;p&gt;Now I am learning Rust and  in rust references are like on steroids or are like sneaky. Coming from C reading rust references seems quite difficult for me.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;enum List{\n    Cons(Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;, Rc&amp;lt;List&amp;gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&amp;amp;value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;amp;a));\n    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;amp;a));\n\n    *value.borrow_mut() += 10;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This code is copied from Rust docs. on last line they used a single * , I understand that how coercion works but its quite confusing that i think since value is wrapped twice in smart pointers shouldn&amp;#39;t it be like **.&lt;/p&gt;\n\n&lt;p&gt;Anyone can share any links that explains this concepts clearly. (videos would be even great or talks would be amazing)&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ihjnjo", "is_robot_indexable": true, "report_reasons": null, "author": "gireeshvmo", "discussion_type": null, "num_comments": 8, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/ihjnjo/rust_deref_coercion_confusion/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/rust/comments/ihjnjo/rust_deref_coercion_confusion/", "subreddit_subscribers": 111727, "created_utc": 1598529337.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "I am in a bit of dilemma , I learned C++ to implement deep learning algorithms , I am using DL for the purpose of macroeconomic simulations, recently I came across rust and instantly fall in love with the syntax of the language. Now I am in dilemma if i should implement DL algorithms in Rust or C++ and if Rust have any advantage over C++ in future ?? Thanks in advance to the vibrant community", "author_fullname": "t2_4l272piv", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Deep Learning in Rust", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_igz8iv", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.94, "author_flair_background_color": null, "subreddit_type": "public", "ups": 159, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 159, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1598478846.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.rust", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I am in a bit of dilemma , I learned C++ to implement deep learning algorithms , I am using DL for the purpose of macroeconomic simulations, recently I came across rust and instantly fall in love with the syntax of the language. Now I am in dilemma if i should implement DL algorithms in Rust or C++ and if Rust have any advantage over C++ in future ?? Thanks in advance to the vibrant community&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "igz8iv", "is_robot_indexable": true, "report_reasons": null, "author": "Nhasan25", "discussion_type": null, "num_comments": 54, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/igz8iv/deep_learning_in_rust/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/rust/comments/igz8iv/deep_learning_in_rust/", "subreddit_subscribers": 111727, "created_utc": 1598450046.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "* [user guide](https://ocypod.readthedocs.io/en/latest/)\n* [source](https://github.com/davechallis/ocypod)\n* [docker images](https://hub.docker.com/repository/docker/davechallis/ocypod/)\n\nOcypod is an open source job queue server implemented using Rust/Actix/Redis. It's been used production at my workplace for over a year now, having processed ~500m jobs without any issues.\n\nThis release focused entirely on updating the internals. The previous version was built on Actix Web 1.0 and Actix actors were used to provide access to Redis via a sync connection.\n\nThis update now uses Actix Web 2.0 and async/await throughout (including Redis communication), so no more actors/Actix needed.\n\nThe whole async/await migration process was less painful than I'd anticipated, bar a couple of minor stumbling blocks to figure out.", "author_fullname": "t2_bzm8a", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "ANN: Ocypod 0.5.0 (language-agnostic, Redis-backed job queue server, now fully async)", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": true, "name": "t3_ihkjr0", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1598561858.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.rust", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://ocypod.readthedocs.io/en/latest/\"&gt;user guide&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://github.com/davechallis/ocypod\"&gt;source&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://hub.docker.com/repository/docker/davechallis/ocypod/\"&gt;docker images&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Ocypod is an open source job queue server implemented using Rust/Actix/Redis. It&amp;#39;s been used production at my workplace for over a year now, having processed ~500m jobs without any issues.&lt;/p&gt;\n\n&lt;p&gt;This release focused entirely on updating the internals. The previous version was built on Actix Web 1.0 and Actix actors were used to provide access to Redis via a sync connection.&lt;/p&gt;\n\n&lt;p&gt;This update now uses Actix Web 2.0 and async/await throughout (including Redis communication), so no more actors/Actix needed.&lt;/p&gt;\n\n&lt;p&gt;The whole async/await migration process was less painful than I&amp;#39;d anticipated, bar a couple of minor stumbling blocks to figure out.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ihkjr0", "is_robot_indexable": true, "report_reasons": null, "author": "lxnx", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/ihkjr0/ann_ocypod_050_languageagnostic_redisbacked_job/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/rust/comments/ihkjr0/ann_ocypod_050_languageagnostic_redisbacked_job/", "subreddit_subscribers": 111727, "created_utc": 1598533058.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "Yesterday I released version `0.4` of [Polars](https://github.com/ritchie46/polars), a DataFrame library in Rust. I've been working on it for a few months now. I believe it is already pretty feature complete. However, I'd like some feedback and get my head out of the ivory tower. \n\nWhat do you guys think? Which operations should definitely be supported by DataFrame library.", "author_fullname": "t2_zvbil", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Polars DataFrame library; Missing features?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_ihgazu", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.86, "author_flair_background_color": null, "subreddit_type": "public", "ups": 5, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 5, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1598540135.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.rust", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Yesterday I released version &lt;code&gt;0.4&lt;/code&gt; of &lt;a href=\"https://github.com/ritchie46/polars\"&gt;Polars&lt;/a&gt;, a DataFrame library in Rust. I&amp;#39;ve been working on it for a few months now. I believe it is already pretty feature complete. However, I&amp;#39;d like some feedback and get my head out of the ivory tower. &lt;/p&gt;\n\n&lt;p&gt;What do you guys think? Which operations should definitely be supported by DataFrame library.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ihgazu", "is_robot_indexable": true, "report_reasons": null, "author": "ritchie46", "discussion_type": null, "num_comments": 11, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/ihgazu/polars_dataframe_library_missing_features/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/rust/comments/ihgazu/polars_dataframe_library_missing_features/", "subreddit_subscribers": 111727, "created_utc": 1598511335.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "", "author_fullname": "t2_6g1ppt9x", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Spawning Tasks on Multiple Thread Pools in Rust", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_ihep0e", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.9, "author_flair_background_color": null, "subreddit_type": "public", "ups": 8, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 8, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1598532055.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "pkolaczk.github.io", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://pkolaczk.github.io/multiple-threadpools-rust/", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ihep0e", "is_robot_indexable": true, "report_reasons": null, "author": "coderemover", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/ihep0e/spawning_tasks_on_multiple_thread_pools_in_rust/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://pkolaczk.github.io/multiple-threadpools-rust/", "subreddit_subscribers": 111727, "created_utc": 1598503255.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "I'm working on a new database and went through the process of trying to find a good serialization format that meets the performance and technical needs of the project. \n\nOne of the frequent operations with secondary indexes is to grab a value out of a row and insert it into an index table.  This operation needs to be efficient and fast to keep the insert hot path running as quickly as possible.  \n\nThis requirement automatically excludes a majority of serialization formats.  Even high performance/efficient formats like BSON and Message Pack are designed to deserialize the entire buffer before allowing access to any internal values.  This makes these formats not much better than JSON from a performance standpoint.  The crux of the issue with these formats is if you need to read 4 bytes from a buffer that is a kilobyte in size, you will need to deserialize the whole kilobyte object before you can get your 4 byte value.\n\nThis is one of the major advantages of projects like Flatbuffers and CapN Proto, you can read internal values from the buffer without deserializing the whole thing.  So even if you have a large buffer that is several kilobytes large, you will only need to deserialize the data you need and maybe a few other bytes to traverse the buffer.\n\nUnfortunately there's a few tradeoffs with Flatbuffers &amp; CapN Proto.  The first is that new schemas must be compiled into the source language you're using (Rust, C, Java, etc) and then included into your  binary.  This makes these formats a non starter for my use case, I can't ask the end user to recompile the database binary every time there is a schema change.\n\nThe second tradeoff is that the these buffers cannot be mutated.  So once you create a FlatBuffer or CapNProto buffer the data is essentially in stone.  If you want to update or delete a value inside a buffer after it's been created or after opening an existing buffer you simply can't.  The correct process to perform an update would be to recursively copy all values in the existing buffer and either don't include the value in the new buffer to delete it or update the value into the new buffer.  As you can imagine, this would be extremely tedious and there's no abstract way to set this process up.  You'd need an \"update\" or \"delete\" function for every single value in the buffer.\n\nNow Flatbuffers &amp; CapN Proto is off the table.  The \"table\" is now... empty.\n\nWe need a format that:\n\n1. You can traverse efficiently without parsing the whole buffer first.\n2. Allows efficient mutations in place.\n3. Allows the schema of the buffers to change without a compilation step\n\nAs far as I know, this simply hasn't existed until now.  I wrote the [NoProto](https://crates.io/crates/no_proto) crate to solve exactly this problem.\n\nHow does it work?\n\nSchemas are specially formatted JSON objects parsed at runtime.  The parsed schemas are converted into \"factories\" which can be used to serialize and deserialize any number of buffers. \n\n```rs\nlet user_factory = NP_Factory::new(r#\"{\n    \"type\": \"table\",\n    \"columns\": [\n        [\"name\",   {\"type\": \"string\"}],\n        [\"age\",    {\"type\": \"u16\", \"default\": 0}],\n        [\"tags\",   {\"type\": \"list\", \"of\": {\n            \"type\": \"string\"\n        }}]\n    ]\n}\"#).unwrap();\n```\n\nThe schemas are validated to follow a specific format, which means the validation or JSON parsing can fail, thus the call to `.unwrap()`.\n\nLike Protocol Buffers, CapN Proto &amp; Flatbuffers there are ways you can safely mutate the schema without breaking it's ability to parse previous buffers. \n\n```rs\n// safe mutation from previous schema, adding new column at the bottom\nlet user_factory = NP_Factory::new(r#\"{\n    \"type\": \"table\",\n    \"columns\": [\n        [\"name\",   {\"type\": \"string\"}],\n        [\"age\",    {\"type\": \"u16\", \"default\": 0}],\n        [\"tags\",   {\"type\": \"list\", \"of\": {\n            \"type\": \"string\"\n        }}],\n        [\"phone\",    {\"type\": \"string\"}],\n    ]\n}\"#)?;\n\n// UNSAFE mutation from previous schema, deleting columns entirely (changes column order).\nlet user_factory = NP_Factory::new(r#\"{\n    \"type\": \"table\",\n    \"columns\": [\n        [\"name\",   {\"type\": \"string\"}],\n        [\"tags\",   {\"type\": \"list\", \"of\": {\n            \"type\": \"string\"\n        }}]\n    ]\n}\"#)?;\n```\n\nOnce you have a factory, creating and opening buffers is easy and efficient.\n```rs\n// create a new empty buffer\nlet mut user_buffer = user_factory.empty_buffer(None, None);\n\n// assign the name column\nuser_buffer.deep_set(\"name\", String::from(\"Billy Joel\")).unwrap();\n\n// assign nested internal values, sets the first tag element\nuser_buffer.deep_set(\"tags.0\", String::from(\"first tag\")).unwrap();\n\n// close buffer and get internal bytes\n// this is essentially a free operation, just moves the internal bytes out of the buffer\nlet user_bytes: Vec&lt;u8&gt; = user_buffer.close();\n\n// user_bytes can be sent across the network, saved to disk, or whatever else you'd like... \n// then to open it again...\n\n// open the buffer, essentially free operation as it just moves the Vec.  \n// Zero parsing happens here\nlet user_buffer = user_factory.open_buffer(user_bytes);\n\n// efficiently traverse the buffer to get internal value\n// only reads the value and a few other bytes from the buffer.\nlet tag = user_buffer.deep_get::&lt;String&gt;(\"tags.0\").unwrap();\nassert_eq!(tag, Some(Box::new(String::from(\"first tag\"))));\n\n// get nested internal value, the age field\nlet age = user_buffer.deep_get::&lt;u16&gt;(\"age\")?;\n// returns default value from schema\nassert_eq!(age, Some(Box::new(0u16)));\n```\n\nSo we get the dynamic capabilities of something like JSON with the performance of CapNProto &amp; Flatbuffers.  \n\nThe library is also fully documented and supports `no_std`, so it will work with WASM as long as you include an allocator.\n\nI hope you'll find this library useful and any feedback / suggestions are welcome!\n\nhttps://crates.io/crates/no_proto", "author_fullname": "t2_5farcmip", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Motivations for NoProto Library", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_ih4qm6", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.93, "author_flair_background_color": null, "subreddit_type": "public", "ups": 43, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 43, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1598477892.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1598496363.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.rust", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m working on a new database and went through the process of trying to find a good serialization format that meets the performance and technical needs of the project. &lt;/p&gt;\n\n&lt;p&gt;One of the frequent operations with secondary indexes is to grab a value out of a row and insert it into an index table.  This operation needs to be efficient and fast to keep the insert hot path running as quickly as possible.  &lt;/p&gt;\n\n&lt;p&gt;This requirement automatically excludes a majority of serialization formats.  Even high performance/efficient formats like BSON and Message Pack are designed to deserialize the entire buffer before allowing access to any internal values.  This makes these formats not much better than JSON from a performance standpoint.  The crux of the issue with these formats is if you need to read 4 bytes from a buffer that is a kilobyte in size, you will need to deserialize the whole kilobyte object before you can get your 4 byte value.&lt;/p&gt;\n\n&lt;p&gt;This is one of the major advantages of projects like Flatbuffers and CapN Proto, you can read internal values from the buffer without deserializing the whole thing.  So even if you have a large buffer that is several kilobytes large, you will only need to deserialize the data you need and maybe a few other bytes to traverse the buffer.&lt;/p&gt;\n\n&lt;p&gt;Unfortunately there&amp;#39;s a few tradeoffs with Flatbuffers &amp;amp; CapN Proto.  The first is that new schemas must be compiled into the source language you&amp;#39;re using (Rust, C, Java, etc) and then included into your  binary.  This makes these formats a non starter for my use case, I can&amp;#39;t ask the end user to recompile the database binary every time there is a schema change.&lt;/p&gt;\n\n&lt;p&gt;The second tradeoff is that the these buffers cannot be mutated.  So once you create a FlatBuffer or CapNProto buffer the data is essentially in stone.  If you want to update or delete a value inside a buffer after it&amp;#39;s been created or after opening an existing buffer you simply can&amp;#39;t.  The correct process to perform an update would be to recursively copy all values in the existing buffer and either don&amp;#39;t include the value in the new buffer to delete it or update the value into the new buffer.  As you can imagine, this would be extremely tedious and there&amp;#39;s no abstract way to set this process up.  You&amp;#39;d need an &amp;quot;update&amp;quot; or &amp;quot;delete&amp;quot; function for every single value in the buffer.&lt;/p&gt;\n\n&lt;p&gt;Now Flatbuffers &amp;amp; CapN Proto is off the table.  The &amp;quot;table&amp;quot; is now... empty.&lt;/p&gt;\n\n&lt;p&gt;We need a format that:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;You can traverse efficiently without parsing the whole buffer first.&lt;/li&gt;\n&lt;li&gt;Allows efficient mutations in place.&lt;/li&gt;\n&lt;li&gt;Allows the schema of the buffers to change without a compilation step&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;As far as I know, this simply hasn&amp;#39;t existed until now.  I wrote the &lt;a href=\"https://crates.io/crates/no_proto\"&gt;NoProto&lt;/a&gt; crate to solve exactly this problem.&lt;/p&gt;\n\n&lt;p&gt;How does it work?&lt;/p&gt;\n\n&lt;p&gt;Schemas are specially formatted JSON objects parsed at runtime.  The parsed schemas are converted into &amp;quot;factories&amp;quot; which can be used to serialize and deserialize any number of buffers. &lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;rs\nlet user_factory = NP_Factory::new(r#&amp;quot;{\n    &amp;quot;type&amp;quot;: &amp;quot;table&amp;quot;,\n    &amp;quot;columns&amp;quot;: [\n        [&amp;quot;name&amp;quot;,   {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;}],\n        [&amp;quot;age&amp;quot;,    {&amp;quot;type&amp;quot;: &amp;quot;u16&amp;quot;, &amp;quot;default&amp;quot;: 0}],\n        [&amp;quot;tags&amp;quot;,   {&amp;quot;type&amp;quot;: &amp;quot;list&amp;quot;, &amp;quot;of&amp;quot;: {\n            &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;\n        }}]\n    ]\n}&amp;quot;#).unwrap();\n&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;The schemas are validated to follow a specific format, which means the validation or JSON parsing can fail, thus the call to &lt;code&gt;.unwrap()&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Like Protocol Buffers, CapN Proto &amp;amp; Flatbuffers there are ways you can safely mutate the schema without breaking it&amp;#39;s ability to parse previous buffers. &lt;/p&gt;\n\n&lt;p&gt;```rs\n// safe mutation from previous schema, adding new column at the bottom\nlet user_factory = NP_Factory::new(r#&amp;quot;{\n    &amp;quot;type&amp;quot;: &amp;quot;table&amp;quot;,\n    &amp;quot;columns&amp;quot;: [\n        [&amp;quot;name&amp;quot;,   {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;}],\n        [&amp;quot;age&amp;quot;,    {&amp;quot;type&amp;quot;: &amp;quot;u16&amp;quot;, &amp;quot;default&amp;quot;: 0}],\n        [&amp;quot;tags&amp;quot;,   {&amp;quot;type&amp;quot;: &amp;quot;list&amp;quot;, &amp;quot;of&amp;quot;: {\n            &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;\n        }}],\n        [&amp;quot;phone&amp;quot;,    {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;}],\n    ]\n}&amp;quot;#)?;&lt;/p&gt;\n\n&lt;p&gt;// UNSAFE mutation from previous schema, deleting columns entirely (changes column order).\nlet user_factory = NP_Factory::new(r#&amp;quot;{\n    &amp;quot;type&amp;quot;: &amp;quot;table&amp;quot;,\n    &amp;quot;columns&amp;quot;: [\n        [&amp;quot;name&amp;quot;,   {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;}],\n        [&amp;quot;tags&amp;quot;,   {&amp;quot;type&amp;quot;: &amp;quot;list&amp;quot;, &amp;quot;of&amp;quot;: {\n            &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;\n        }}]\n    ]\n}&amp;quot;#)?;\n```&lt;/p&gt;\n\n&lt;p&gt;Once you have a factory, creating and opening buffers is easy and efficient.\n```rs\n// create a new empty buffer\nlet mut user_buffer = user_factory.empty_buffer(None, None);&lt;/p&gt;\n\n&lt;p&gt;// assign the name column\nuser_buffer.deep_set(&amp;quot;name&amp;quot;, String::from(&amp;quot;Billy Joel&amp;quot;)).unwrap();&lt;/p&gt;\n\n&lt;p&gt;// assign nested internal values, sets the first tag element\nuser_buffer.deep_set(&amp;quot;tags.0&amp;quot;, String::from(&amp;quot;first tag&amp;quot;)).unwrap();&lt;/p&gt;\n\n&lt;p&gt;// close buffer and get internal bytes\n// this is essentially a free operation, just moves the internal bytes out of the buffer\nlet user_bytes: Vec&amp;lt;u8&amp;gt; = user_buffer.close();&lt;/p&gt;\n\n&lt;p&gt;// user_bytes can be sent across the network, saved to disk, or whatever else you&amp;#39;d like... \n// then to open it again...&lt;/p&gt;\n\n&lt;p&gt;// open the buffer, essentially free operation as it just moves the Vec.&lt;br/&gt;\n// Zero parsing happens here\nlet user_buffer = user_factory.open_buffer(user_bytes);&lt;/p&gt;\n\n&lt;p&gt;// efficiently traverse the buffer to get internal value\n// only reads the value and a few other bytes from the buffer.\nlet tag = user_buffer.deep_get::&amp;lt;String&amp;gt;(&amp;quot;tags.0&amp;quot;).unwrap();\nassert_eq!(tag, Some(Box::new(String::from(&amp;quot;first tag&amp;quot;))));&lt;/p&gt;\n\n&lt;p&gt;// get nested internal value, the age field\nlet age = user_buffer.deep_get::&amp;lt;u16&amp;gt;(&amp;quot;age&amp;quot;)?;\n// returns default value from schema\nassert_eq!(age, Some(Box::new(0u16)));\n```&lt;/p&gt;\n\n&lt;p&gt;So we get the dynamic capabilities of something like JSON with the performance of CapNProto &amp;amp; Flatbuffers.  &lt;/p&gt;\n\n&lt;p&gt;The library is also fully documented and supports &lt;code&gt;no_std&lt;/code&gt;, so it will work with WASM as long as you include an allocator.&lt;/p&gt;\n\n&lt;p&gt;I hope you&amp;#39;ll find this library useful and any feedback / suggestions are welcome!&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://crates.io/crates/no_proto\"&gt;https://crates.io/crates/no_proto&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ih4qm6", "is_robot_indexable": true, "report_reasons": null, "author": "onlycliches", "discussion_type": null, "num_comments": 18, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/ih4qm6/motivations_for_noproto_library/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/rust/comments/ih4qm6/motivations_for_noproto_library/", "subreddit_subscribers": 111727, "created_utc": 1598467563.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_ih4qm6", "before": null}}