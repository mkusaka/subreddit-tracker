{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "", "author_fullname": "t2_bu67h", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "hubba gem - little github api helper for (auto-)generating statistics reports (summary, stars, timeline, updates)", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": 140, "top_awarded_type": null, "hide_score": false, "name": "t3_j8fz13", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "https://b.thumbs.redditmedia.com/HarvsJBGZ3kf5mSenri0iuFPlI99XAs-yP9BE99FG7E.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "link", "content_categories": null, "is_self": false, "mod_note": null, "created": 1602341854.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://github.com/rubycoco/git/tree/master/hubba", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/NGS6lCTVeozxUkFzDoJpU60rfpBx6ZVsf9Bf5SP4ZUw.jpg?auto=webp&amp;s=953b3678c3e8952f4b564dfa707cfd13dd605be5", "width": 256, "height": 256}, "resolutions": [{"url": "https://external-preview.redd.it/NGS6lCTVeozxUkFzDoJpU60rfpBx6ZVsf9Bf5SP4ZUw.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=85a053ea9052d55dbc50a6a8e16943767edae04f", "width": 108, "height": 108}, {"url": "https://external-preview.redd.it/NGS6lCTVeozxUkFzDoJpU60rfpBx6ZVsf9Bf5SP4ZUw.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=761ab3da112907d6886972777cfa8b49ef8ecd01", "width": 216, "height": 216}], "variants": {}, "id": "37oOMmuQfsRF678Qj5bf0kE0590QT2uVorZ9tjX1tnU"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "j8fz13", "is_robot_indexable": true, "report_reasons": null, "author": "geraldbauer", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/j8fz13/hubba_gem_little_github_api_helper_for/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/rubycoco/git/tree/master/hubba", "subreddit_subscribers": 67782, "created_utc": 1602313054.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "", "author_fullname": "t2_2wqagm4q", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Remote Ruby: Adam Wathan joins to talk TailwindCSS, Tailwind UI, and View Components", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": "", "downs": 0, "thumbnail_height": 140, "top_awarded_type": null, "hide_score": false, "name": "t3_j7zouw", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.93, "author_flair_background_color": null, "subreddit_type": "public", "ups": 33, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Podcast", "can_mod_post": false, "score": 33, "approved_by": null, "author_premium": false, "thumbnail": "https://b.thumbs.redditmedia.com/YlthTRQrwshoZpHrDbW-LITspMkyEr1rTkbT_UdkzME.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "link", "content_categories": null, "is_self": false, "mod_note": null, "created": 1602281623.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "share.transistor.fm", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://share.transistor.fm/s/7bd5b843", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/fceurwkv3tKEkxEv63JYA6Zwjlu-v8ODWdczCqAbv_g.jpg?auto=webp&amp;s=6341e0cf5c75ca40029a3ec027f549289f849b18", "width": 800, "height": 800}, "resolutions": [{"url": "https://external-preview.redd.it/fceurwkv3tKEkxEv63JYA6Zwjlu-v8ODWdczCqAbv_g.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=bd9739f48d9e96dc3367dc8a91eb6ff7e1028606", "width": 108, "height": 108}, {"url": "https://external-preview.redd.it/fceurwkv3tKEkxEv63JYA6Zwjlu-v8ODWdczCqAbv_g.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=24d1a55d37634c284dee1eb3485fbbb65bb17eb7", "width": 216, "height": 216}, {"url": "https://external-preview.redd.it/fceurwkv3tKEkxEv63JYA6Zwjlu-v8ODWdczCqAbv_g.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=8037d4d9ba93a13227c9885d97b03902518f801a", "width": 320, "height": 320}, {"url": "https://external-preview.redd.it/fceurwkv3tKEkxEv63JYA6Zwjlu-v8ODWdczCqAbv_g.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=f1be2b004b45e8790aa6e12839e9b0982526e0c1", "width": 640, "height": 640}], "variants": {}, "id": "rw54Yic_EmGnH7CueCqesISm133oiJGlOUHorLEH-9Q"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "91df2474-873d-11e9-a45d-0e56054fcf08", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "j7zouw", "is_robot_indexable": true, "report_reasons": null, "author": "andrewmc0des", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/j7zouw/remote_ruby_adam_wathan_joins_to_talk_tailwindcss/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://share.transistor.fm/s/7bd5b843", "subreddit_subscribers": 67782, "created_utc": 1602252823.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "I'm trying to generate a fixed digit random number, and I came across this code. Could someone help me with what is happening here?  \n\n\nI'm not sure i get much from the documentation for rand either.", "author_fullname": "t2_7m8mv9r7", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Can someone help me out with what this does rand(999_999)", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": "", "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_j7vkhg", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.83, "author_flair_background_color": null, "subreddit_type": "public", "ups": 7, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Question", "can_mod_post": false, "score": 7, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1602262684.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m trying to generate a fixed digit random number, and I came across this code. Could someone help me with what is happening here?  &lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m not sure i get much from the documentation for rand either.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "d3392e70-873c-11e9-af37-0eea3fce36a6", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "j7vkhg", "is_robot_indexable": true, "report_reasons": null, "author": "prosperousdoggo", "discussion_type": null, "num_comments": 5, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/j7vkhg/can_someone_help_me_out_with_what_this_does/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/j7vkhg/can_someone_help_me_out_with_what_this_does/", "subreddit_subscribers": 67782, "created_utc": 1602233884.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "I've spent a good part of this year working on revisions to the RDoc for Hash.  The revisions include all methods documentation in addition to much of the introductory text (class documentation).  Lots more example code.\n\nCheck it out:\n\n\\- 2.7.2: [https://ruby-doc.org/core-2.7.2/Hash.html](https://ruby-doc.org/core-2.7.2/Hash.html)\n\n\\- 2.7.1: [https://ruby-doc.org/core-2.7.1/Hash.html](https://ruby-doc.org/core-2.7.1/Hash.html)", "author_fullname": "t2_1ruooe", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Ruby 2.7.2 has revised Rdoc for Hash", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_j7l51e", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.97, "author_flair_background_color": null, "subreddit_type": "public", "ups": 62, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 62, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1602218700.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;ve spent a good part of this year working on revisions to the RDoc for Hash.  The revisions include all methods documentation in addition to much of the introductory text (class documentation).  Lots more example code.&lt;/p&gt;\n\n&lt;p&gt;Check it out:&lt;/p&gt;\n\n&lt;p&gt;- 2.7.2: &lt;a href=\"https://ruby-doc.org/core-2.7.2/Hash.html\"&gt;https://ruby-doc.org/core-2.7.2/Hash.html&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;- 2.7.1: &lt;a href=\"https://ruby-doc.org/core-2.7.1/Hash.html\"&gt;https://ruby-doc.org/core-2.7.1/Hash.html&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "j7l51e", "is_robot_indexable": true, "report_reasons": null, "author": "BurdetteLamar", "discussion_type": null, "num_comments": 18, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/j7l51e/ruby_272_has_revised_rdoc_for_hash/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/j7l51e/ruby_272_has_revised_rdoc_for_hash/", "subreddit_subscribers": 67782, "created_utc": 1602189900.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "I am looking for something like Julia's `Threads.@threads` macro, which allows to parallelize a for loop within multithreading, now I am looking for something like this for Ruby.", "author_fullname": "t2_57t3n9fq", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Multithreading -- Parallelizing loops", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_j80sz0", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.67, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1602285350.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I am looking for something like Julia&amp;#39;s &lt;code&gt;Threads.@threads&lt;/code&gt; macro, which allows to parallelize a for loop within multithreading, now I am looking for something like this for Ruby.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "j80sz0", "is_robot_indexable": true, "report_reasons": null, "author": "GPhykos", "discussion_type": null, "num_comments": 5, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/j80sz0/multithreading_parallelizing_loops/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/j80sz0/multithreading_parallelizing_loops/", "subreddit_subscribers": 67782, "created_utc": 1602256550.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "I found this code to generate 6 digit number \n\n    rand(100000...999999)\n\nIs this approach fine?   \nI'm not sure what the two dots(..) or three dots(...) mean and I hope it doesn't expand into an array and then rand selects a values", "author_fullname": "t2_7m8mv9r7", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Fastest way to generating a n digit number", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": "", "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_j7w5xn", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.84, "author_flair_background_color": null, "subreddit_type": "public", "ups": 4, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Question", "can_mod_post": false, "score": 4, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1602266150.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I found this code to generate 6 digit number &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;rand(100000...999999)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Is this approach fine?&lt;br/&gt;\nI&amp;#39;m not sure what the two dots(..) or three dots(...) mean and I hope it doesn&amp;#39;t expand into an array and then rand selects a values&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "d3392e70-873c-11e9-af37-0eea3fce36a6", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "j7w5xn", "is_robot_indexable": true, "report_reasons": null, "author": "prosperousdoggo", "discussion_type": null, "num_comments": 4, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/j7w5xn/fastest_way_to_generating_a_n_digit_number/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/j7w5xn/fastest_way_to_generating_a_n_digit_number/", "subreddit_subscribers": 67782, "created_utc": 1602237350.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "", "author_fullname": "t2_1iquhusy", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Speeding up Rails with Memoization", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": 70, "top_awarded_type": null, "hide_score": false, "name": "t3_j7v6l2", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.67, "author_flair_background_color": null, "subreddit_type": "public", "ups": 4, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 4, "approved_by": null, "author_premium": false, "thumbnail": "https://a.thumbs.redditmedia.com/Xjq8cQFeQ8N9ZWXnj-yQxO9ywuqcFKDwFHBndDJ5KM0.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "link", "content_categories": null, "is_self": false, "mod_note": null, "created": 1602260419.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "honeybadger.io", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://www.honeybadger.io/blog/ruby-rails-memoization/?utm_source=rubyweekly&amp;utm_medium=email&amp;utm_campaign=ruby", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/LTLgvLhYHk_H2MxvebMtWTbqq-zeVK6ghhZX4NkuksY.jpg?auto=webp&amp;s=946dfa2b21fed19e3ce735d5cce6050591e546b8", "width": 2048, "height": 1024}, "resolutions": [{"url": "https://external-preview.redd.it/LTLgvLhYHk_H2MxvebMtWTbqq-zeVK6ghhZX4NkuksY.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=95baefaf60da93e911a02b209152fcbb7d6c1cdf", "width": 108, "height": 54}, {"url": "https://external-preview.redd.it/LTLgvLhYHk_H2MxvebMtWTbqq-zeVK6ghhZX4NkuksY.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=2aeff025d6e18a37377240b05e3da79e7ec963f3", "width": 216, "height": 108}, {"url": "https://external-preview.redd.it/LTLgvLhYHk_H2MxvebMtWTbqq-zeVK6ghhZX4NkuksY.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=29fc881aa01d339ea0528775350d3518f570c8d5", "width": 320, "height": 160}, {"url": "https://external-preview.redd.it/LTLgvLhYHk_H2MxvebMtWTbqq-zeVK6ghhZX4NkuksY.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=8166cf64db3d115696ec6cc461ea988357e864e7", "width": 640, "height": 320}, {"url": "https://external-preview.redd.it/LTLgvLhYHk_H2MxvebMtWTbqq-zeVK6ghhZX4NkuksY.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=31ba2de3e3993c26453d2e74bb3b358f4d7e53e3", "width": 960, "height": 480}, {"url": "https://external-preview.redd.it/LTLgvLhYHk_H2MxvebMtWTbqq-zeVK6ghhZX4NkuksY.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=a2601feb68388948ea92b47b54801fb557460e2b", "width": 1080, "height": 540}], "variants": {}, "id": "K_xfFOANcSVffWV8_XSK1nE4Zws0JCj6BdEwR7tfxBI"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "j7v6l2", "is_robot_indexable": true, "report_reasons": null, "author": "flower_power_2000", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/j7v6l2/speeding_up_rails_with_memoization/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.honeybadger.io/blog/ruby-rails-memoization/?utm_source=rubyweekly&amp;utm_medium=email&amp;utm_campaign=ruby", "subreddit_subscribers": 67782, "created_utc": 1602231619.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "Context:  \n I am pulling in data from a social media site and storing it in my database. For eg. Everday I make an api req to fetch all tweets of a user. Then make another api req for each tweet to fetch its public\\_metrics like tweets, likes,etc.   \n\n\nIf I am using Sidekiq, how should I build my data pipeline?  \n\n\nRight now, I have a worker who just makes both the api calls from the same worker.  \nShould I separate, \"fetching all tweets\" into a seprate worker and \"fetch tweets metrics\" into a separate wrker?", "author_fullname": "t2_3s6jjcxn", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Beginner need some help understaind data pipeline", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_j7vlbx", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.81, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1602262820.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Context:&lt;br/&gt;\n I am pulling in data from a social media site and storing it in my database. For eg. Everday I make an api req to fetch all tweets of a user. Then make another api req for each tweet to fetch its public_metrics like tweets, likes,etc.   &lt;/p&gt;\n\n&lt;p&gt;If I am using Sidekiq, how should I build my data pipeline?  &lt;/p&gt;\n\n&lt;p&gt;Right now, I have a worker who just makes both the api calls from the same worker.&lt;br/&gt;\nShould I separate, &amp;quot;fetching all tweets&amp;quot; into a seprate worker and &amp;quot;fetch tweets metrics&amp;quot; into a separate wrker?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "j7vlbx", "is_robot_indexable": true, "report_reasons": null, "author": "sitaram_", "discussion_type": null, "num_comments": 7, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/j7vlbx/beginner_need_some_help_understaind_data_pipeline/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/j7vlbx/beginner_need_some_help_understaind_data_pipeline/", "subreddit_subscribers": 67782, "created_utc": 1602234020.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "[https://www.ruby-lang.org/en/news/2020/10/02/ruby-2-7-2-released/](https://www.ruby-lang.org/en/news/2020/10/02/ruby-2-7-2-released/)\n\nAnybody know what the incompatibility is? I'm glad they mention it as an issue, but I couldn't find any details on that page.", "author_fullname": "t2_4emgi", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "\"Ruby 2.7.2 ... contains intentional incompatibility\"", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_j7fk83", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.95, "author_flair_background_color": null, "subreddit_type": "public", "ups": 18, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 18, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1602201185.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;a href=\"https://www.ruby-lang.org/en/news/2020/10/02/ruby-2-7-2-released/\"&gt;https://www.ruby-lang.org/en/news/2020/10/02/ruby-2-7-2-released/&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Anybody know what the incompatibility is? I&amp;#39;m glad they mention it as an issue, but I couldn&amp;#39;t find any details on that page.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "j7fk83", "is_robot_indexable": true, "report_reasons": null, "author": "dogweather", "discussion_type": null, "num_comments": 8, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/j7fk83/ruby_272_contains_intentional_incompatibility/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/j7fk83/ruby_272_contains_intentional_incompatibility/", "subreddit_subscribers": 67782, "created_utc": 1602172385.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "I have two strings say first = \"say\" and second = \"henlo\". I want to find the shortest possible user-friendly string(a-z, 0-9) that can encode this information. This string isn't any encrypted value I want it to be as human-readable as possible.\n\nThis is how I do it currently. I combine the two words with space since both the words can't contain space like \"first second\" word = \"say henlo\" and compute the hexdigest using SHA1 and I get a value like so\n\n    require 'faker'\n    \n    all = {}\n    iterations = 5000000\n    word_size = 10\n    count, duplicates = 0, 0\n    \n    iterations.times do\n        word = Faker::Lorem.sentence(80, true, 15).split(' ').sample(2).join(' ')\n        digest = Digest::SHA1.hexdigest(word)[0..word_size-1]\n        if all[digest] == word\n            duplicates += 1\n            next\n        end\n        if all.include?(digest) \n            puts [digest, all[digest], word].inspect\n            count += 1\n        end\n        all[digest] = word\n    end\n    puts [iterations, word_size, duplicates, count, (count.to_f / (iterations - duplicates)) * 100].inspect\n\nAnd this is the result I got\n\n    [1000000, 8, 363802, 64, 0.01]\n    [1000000, 10, 363723, 0, 0.0]\n    [5000000, 10, 3769185, 0, 0.0]\n\nNow, I have a couple of questions.\n\n1. Is there any other way to shrink the hexdigest likes into something shorter, and user-readable string without increasing the chance of collision?\n2. What is the probability that taking the first n characters is unique for a set of words like 1M words? How could I reliability calculate it to compute the trade-offs\n\nEDIT:The purpose of the short string isn't to substitute saving both the string themselves but to generate a short string for the user which they can use in their API calls.  \nEDIT 2: The reason I can't use the \"human-friend\" words as it is, is because it can be languages with accents(French and unicode ones also)  and API key is ASCII only. ", "author_fullname": "t2_7m8mv9r7", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Help to create the shortest hexadecimal string from two strings", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": "", "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_j7juoj", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.81, "author_flair_background_color": null, "subreddit_type": "public", "ups": 6, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Question", "can_mod_post": false, "score": 6, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": 1602189436.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1602214613.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I have two strings say first = &amp;quot;say&amp;quot; and second = &amp;quot;henlo&amp;quot;. I want to find the shortest possible user-friendly string(a-z, 0-9) that can encode this information. This string isn&amp;#39;t any encrypted value I want it to be as human-readable as possible.&lt;/p&gt;\n\n&lt;p&gt;This is how I do it currently. I combine the two words with space since both the words can&amp;#39;t contain space like &amp;quot;first second&amp;quot; word = &amp;quot;say henlo&amp;quot; and compute the hexdigest using SHA1 and I get a value like so&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;require &amp;#39;faker&amp;#39;\n\nall = {}\niterations = 5000000\nword_size = 10\ncount, duplicates = 0, 0\n\niterations.times do\n    word = Faker::Lorem.sentence(80, true, 15).split(&amp;#39; &amp;#39;).sample(2).join(&amp;#39; &amp;#39;)\n    digest = Digest::SHA1.hexdigest(word)[0..word_size-1]\n    if all[digest] == word\n        duplicates += 1\n        next\n    end\n    if all.include?(digest) \n        puts [digest, all[digest], word].inspect\n        count += 1\n    end\n    all[digest] = word\nend\nputs [iterations, word_size, duplicates, count, (count.to_f / (iterations - duplicates)) * 100].inspect\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And this is the result I got&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;[1000000, 8, 363802, 64, 0.01]\n[1000000, 10, 363723, 0, 0.0]\n[5000000, 10, 3769185, 0, 0.0]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now, I have a couple of questions.&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Is there any other way to shrink the hexdigest likes into something shorter, and user-readable string without increasing the chance of collision?&lt;/li&gt;\n&lt;li&gt;What is the probability that taking the first n characters is unique for a set of words like 1M words? How could I reliability calculate it to compute the trade-offs&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;EDIT:The purpose of the short string isn&amp;#39;t to substitute saving both the string themselves but to generate a short string for the user which they can use in their API calls.&lt;br/&gt;\nEDIT 2: The reason I can&amp;#39;t use the &amp;quot;human-friend&amp;quot; words as it is, is because it can be languages with accents(French and unicode ones also)  and API key is ASCII only. &lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "d3392e70-873c-11e9-af37-0eea3fce36a6", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "j7juoj", "is_robot_indexable": true, "report_reasons": null, "author": "prosperousdoggo", "discussion_type": null, "num_comments": 8, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/j7juoj/help_to_create_the_shortest_hexadecimal_string/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/j7juoj/help_to_create_the_shortest_hexadecimal_string/", "subreddit_subscribers": 67782, "created_utc": 1602185813.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_j7juoj", "before": null}}