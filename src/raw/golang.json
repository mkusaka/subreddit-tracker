{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_3ebii", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How to find a job as a Go developer?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i9ma30", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.9, "author_flair_background_color": null, "subreddit_type": "public", "ups": 232, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": true, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 232, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1597441711.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "i.redd.it", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://i.redd.it/7ndi0qt33zg51.png", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i9ma30", "is_robot_indexable": true, "report_reasons": null, "author": "KevBurnsJr", "discussion_type": null, "num_comments": 77, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i9ma30/how_to_find_a_job_as_a_go_developer/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://i.redd.it/7ndi0qt33zg51.png", "subreddit_subscribers": 122318, "created_utc": 1597412911.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_4yljdd94", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How to update field in mongodb of type map[string]interface{} , Golang ?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": true, "name": "t3_ia6rtc", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "crosspost_parent_list": [{"approved_at_utc": null, "subreddit": "mongodb", "selftext": "I am trying to update field \"Comments\" in MongoDB of type \"map\\[string\\]interface{}\" , I tried several things but no luck I am unable to find where I am doing wrong. Till now I've tried \"$push\",\"$set\". Tried reading official/unofficial docs\n\nAny help is appreciated.\n\n**Struct for storing in MongoDB.**\n\n    package entities\n    \n    type IMDBRegistry struct {\n    \tMovieName   string                 `json:\"moviename,omitempty\"`\n    \tRating      string                 `json:\"rating,omitempty\"`\n    \tRatingCount int                    `json:\"peoplecount,omitempty\"`\n    \tComments    map[string]interface{} `json:\"comments,omitempty\"`\n    }\n\nGolang Code I tried for updating the \"Comments\" field.  It is only portion of code , it is untidy because I tried several things,  I've commented it for readablity.\n\n    //Reading MongoDB database based on the MovieName provided.\n    searchResult, err := ReadDocument(entities.IMDBRegistry{MovieName: movieName}, &amp;entities.IMDBRegistry{})\n    // Printing the MongoDB response for debugging purpose.\n    log.Println(\"SearchResult is :\", searchResult)\n    if err != nil {\t}\n    //If MongoDB response is not nil then proceed.\n    if searchResult != nil {\n        result := searchResult.(entities.IMDBRegistry)\n        commentUp := result.Comments\n        log.Println(\"CommentUp :\", commentUp)\n        commentUp[userName] = movieComment[\"comments\"]\n        log.Println(\"CommentUp after update:\", commentUp)\n        //update := make(map[string]interface{})\n        //update[\"comments\"]=commentUp[]\n        for i, v := range commentUp {\n    \tfmt.Println(\"i:\", i, \"v:\", v)\n        }\n    \n        fmt.Println(\"results.Comment\", result.Comments)\n        fmt.Println(\"results.Comment[admin]\", result.Comments[\"admin\"])\n        /*_, err := UpdateDocument(entities.IMDBRegistry{Comments: commentUp}, \"$push\", nil)\n        if err != nil {\n    \tlog.Println(\"Error while updating document\", err)\n    \t}*/\n            // Need help here while updating.\n    \tupdateRes, err := UpdateDocument(entities.IMDBRegistry{Comments: commentUp}, \"$set\", movieComment)\n            fmt.Println(\"UpdateRes: \", updateRes)\n    \tfmt.Println(\"Err :\", err)\n    \tif err != nil {\n    \t     log.Println(\"Error while updating document\", err)\n           \t}\n\n&amp;#x200B;\n\nThank you for help :-)", "author_fullname": "t2_4yljdd94", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How to update field in mongodb of type map[string]interface{} , Golang ?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/mongodb", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": true, "name": "t3_ia6foo", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1597494520.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1597523103.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.mongodb", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I am trying to update field &amp;quot;Comments&amp;quot; in MongoDB of type &amp;quot;map[string]interface{}&amp;quot; , I tried several things but no luck I am unable to find where I am doing wrong. Till now I&amp;#39;ve tried &amp;quot;$push&amp;quot;,&amp;quot;$set&amp;quot;. Tried reading official/unofficial docs&lt;/p&gt;\n\n&lt;p&gt;Any help is appreciated.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Struct for storing in MongoDB.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package entities\n\ntype IMDBRegistry struct {\n    MovieName   string                 `json:&amp;quot;moviename,omitempty&amp;quot;`\n    Rating      string                 `json:&amp;quot;rating,omitempty&amp;quot;`\n    RatingCount int                    `json:&amp;quot;peoplecount,omitempty&amp;quot;`\n    Comments    map[string]interface{} `json:&amp;quot;comments,omitempty&amp;quot;`\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Golang Code I tried for updating the &amp;quot;Comments&amp;quot; field.  It is only portion of code , it is untidy because I tried several things,  I&amp;#39;ve commented it for readablity.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;//Reading MongoDB database based on the MovieName provided.\nsearchResult, err := ReadDocument(entities.IMDBRegistry{MovieName: movieName}, &amp;amp;entities.IMDBRegistry{})\n// Printing the MongoDB response for debugging purpose.\nlog.Println(&amp;quot;SearchResult is :&amp;quot;, searchResult)\nif err != nil { }\n//If MongoDB response is not nil then proceed.\nif searchResult != nil {\n    result := searchResult.(entities.IMDBRegistry)\n    commentUp := result.Comments\n    log.Println(&amp;quot;CommentUp :&amp;quot;, commentUp)\n    commentUp[userName] = movieComment[&amp;quot;comments&amp;quot;]\n    log.Println(&amp;quot;CommentUp after update:&amp;quot;, commentUp)\n    //update := make(map[string]interface{})\n    //update[&amp;quot;comments&amp;quot;]=commentUp[]\n    for i, v := range commentUp {\n    fmt.Println(&amp;quot;i:&amp;quot;, i, &amp;quot;v:&amp;quot;, v)\n    }\n\n    fmt.Println(&amp;quot;results.Comment&amp;quot;, result.Comments)\n    fmt.Println(&amp;quot;results.Comment[admin]&amp;quot;, result.Comments[&amp;quot;admin&amp;quot;])\n    /*_, err := UpdateDocument(entities.IMDBRegistry{Comments: commentUp}, &amp;quot;$push&amp;quot;, nil)\n    if err != nil {\n    log.Println(&amp;quot;Error while updating document&amp;quot;, err)\n    }*/\n        // Need help here while updating.\n    updateRes, err := UpdateDocument(entities.IMDBRegistry{Comments: commentUp}, &amp;quot;$set&amp;quot;, movieComment)\n        fmt.Println(&amp;quot;UpdateRes: &amp;quot;, updateRes)\n    fmt.Println(&amp;quot;Err :&amp;quot;, err)\n    if err != nil {\n         log.Println(&amp;quot;Error while updating document&amp;quot;, err)\n        }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;Thank you for help :-)&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rjwd", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ia6foo", "is_robot_indexable": true, "report_reasons": null, "author": "makeeverysecondcount", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/mongodb/comments/ia6foo/how_to_update_field_in_mongodb_of_type/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/mongodb/comments/ia6foo/how_to_update_field_in_mongodb_of_type/", "subreddit_subscribers": 10709, "created_utc": 1597494303.0, "num_crossposts": 1, "media": null, "is_video": false}], "created": 1597524555.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.mongodb", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "/r/mongodb/comments/ia6foo/how_to_update_field_in_mongodb_of_type/", "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ia6rtc", "is_robot_indexable": true, "report_reasons": null, "author": "makeeverysecondcount", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "crosspost_parent": "t3_ia6foo", "author_flair_text_color": null, "permalink": "/r/golang/comments/ia6rtc/how_to_update_field_in_mongodb_of_type/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "/r/mongodb/comments/ia6foo/how_to_update_field_in_mongodb_of_type/", "subreddit_subscribers": 122318, "created_utc": 1597495755.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_3463x", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Swimming in Datalakes with Go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i9oxm8", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 12, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 12, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1597450637.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "fraugster.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://fraugster.com/blog/post/future-proofing-our-storage-needs-with-aws-athena-apache-parquet", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i9oxm8", "is_robot_indexable": true, "report_reasons": null, "author": "_ak", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i9oxm8/swimming_in_datalakes_with_go/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://fraugster.com/blog/post/future-proofing-our-storage-needs-with-aws-athena-apache-parquet", "subreddit_subscribers": 122318, "created_utc": 1597421837.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_jvx69", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "I also push directly to prod!", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i91ynq", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.93, "author_flair_background_color": null, "subreddit_type": "public", "ups": 609, "total_awards_received": 1, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": true, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 609, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1597361381.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "i.redd.it", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://i.redd.it/ql3zpki3gsg51.png", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [{"giver_coin_reward": null, "subreddit_id": null, "is_new": false, "days_of_drip_extension": 0, "coin_price": 125, "id": "award_5f123e3d-4f48-42f4-9c11-e98b566d5897", "penny_donate": null, "award_sub_type": "GLOBAL", "coin_reward": 0, "icon_url": "https://i.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png", "days_of_premium": 0, "resized_icons": [{"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=16&amp;height=16&amp;auto=webp&amp;s=92932f465d58e4c16b12b6eac4ca07d27e3d11c0", "width": 16, "height": 16}, {"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=32&amp;height=32&amp;auto=webp&amp;s=d11484a208d68a318bf9d4fcf371171a1cb6a7ef", "width": 32, "height": 32}, {"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=48&amp;height=48&amp;auto=webp&amp;s=febdf28b6f39f7da7eb1365325b85e0bb49a9f63", "width": 48, "height": 48}, {"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=64&amp;height=64&amp;auto=webp&amp;s=b4406a2d88bf86fa3dc8a45aacf7e0c7bdccc4fb", "width": 64, "height": 64}, {"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=128&amp;height=128&amp;auto=webp&amp;s=19555b13e3e196b62eeb9160d1ac1d1b372dcb0b", "width": 128, "height": 128}], "icon_width": 2048, "static_icon_width": 2048, "start_date": null, "is_enabled": true, "description": "When you come across a feel-good thing.", "end_date": null, "subreddit_coin_reward": 0, "count": 1, "static_icon_height": 2048, "name": "Wholesome", "resized_static_icons": [{"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=16&amp;height=16&amp;auto=webp&amp;s=92932f465d58e4c16b12b6eac4ca07d27e3d11c0", "width": 16, "height": 16}, {"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=32&amp;height=32&amp;auto=webp&amp;s=d11484a208d68a318bf9d4fcf371171a1cb6a7ef", "width": 32, "height": 32}, {"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=48&amp;height=48&amp;auto=webp&amp;s=febdf28b6f39f7da7eb1365325b85e0bb49a9f63", "width": 48, "height": 48}, {"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=64&amp;height=64&amp;auto=webp&amp;s=b4406a2d88bf86fa3dc8a45aacf7e0c7bdccc4fb", "width": 64, "height": 64}, {"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=128&amp;height=128&amp;auto=webp&amp;s=19555b13e3e196b62eeb9160d1ac1d1b372dcb0b", "width": 128, "height": 128}], "icon_format": null, "icon_height": 2048, "penny_price": null, "award_type": "global", "static_icon_url": "https://i.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png"}], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i91ynq", "is_robot_indexable": true, "report_reasons": null, "author": "klauspost", "discussion_type": null, "num_comments": 79, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i91ynq/i_also_push_directly_to_prod/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://i.redd.it/ql3zpki3gsg51.png", "subreddit_subscribers": 122318, "created_utc": 1597332581.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hello everyone, i want to upload an image received from a form input to a cloud service like cloudinary, but i am unable to find any suitable library for doing that.\nWhat library do you use to perform file uploads or which cloud storage service do you use with your golang applications.\nThanks", "author_fullname": "t2_44vg3k2z", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Upload images to cloud storage service", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i9y426", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.67, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1597481390.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hello everyone, i want to upload an image received from a form input to a cloud service like cloudinary, but i am unable to find any suitable library for doing that.\nWhat library do you use to perform file uploads or which cloud storage service do you use with your golang applications.\nThanks&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i9y426", "is_robot_indexable": true, "report_reasons": null, "author": "ant1g3n", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i9y426/upload_images_to_cloud_storage_service/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/i9y426/upload_images_to_cloud_storage_service/", "subreddit_subscribers": 122318, "created_utc": 1597452590.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Not sure if the subject makes sense.. so more explanation here. Basically I have a simple microservice.. it uses the DB in CRUD fashion. But.. it has to handle potentially hundreds of requests at the same time.\n\nI turned to PGX as it is supposedly faster (for Postgresql), and it has a connection pool for handling concurrency. That's great.\n\nWhat confuses me is how to maintain the DB object I use to GET connections from, across threads. If it's not obvious, I am using this in an API back end.. so each request is running in it's own thread (or go func).\n\nSo let me ask this.. in my code, main.go, I have something like this:\n\n pool, err := pgxpool.Connect(context.Background(), os.Getenv(\"DATABASE\\_URL\")) \n\nFirst question I have is.. the context.Background()... shouldn't that be set to the context that my request is using? The issue I see here is.. the above call should be done once (on service start), where as each request comes in randomly and has a new context for it. So I am not sure how I pass my request context to the DB so that if some other routine cancels the request, the DB code that may be running ALSO cancels. There is this notion that maybe a long running request (e.g. one that the socket to the client stays open for some period of time like web socket) can be cancelled. If the DB is doing a billion record search..but the request is no longer of use.. I assume cancelling it via context Cancel() should propagate to the DB code to just terminate the search..thus reducing the use of resources when not needed. Is this accurate? I am unclear HOW you make this happen though.\n\nAnyway, so, I have this in my code:\n\n    type Datasource struct {\n      ConPool *Pool\n    }\n    \n    var db Datasource = Datasource{}\n    \n    func main() {\n        // load env\n        pool, err := pgxpool.Connect(context.Background(), os.Getenv(\"DATABASE_URL\")) \n        // no err\n        db.ConPool = pool\n    }\n    \n    func GetPool() (Datasource, error) {\n      return db, nil\n    }\n\nI realize the code above is not perfect.. e.g. I would handle errors, check for nil/empty, etc. Trying to reduce the amount.\n\nAnyway, so in my api handler/router code, I am not sure exactly how I do things to pass the context that is part of the request, to the db.. but I assume it is something like this:\n\n \n\n    func myHandler(w http.ResponseWriter, r *http.Request) {\n      conn, err := GetPool().ConPool.Acquire(r.Context())\n      // no error\n      defer conn.Release()\n      // do something with request level connection\n    }\n\n  So the two questions I am trying to understand/solve.. first.. is using a global var for the Datasource struct the right way.. and OK in that it holds the one time setup for the connection pool? In other words, I only have to connect to the DB one time during the existence of the running service (short of some connection issue.. which I should ALSO account for and reconnect should it fail, etc)? Or do I have to.. on every single incoming request, establish another connection to the DB? I assume its the former.. as it doesnt seem to make sense that you would have a connection pool to pull from if you have to do the heavier connection to DB every time?\n\nSecond, when acquiring a connection or getting one.. is using r.Context() the right way to pass the request context.. and WILL that allow the DB code to \"stop\" mid stream should the context Cancel() be called.. thus properly freeing up DB resources/connection pool (con returns to pool), etc?\n\n&amp;#x200B;\n\nThanks.", "author_fullname": "t2_5rkthjpv", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How do you manage the DB object instance in your microservice while handling concurrency?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i9r7j8", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1597457865.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Not sure if the subject makes sense.. so more explanation here. Basically I have a simple microservice.. it uses the DB in CRUD fashion. But.. it has to handle potentially hundreds of requests at the same time.&lt;/p&gt;\n\n&lt;p&gt;I turned to PGX as it is supposedly faster (for Postgresql), and it has a connection pool for handling concurrency. That&amp;#39;s great.&lt;/p&gt;\n\n&lt;p&gt;What confuses me is how to maintain the DB object I use to GET connections from, across threads. If it&amp;#39;s not obvious, I am using this in an API back end.. so each request is running in it&amp;#39;s own thread (or go func).&lt;/p&gt;\n\n&lt;p&gt;So let me ask this.. in my code, main.go, I have something like this:&lt;/p&gt;\n\n&lt;p&gt;pool, err := pgxpool.Connect(context.Background(), os.Getenv(&amp;quot;DATABASE_URL&amp;quot;)) &lt;/p&gt;\n\n&lt;p&gt;First question I have is.. the context.Background()... shouldn&amp;#39;t that be set to the context that my request is using? The issue I see here is.. the above call should be done once (on service start), where as each request comes in randomly and has a new context for it. So I am not sure how I pass my request context to the DB so that if some other routine cancels the request, the DB code that may be running ALSO cancels. There is this notion that maybe a long running request (e.g. one that the socket to the client stays open for some period of time like web socket) can be cancelled. If the DB is doing a billion record search..but the request is no longer of use.. I assume cancelling it via context Cancel() should propagate to the DB code to just terminate the search..thus reducing the use of resources when not needed. Is this accurate? I am unclear HOW you make this happen though.&lt;/p&gt;\n\n&lt;p&gt;Anyway, so, I have this in my code:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Datasource struct {\n  ConPool *Pool\n}\n\nvar db Datasource = Datasource{}\n\nfunc main() {\n    // load env\n    pool, err := pgxpool.Connect(context.Background(), os.Getenv(&amp;quot;DATABASE_URL&amp;quot;)) \n    // no err\n    db.ConPool = pool\n}\n\nfunc GetPool() (Datasource, error) {\n  return db, nil\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I realize the code above is not perfect.. e.g. I would handle errors, check for nil/empty, etc. Trying to reduce the amount.&lt;/p&gt;\n\n&lt;p&gt;Anyway, so in my api handler/router code, I am not sure exactly how I do things to pass the context that is part of the request, to the db.. but I assume it is something like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func myHandler(w http.ResponseWriter, r *http.Request) {\n  conn, err := GetPool().ConPool.Acquire(r.Context())\n  // no error\n  defer conn.Release()\n  // do something with request level connection\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So the two questions I am trying to understand/solve.. first.. is using a global var for the Datasource struct the right way.. and OK in that it holds the one time setup for the connection pool? In other words, I only have to connect to the DB one time during the existence of the running service (short of some connection issue.. which I should ALSO account for and reconnect should it fail, etc)? Or do I have to.. on every single incoming request, establish another connection to the DB? I assume its the former.. as it doesnt seem to make sense that you would have a connection pool to pull from if you have to do the heavier connection to DB every time?&lt;/p&gt;\n\n&lt;p&gt;Second, when acquiring a connection or getting one.. is using r.Context() the right way to pass the request context.. and WILL that allow the DB code to &amp;quot;stop&amp;quot; mid stream should the context Cancel() be called.. thus properly freeing up DB resources/connection pool (con returns to pool), etc?&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;Thanks.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i9r7j8", "is_robot_indexable": true, "report_reasons": null, "author": "golangorgohome", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i9r7j8/how_do_you_manage_the_db_object_instance_in_your/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/i9r7j8/how_do_you_manage_the_db_object_instance_in_your/", "subreddit_subscribers": 122318, "created_utc": 1597429065.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_5ibor34y", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "From Python to Go: migrating our entire API", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i9fo8f", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.75, "author_flair_background_color": null, "subreddit_type": "public", "ups": 34, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 34, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1597409300.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "repustate.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://www.repustate.com/blog/migrating-entire-api-go-python/", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i9fo8f", "is_robot_indexable": true, "report_reasons": null, "author": "aman_agrwl", "discussion_type": null, "num_comments": 16, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i9fo8f/from_python_to_go_migrating_our_entire_api/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.repustate.com/blog/migrating-entire-api-go-python/", "subreddit_subscribers": 122318, "created_utc": 1597380500.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_3em9l", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Go 1.15's interface optimization for small integers is invisible to Go programs", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i9ll67", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.82, "author_flair_background_color": null, "subreddit_type": "public", "ups": 7, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 7, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1597439114.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "utcc.utoronto.ca", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://utcc.utoronto.ca/~cks/space/blog/programming/Go115InterfaceSmallIntsII", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i9ll67", "is_robot_indexable": true, "report_reasons": null, "author": "skeeto", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i9ll67/go_115s_interface_optimization_for_small_integers/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://utcc.utoronto.ca/~cks/space/blog/programming/Go115InterfaceSmallIntsII", "subreddit_subscribers": 122318, "created_utc": 1597410314.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hi Everyone, I have wrote a back-end machine learning process in Python but due to the global interpreter lock (GIL) , it isn't going to scale for production purposes.\n\nBeen looking at  converting the Python code into either Go or Java.  From what I have seen so far, both languages can carry out the processes that I need.\n\nWhich of the two languages is faster in Tesseract OCR and linear algebra processes and makes it easy to print the results in a React framework?\n\nThank you for your time.", "author_fullname": "t2_76jy76qf", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Use Go or Java for back-end machine learning processes to post results to React front-end?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i9ug2k", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.66, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1597439970.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1597468365.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hi Everyone, I have wrote a back-end machine learning process in Python but due to the global interpreter lock (GIL) , it isn&amp;#39;t going to scale for production purposes.&lt;/p&gt;\n\n&lt;p&gt;Been looking at  converting the Python code into either Go or Java.  From what I have seen so far, both languages can carry out the processes that I need.&lt;/p&gt;\n\n&lt;p&gt;Which of the two languages is faster in Tesseract OCR and linear algebra processes and makes it easy to print the results in a React framework?&lt;/p&gt;\n\n&lt;p&gt;Thank you for your time.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i9ug2k", "is_robot_indexable": true, "report_reasons": null, "author": "Frequent-Pass457", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i9ug2k/use_go_or_java_for_backend_machine_learning/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/i9ug2k/use_go_or_java_for_backend_machine_learning/", "subreddit_subscribers": 122318, "created_utc": 1597439565.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_x09ef", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "SSH Port Forwarding Tool with Resiliency and UX", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i9tjzy", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.43, "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1597465455.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "davrodpin.github.io", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://davrodpin.github.io/mole/", "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i9tjzy", "is_robot_indexable": true, "report_reasons": null, "author": "davrodpin", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i9tjzy/ssh_port_forwarding_tool_with_resiliency_and_ux/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://davrodpin.github.io/mole/", "subreddit_subscribers": 122318, "created_utc": 1597436655.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_i9tjzy", "before": null}}