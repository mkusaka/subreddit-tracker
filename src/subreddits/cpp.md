# cpp
## [1][C++ Events Affected By Coronavirus](https://www.reddit.com/r/cpp/comments/fidita/c_events_affected_by_coronavirus/)
- url: https://www.reddit.com/r/cpp/comments/fidita/c_events_affected_by_coronavirus/
---
**Don't talk about the coronavirus. r/cpp is not the place to discuss or debate the coronavirus.**

# Purpose

Many C++ conferences, meetups, and even the next committee meeting have been affected by the ongoing public health crisis caused by the coronavirus.

I think it will be helpful to everyone to collect information about C++ events that have been or may be affected by the coronavirus. That includes not only cancellations/postponements, but also events that are planning to move forward but may be impacted in the future

**This is intended to be a living document. Please help by suggesting changes or additions.**

# Lexicon

Term | Meaning
-|-
**Cancelled** | The event will not happen on the planned dates and will not be rescheduled in 2020.
**Postponed** | The event will not happen on the planned dates but may happen later in 2020.
**Virtual** | The event is now virtual.
**No Date Changes Yet** | The event has not announced any changes to the planned dates.

# 2020 Conferences

Event | Location | Original Dates | Status | New Dates
-|-|-|-|-
[QtDay](https://www.qtday.it) | Florence, Italy | 03-13 to 03-14 | [Postponed](https://www.qtday.it) | 11-20 to 11-21
[emBO++](https://www.embo.io) | Bochum, Germany | 03-13 to 03-15 | No Date Changes Yet | 
[ConanDays](https://conandays.conan.io) | Madrid, Spain | 03-19 to 03-20 | [Postponed](https://conandays.conan.io) | Autumn
[ACCU](https://conference.accu.org) | Bristol, UK | 03-25 to 03-28 | [Cancelled](https://conference.accu.org/news/2020/202003121205_accu2020cancelled.html)
[C++ CoreHard](https://conference.corehard.by) | Minsk, Belarus | 04-10 to 04-11 | [Postponed](https://conference.corehard.by) | 10-30 to 10-31
[using std::cpp](https://usingstdcpp.org) | Madrid, Spain | 04-16 | [Postponed](https://eventos.uc3m.es/40350/detail/using-std_cpp-2020.html) | October
[C++ Russia Moscow](https://cppconf-moscow.ru/en) | Moscow, Russia | 04-27 to 04-28 | [Postponed](https://twitter.com/timur_audio/status/1238544415876096000) | June
[C++Now](https://cppnow.org) | Aspen, CO, US | 05-03 to 05-08 | [Cancelled](http://cppnow.org/announcements/2020/03/Canceled) |
[ADC++](https://adcpp.de/20) | Regensburg, Germany | 05-04 to 05-06 | [Postponed](https://adcpp.de/20) | 10-13 to 10-14
[Qt World Summit](https://www.qt.io/qtws20) | Palm Springs, California, US | 05-12 to 05-14 | [Postponed](https://www.qt.io/blog/qt-world-summit-20-postponed-to-october) | 10-20 to 10-22
[Core C++](https://corecpp.org) | Tel Aviv, Israel | 05-25 to 05-27 | [Postponed](https://twitter.com/corecpp/status/1238373483501010944) | Autumn
[Total Chaos](https://www.chaosgroup.com/total-chaos) | Sofia, Bulgaria | 05-29 to 05-31 | [Cancelled](https://www.chaosgroup.com/total-chaos) |
[Cpp On Sea](https://cpponsea.uk) | Folkestone, UK | 06-07 to 06-10 | [Postponed](https://cpponsea.uk/news/2020-conference-rethink.html) |
[Italian C++ Conference](https://www.italiancpp.org/event/itcppcon20) | Rome, Italy | 06-13 | No Date Changes Yet |
[CPPP](https://cppp.fr) | Paris, France | 06-22 to 06-23 | [Cancelled](https://cppp.fr/blog/canceled) |
[CppCon](https://cppcon.org) | Aurora, CO, US | 09-13 to 09-18 | No Date Changes Yet |
[Meeting C++](https://meetingcpp.com) | Berlin, Germany | 11-12 to 11-14 | No Date Changes Yet |

# 2020 ISO C++ Committee Meetings

Location | Original Dates | Status | New Dates
-|-|-|-
[Varna, Bulgaria](https://wg21.link/N4837) | 06-01 to 06-06 | [Cancelled](https://herbsutter.com/2020/03/13/the-varna-iso-c-meeting-is-postponed) | 
[JFK Airport, New York](https://wg21.link/N4848) |  11-09 to 11-14 | No Date Changes Yet |

# 2020 C++ User Groups

Group | Location | Status | Until
-|-|-|-
[ACCU Bay Area](https://meetup.com/ACCU-Bay-Area) | San Francisco Bay Area, California, US | [Postponed](https://meetup.com/ACCU-Bay-Area) | Indefinitely
[PDXCPP](https://www.meetup.com/pdxcpp) | Portland, Oregon, US | [Postponed](https://www.meetup.com/pdxcpp/events/xgjlqrybcfbwb/) | Indefinitely
[Denver Metro C++ Meetup](https://www.meetup.com/North-Denver-Metro-C-Meetup) | Denver, Colorado, US | [Postponed](https://www.meetup.com/North-Denver-Metro-C-Meetup/) | Indefinitely
[C++TO](https://www.meetup.com/CPPTORONTO/) | Toronto, Ontario, Canada | [Postponed](https://www.meetup.com/CPPTORONTO/) | Indefinitely
[C++ MontrÃ©al](https://www.meetup.com/CppMtl/) | MontrÃ©al, QuÃ©bec, Canada | [Virtual](https://www.meetup.com/CppMtl/events/269770766/) | Indefinitely
[Bulgaria C++ Meetup](https://dev.bg/groups/c-c-plus-plus/) | Sofia, Bulgaria | [Virtual](https://dev.bg/groups/c-c-plus-plus/) | Indefinitely
## [2][C++ Jobs - Q2 2020](https://www.reddit.com/r/cpp/comments/ft77lv/c_jobs_q2_2020/)
- url: https://www.reddit.com/r/cpp/comments/ft77lv/c_jobs_q2_2020/
---
Rules For Individuals
---------------------

* **Don't** create top-level comments - those are for employers.
* Feel free to reply to top-level comments with **on-topic** questions.
* I will create one top-level comment for **meta** discussion.
* I will create another top-level comment for **individuals looking for work**.

Rules For Employers
---------------------

* You must be hiring **directly**. No third-party recruiters.
* **One** top-level comment per employer. If you have multiple job openings, that's great, but please consolidate their descriptions or mention them in replies to your own top-level comment.
* **Don't** use URL shorteners. [reddiquette](https://www.reddithelp.com/en/categories/reddit-101/reddit-basics/reddiquette) forbids them because they're opaque to the spam filter.
* Templates are awesome. Please **use** the following template. As the "formatting help" says, use \*\*two stars\*\* to **bold text**. Use empty lines to separate sections.
* **Proofread** your comment after posting it, and edit any formatting mistakes.
* ðŸš¨ **Updated Remote section.** ðŸš¨ You must follow its guidance, or your post will be removed.

---

\*\*Company:\*\* [Company name; also, use the "formatting help" to make it a link to your company's website, or a specific careers page if you have one.]

&amp;nbsp;

\*\*Type:\*\* [Full time, part time, internship, contract, etc.]

&amp;nbsp;

\*\*Description:\*\* [What does your company do, and what are you hiring C++ devs for? How much experience are you looking for, and what seniority levels are you hiring for? The more details you provide, the better.]

&amp;nbsp;

\*\*Location:\*\* [Where's your office - or if you're hiring at multiple offices, list them. If your workplace language isn't English, please specify it.]

&amp;nbsp;

\*\*Remote:\*\* [ðŸš¨ **Updated!** ðŸš¨ Is this permanently a remote job, or is this remote (including new employee orientation) for the duration of the crisis? If so, do you require employees to live in certain areas or time zones? If you require programmers to be physically present, please explain either why you're essential infrastructure (e.g. programmers must physically interact with manufacturing/medical equipment) or why you're recklessly foolish.]

&amp;nbsp;

\*\*Visa Sponsorship:\*\* [Does your company sponsor visas?]

&amp;nbsp;

\*\*Technologies:\*\* [Required: do you mainly use C++98/03, C++11, C++14, C++17, or the C++20 working draft? Optional: do you use Linux/Mac/Windows, are there languages you use in addition to C++, are there technologies like OpenGL or libraries like Boost that you need/want/like experience with, etc.]

&amp;nbsp;

\*\*Contact:\*\* [How do you want to be contacted? Email, reddit PM, telepathy, gravitational waves?]

---

Previous Post
--------------

* [C++ Jobs - Q1 2020](https://www.reddit.com/r/cpp/comments/eiila4/c_jobs_q1_2020/)
## [3][Making a STL-compatible hash map from scratch](https://www.reddit.com/r/cpp/comments/fwgco5/making_a_stlcompatible_hash_map_from_scratch/)
- url: https://jguegant.github.io//jguegant.github.io/blogs/tech/dense-hash-map.html
---

## [4][Approximate string match library in c++?](https://www.reddit.com/r/cpp/comments/fwhuk0/approximate_string_match_library_in_c/)
- url: https://www.reddit.com/r/cpp/comments/fwhuk0/approximate_string_match_library_in_c/
---
Hi, I was curious if there is already around a modern library for approximate string matching in c++

The use case would be catching potential typos in string input parameters and providing the user with an error message with the closest matching suggestion coming from a list of already existing strings.

(if not we might try to roll our own.

&amp;#x200B;

Thanks!
## [5][rocket - Fast C++ Observer Pattern](https://www.reddit.com/r/cpp/comments/fw7tpm/rocket_fast_c_observer_pattern/)
- url: https://www.reddit.com/r/cpp/comments/fw7tpm/rocket_fast_c_observer_pattern/
---
Rocket is a single-header implementation of a signal/slots library for C++.

## Why another one?

The library was developed because existing solutions were too inflexible, too slow, or came as a part of a larger dependency (for example boost::signals and boost::signals2).

## Design goals

1. Efficiency. The library takes special care to not use cache unfriendly code (such as calling virtual methods) unless absolutely necessary.
2. Low memory footprint (does not allocate during signal emission).
3. Modern C++. No bloat from overloading 50 template specializations for each function.
4. Single header file implementation.
5. No dependencies.

The API was heavily inspired by boost::signals2. If you are already familiar with boost::signals2, switching to rocket will be a no brainer.

## What makes rocket unique?

1. All classes in this library are single threaded\*. No efficiency loss due to locks or atomics.
2. Policy based design. Specify at declaration time and invocation time of the signal how _you_ want the call results to be returned.
3. The signals are reentrant. This property is a must have for any event processing library because it must be possible to recursively emit signals, or disconnect slots from within a signal handler.
4. Support for smart `scoped_connection`'s and `scoped_connection_container`'s.
5. Support for automatic lifetime tracking of observers via `rocket::trackable`.
6. Allows slots to get an instance to the `current_connection` object (see example 6).
7. Allows slots to preemtively abort the emission of the signal (see example 7).


\*) This does not mean that you cannot use different signals in multiple different threads. The library has no global state and thus two different signals are always thread safe as long as you don't call one of them from multiple threads at the same time.

## Performance

Because the main focus of this library was to provide an efficient single threaded implementation, `rocket::signal` has about the same overhead as an iteration through an `std::list&lt;std::function&lt;T&gt;&gt;`.

Here are some performance benchmarks between boost::signals2 and rocket for registering 10 slots to each signal type and emitting each one 1000 times.

| Library         | Avg. execution time |
| --------------  | -------------------:|
| boost::signals2 |          810.389 Âµs |
| rocket::signal  |           98.155 Âµs |

## Github Link

https://github.com/tripleslash/rocket
## [6][{fmt} 6.2 released with improved error reporting, smaller library size, better compatibility with std::format and more](https://www.reddit.com/r/cpp/comments/fvyixl/fmt_62_released_with_improved_error_reporting/)
- url: https://github.com/fmtlib/fmt/releases/tag/6.2.0
---

## [7][Things I learned about C++ exceptions from Boost](https://www.reddit.com/r/cpp/comments/fw882x/things_i_learned_about_c_exceptions_from_boost/)
- url: https://github.com/HDembinski/essays/blob/master/exceptions.md
---

## [8][iris: Lightweight Component Model and Messaging Framework based on Ã˜MQ](https://www.reddit.com/r/cpp/comments/fwk63r/iris_lightweight_component_model_and_messaging/)
- url: https://github.com/p-ranav/iris
---

## [9][Optimizing okon's B-tree file creation. Going down from 477.2s to 342.2s. I even learned SIMD a little bit \o/](https://www.reddit.com/r/cpp/comments/fw67d3/optimizing_okons_btree_file_creation_going_down/)
- url: http://stryku.pl/poetry/okon_preparing_optimizations.html
---

## [10][corobatch: using coroutines to batch operations with no effort](https://www.reddit.com/r/cpp/comments/fw1068/corobatch_using_coroutines_to_batch_operations/)
- url: https://www.reddit.com/r/cpp/comments/fw1068/corobatch_using_coroutines_to_batch_operations/
---
Often performing operations in batch is more efficient than doing them one at a time. 
Typical examples could be most kinds of I/O, or vectorized instructions.

Unfortunately, doing operations on groups of items at the same time can be much less readable than doing them one element at a time.

For example, the following example 

    std::vector&lt;Bar4&gt; res;
    for(const Bar1&amp; bar1 : bar1s) {
        Bar3 bar3 = foo({bar1.bar2}).at(0); // takes a vector and returns a vector
        res.push_back(bar3.bar4);
    }

would be

    std::vector&lt;Bar2&gt; bar2s;
    std::transform(bar1s.begin(), bar1s.end(), std::back_inserter(bar2s), [](const Bar1&amp; bar1) { return bar1.bar2; });
    std::vector&lt;Bar3&gt; bar3s = foo(bar2s);
    std::vector&lt;Bar4&gt; ret;
    std::transform(bar3s.begin(), bar3s.end(), std::back_inserter(ret), [](const Bar3&amp; bar3) { return bar3.bar4; });

In the second version it's much harder to understand what is going on, but if `foo` benefits from being executed with batches of data the second version might be significantly faster.

---

While reading more on coroutines, I though that they could be used to take control of the control flow of the code and manage to execute batch operations without having to rewrite the main logic completely.

This resulted in the creation of [corobatch](https://github.com/MakersF/corobatch).


With `corobatch`, the code above could we written like this

    [](const Bar1&amp; bar1, auto&amp;&amp; foo) -&gt; corobatch::task&lt;Bar4&gt; {
        Bar3 bar3 = co_await foo(bar1.bar2);
        co_return bar3.bar4;
    }
    // Plus some boilerplate


The idea is that when a task needs the result of a batch operation, its parameter gets saved and it gets suspended, and another task is started. This goes on until the library gathered enough parameters, at which point it performs the batch operation, and restarts all the tasks waiting for the result.

---

In the repository at https://github.com/MakersF/corobatch you can find a complete example with explanation in the readme, plus an example of integrating the library with `boost::asio` in a fully asynchronous way.


While this is a proof of concept, I think the idea is fairly cool, and it could be applied to different use cases:

* I/O
* allocating memory in big chucks and splitting the buffer across several tasks
* loading data in the GPU and performing batch computation
* performing math with SIMD


What do you think of the idea?


Due to my background I'm most familiar with batch operation for network related operations, but I think this is applicable to several fields.
Do you have experience in some field I don't know about which usually relies heavily on performing batch operations?

For any suggestion or criticism feel free to leave a comment here or open an issue in github.

Thanks!

Note: you need `clang-11` and `libc++-11` to use the library, and you need to download `boost` and `libnop` to run the tests. At the start of the `CMakeLists.txt` file there are the instructions on how to download the dependencies, and you can find the instructions for installing clang-11 at https://apt.llvm.org/.
## [11][GCC always assumes aligned pointer accesses](https://www.reddit.com/r/cpp/comments/fw1jkx/gcc_always_assumes_aligned_pointer_accesses/)
- url: https://trust-in-soft.com/blog/2020/04/06/gcc-always-assumes-aligned-pointers/
---

## [12][Continuable 4.0 released - zero cost futures now with asio integration and better exception control](https://www.reddit.com/r/cpp/comments/fw1dhx/continuable_40_released_zero_cost_futures_now/)
- url: https://github.com/Naios/continuable
---

