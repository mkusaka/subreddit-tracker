# cpp
## [1][C++ Events Affected By Coronavirus](https://www.reddit.com/r/cpp/comments/fidita/c_events_affected_by_coronavirus/)
- url: https://www.reddit.com/r/cpp/comments/fidita/c_events_affected_by_coronavirus/
---
**Don't talk about the coronavirus. r/cpp is not the place to discuss or debate the coronavirus.**

# Purpose

Many C++ conferences, meetups, and even the next committee meeting have been affected by the ongoing public health crisis caused by the coronavirus.

I think it will be helpful to everyone to collect information about C++ events that have been or may be affected by the coronavirus. That includes not only cancellations/postponements, but also events that are planning to move forward but may be impacted in the future

**This is intended to be a living document. Please help by suggesting changes or additions.**

**Last Updated: 2020-05-11 - Email, Tweet or Slack Bryce to request updates.**

# Lexicon

Term | Meaning
-|-
**Cancelled** | The event will not happen on the planned dates and will not be rescheduled in 2020.
**Postponed** | The event will not happen on the planned dates but may happen later in 2020.
**Virtual** | The event is now virtual.
**No Date Changes Yet** | The event has not announced any changes to the planned dates.

# 2020 Conferences

Event | Location | Original Dates | Status | Current Dates
-|-|-|-|-
[emBO++](https://www.embo.io) | Bochum, Germany | 03-13 to 03-15 | No Date Changes Yet | 03-13 to 03-15
[ACCU](https://conference.accu.org) | Bristol, UK | 03-25 to 03-28 | [Cancelled](https://conference.accu.org/news/2020/202003121205_accu2020cancelled.html) | 03-25 to 03-28
[Pure Virtual C++](https://visualstudio.microsoft.com/pure-virtual-cpp-event) | Virtual | 04-30 | [Virtual](https://visualstudio.microsoft.com/pure-virtual-cpp-event)
[C++Now](https://cppnow.org) | Aspen, CO, US | 05-03 to 05-08 | [Cancelled](http://cppnow.org/announcements/2020/03/Canceled) | 05-03 to 05-08
[Total Chaos](https://www.chaosgroup.com/total-chaos) | Sofia, Bulgaria | 05-29 to 05-31 | [Cancelled](https://www.chaosgroup.com/total-chaos) | 05-29 to 05-31
[Italian C++ Conference](https://www.italiancpp.org/event/itcppcon20) | Rome, Italy | 06-13 | [Virtual](https://www.italiancpp.org/event/itcppcon20/) | 06-13
[CPPP](https://cppp.fr) | Paris, France | 06-22 to 06-23 | [Cancelled](https://cppp.fr/blog/canceled) | 06-22 to 06-23
[C++ Russia Moscow](https://cppconf-moscow.ru/en) | Moscow, Russia | 04-27 to 04-28 | [Virtual](https://cppconf-moscow.ru/en/) | 06-29 to 07-02
[Cpp On Sea](https://cpponsea.uk) | Folkestone, UK | 06-07 to 06-10 | [Virtual](https://cpponsea.uk/news/cpp-on-sea-online.html) | 07-15 to 07-17
[CppCon](https://cppcon.org) | Aurora, CO, US | 09-13 to 09-18 | [No Date Changes Yet](https://cppcon.org/cppcon-2020-call-for-submissions/) | 09-13 to 09-17
[ADC++](https://adcpp.de/20) | Regensburg, Germany | 05-04 to 05-06 | [Postponed](https://adcpp.de/20) | 10-13 to 10-14
[Qt World Summit](https://www.qt.io/qtws20) | Palm Springs, California, US | 05-12 to 05-14 | [Postponed](https://www.qt.io/blog/qt-world-summit-20-postponed-to-october) | 10-20 to 10-22
[C++ CoreHard](https://conference.corehard.by) | Minsk, Belarus | 04-10 to 04-11 | [Postponed](https://conference.corehard.by) | 10-30 to 10-31
[using std::cpp](https://usingstdcpp.org) | Madrid, Spain | 04-16 | [Postponed](https://eventos.uc3m.es/40350/detail/using-std_cpp-2020.html) | 10
[Core C++](https://corecpp.org) | Tel Aviv, Israel | 05-25 to 05-27 | [Postponed](https://twitter.com/corecpp/status/1238373483501010944) | Autumn
[ConanDays](https://conandays.conan.io) | Madrid, Spain | 03-19 to 03-20 | [Postponed](https://conandays.conan.io) | Autumn
[Meeting C++](https://meetingcpp.com) | Berlin, Germany | 11-12 to 11-14 | No Date Changes Yet | 11-12 to 11-14
[code::dive](https://codedive.pl/) | Wrocław, Poland | 11-18 | No Date Changes Yet | 11-18
[QtDay](https://www.qtday.it) | Florence, Italy | 03-13 to 03-14 | [Postponed](https://www.qtday.it) | 11-20 to 11-21

# 2020 ISO C++ Committee Meetings

Location | Original Dates | Status | New Dates
-|-|-|-
[Varna, Bulgaria](https://wg21.link/N4837) | 06-01 to 06-06 | [Cancelled](https://herbsutter.com/2020/03/13/the-varna-iso-c-meeting-is-postponed) | 
[JFK Airport, New York](https://wg21.link/N4848) |  11-09 to 11-14 | [Cancelled](https://herbsutter.com/2020/05/20/the-new-york-iso-c-meeting-is-postponed) |

# 2020 C++ User Groups

Group | Location | Status | Until
-|-|-|-
[ACCU Bay Area](https://meetup.com/ACCU-Bay-Area) | San Francisco Bay Area, California, US | [Virtual](https://meetup.com/ACCU-Bay-Area) | Indefinitely
[PDXCPP](https://www.meetup.com/pdxcpp) | Portland, Oregon, US | [Postponed](https://www.meetup.com/pdxcpp/events/xgjlqrybcfbwb/) | Indefinitely
[Denver Metro C++ Meetup](https://www.meetup.com/North-Denver-Metro-C-Meetup) | Denver, Colorado, US | [Postponed](https://www.meetup.com/North-Denver-Metro-C-Meetup/) | Indefinitely
[C++TO](https://www.meetup.com/CPPTORONTO/) | Toronto, Ontario, Canada | [Postponed](https://www.meetup.com/CPPTORONTO/) | Indefinitely
[C++ Montréal](https://www.meetup.com/CppMtl/) | Montréal, Québec, Canada | [Virtual](https://www.meetup.com/CppMtl/events/269770766/) | Indefinitely
[Bulgaria C++ Meetup](https://dev.bg/groups/c-c-plus-plus/) | Sofia, Bulgaria | [Virtual](https://dev.bg/groups/c-c-plus-plus/) | Indefinitely
[C++ London](https://www.meetup.com/CppLondon) | London, UK | [Virtual](https://www.meetup.com/CppLondon) | Indefinitely
[Core C++](https://www.meetup.com/CoreCpp/) | Israel | [Virtual](https://www.meetup.com/CoreCpp/) | Indefinitely
## [2][C++ Jobs - Q3 2020](https://www.reddit.com/r/cpp/comments/hjnaf2/c_jobs_q3_2020/)
- url: https://www.reddit.com/r/cpp/comments/hjnaf2/c_jobs_q3_2020/
---
Rules For Individuals
---------------------

* **Don't** create top-level comments - those are for employers.
* Feel free to reply to top-level comments with **on-topic** questions.
* I will create top-level comments for **meta** discussion and **individuals looking for work**.

Rules For Employers
---------------------

* You must be hiring **directly**. No third-party recruiters.
* **One** top-level comment per employer. If you have multiple job openings, that's great, but please consolidate their descriptions or mention them in replies to your own top-level comment.
* **Don't** use URL shorteners. [reddiquette](https://www.reddithelp.com/en/categories/reddit-101/reddit-basics/reddiquette) forbids them because they're opaque to the spam filter.
* Templates are awesome. Please **use** the following template. As the "formatting help" says, use \*\*two stars\*\* to **bold text**. Use empty lines to separate sections.
* **Proofread** your comment after posting it, and edit any formatting mistakes.

---

\*\*Company:\*\* [Company name; also, use the "formatting help" to make it a link to your company's website, or a specific careers page if you have one.]

&amp;nbsp;

\*\*Type:\*\* [Full time, part time, internship, contract, etc.]

&amp;nbsp;

\*\*Description:\*\* [What does your company do, and what are you hiring C++ devs for? How much experience are you looking for, and what seniority levels are you hiring for? The more details you provide, the better.]

&amp;nbsp;

\*\*Location:\*\* [Where's your office - or if you're hiring at multiple offices, list them. If your workplace language isn't English, please specify it.]

&amp;nbsp;

\*\*Remote:\*\* [Do you offer the option of working remotely (permanently, or for the duration of the pandemic)? If so, do you require employees to live in certain areas or time zones?]

&amp;nbsp;

\*\*Visa Sponsorship:\*\* [Does your company sponsor visas?]

&amp;nbsp;

\*\*Technologies:\*\* [Required: do you mainly use C++98/03, C++11, C++14, C++17, or C++20? Optional: do you use Linux/Mac/Windows, are there languages you use in addition to C++, are there technologies like OpenGL or libraries like Boost that you need/want/like experience with, etc.]

&amp;nbsp;

\*\*Contact:\*\* [How do you want to be contacted? Email, reddit PM, telepathy, gravitational waves?]

---

Previous Post
--------------

* [C++ Jobs - Q2 2020](https://www.reddit.com/r/cpp/comments/ft77lv/c_jobs_q2_2020/)
## [3][Ask Me Anything with Bjarne Stroustrup, hosted by John Regehr (PLDI 2020)](https://www.reddit.com/r/cpp/comments/hqdnx5/ask_me_anything_with_bjarne_stroustrup_hosted_by/)
- url: https://www.youtube.com/watch?v=Bycec3UQxOc
---

## [4][Patch for GCC 10 to implement P0222](https://www.reddit.com/r/cpp/comments/hqbqjd/patch_for_gcc_10_to_implement_p0222/)
- url: https://www.reddit.com/r/cpp/comments/hqbqjd/patch_for_gcc_10_to_implement_p0222/
---
P0222: [https://github.com/mwoehlke/cpp-proposals/blob/master/p0222r0-anonymous-struct-return.rst](https://github.com/mwoehlke/cpp-proposals/blob/master/p0222r0-anonymous-struct-return.rst)

GCC: [https://gcc.gnu.org/git.html](https://gcc.gnu.org/git.html)

This patch lifts the restriction described in P0222 + it is possible to define types in function arguments, so it's possible to write code like this:

    struct { int x; }
    g(const struct { int y; } &amp;args) {
    	return { .x = args.y };
    }
    
    int main() {
    	return g({ .y = 11 }).x;
    }

This code generates the following assembly with `-O3`:

    movl    $11, %eax
    ret

Patch:

    diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
    index 45ad2c05288..b1e0b871777 100644
    --- a/gcc/cp/parser.c
    +++ b/gcc/cp/parser.c
    @@ -3115,6 +3115,7 @@ cp_parser_check_for_definition_in_return_type (cp_declarator *declarator,
       /* [dcl.fct] forbids type definitions in return types.
          Unfortunately, it's not easy to know whether or not we are
          processing a return type until after the fact.  */
    +  /*
       while (declarator
             &amp;&amp; (declarator-&gt;kind == cdk_pointer
                 || declarator-&gt;kind == cdk_reference
    @@ -3129,6 +3130,7 @@ cp_parser_check_for_definition_in_return_type (cp_declarator *declarator,
                  "(perhaps a semicolon is missing after the definition of %qT)",
                  type);
         }
    +    */
     }
     
     /* A type-specifier (TYPE) has been parsed which cannot be followed by
    @@ -22764,8 +22766,10 @@ cp_parser_parameter_declaration (cp_parser *parser,
     
       /* Type definitions may not appear in parameter types.  */
       saved_message = parser-&gt;type_definition_forbidden_message;
    +  /*
       parser-&gt;type_definition_forbidden_message
         = G_("types may not be defined in parameter types");
    +  */
     
       int template_parm_idx = (function_being_declared_is_template_p (parser) ?
                               TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS

Patch is trivial and even if it does not apply, it should be possible to replicate it on other versions of GCC.

IMO it is a bit of overkill because it allows to write code like this:

    struct {
    	int x = 0;
    
    	operator int () const {
    		// this executes when struct is converted to int but not before that
    		std::cout &lt;&lt; x &lt;&lt; std::endl;
    		return 0;
    	}
    
    	struct tors {
    		tors() { std::cout &lt;&lt; "got ctor" &lt;&lt; std::endl; }
    		~tors() { std::cout &lt;&lt; "got dtor?" &lt;&lt; std::endl; }
    	} tors = {};
    }
    f(const struct { int y; } &amp;args) {
    	return { .x = args.y };
    }

This isn't exactly footgun, more like a tactical nuke, looks funny, but probably under export restrictions. But this is very powerful and could be a solid basis for more refined language features i think. However if you think about it, this is nothing that can not be implemented with non anonymous structures. For designated initializers `-std=c++2a` is need to be set of course.

Any ideas?
## [5][Best Practices for A C Programmer](https://www.reddit.com/r/cpp/comments/hpz198/best_practices_for_a_c_programmer/)
- url: https://www.reddit.com/r/cpp/comments/hpz198/best_practices_for_a_c_programmer/
---
Hi all,

Long time C programmer here, primarily working in the embedded industry (particularly involving safety-critical code). I've been a lurker on this sub for a while but I'm hoping to ask some questions regarding best practices. I've been trying to start using c++ on a lot of my work - particularly taking advantage of some of the code-reuse and power of C++ (particularly constexpr, some loose template programming, stronger type checking, RAII etc).

I would consider myself maybe an 8/10 C programmer but I would conservatively maybe rate myself as 3/10 in C++ (with 1/10 meaning the absolute minmum ability to write, google syntax errata, diagnose, and debug a program). Perhaps I should preface the post that I am more than aware that C is by no means a subset of C++ and there are many language constructs permitted in one that are not in the other.

In any case, I was hoping to get a few answers regarding best practices for c++. Keep in mind that the typical target device I work with does not have a heap of any sort and so a lot of the features that constitute "modern" C++ (non-initialization use of dynamic memory, STL meta-programming, hash-maps, lambdas (as I currently understand them) are a big no-no in terms of passing safety review.

### **When do I overload operators inside a class as opposed to outisde?** ###

... And what are the arguments for/against each paradigm? See below:

    /* Overload example 1 (overloaded inside class) */
    class myclass
    {
    private:
        unsigned int a;
        unsigned int b;

    public:
        myclass(void);

        unsigned int get_a(void) const;

        bool operator==(const myclass &amp;rhs);
    };

    bool myclass::operator==(const myclass &amp;rhs)
    {
        if (this == &amp;rhs)
        {
            return true;
        }
        else
        {
            if (this-&gt;a == rhs.a &amp;&amp; this-&gt;b == rhs.b)
            {
                return true;
            }
        }
        return false;
    }

As opposed to this:
    
    /* Overload example 2 (overloaded outside of class) */
    class CD
    {
        private:
            unsigned int c;
            unsigned int d;
        public:
            CD(unsigned int _c, unsigned int _d) : d(_d), c(_c) {}; /* CTOR */
            unsigned int get_c(void) const; /* trival getters */
            unsigned int get_d(void) const; /* trival getters */
    };


    /* In this implementation, If I don't make the getters (get_c, get_d) constant, 
     * it won't  compile despite their access specifiers being public. 
     * 
     * It seems like the const keyword in C++ really should be interpretted as 
     * "read-only AND no side effects" rather than just read only as in C. 
     * But my current understanding may just be flawed...
     * 
     * My confusion is as follows: The function args are constant references 
     * so why do I have to promise that the function methods have no side-effects on
     * the private object members? Is this something specific to the == operator?
     */
    bool operator==(const CD &amp; lhs, const CD &amp; rhs)
    {   
        if(&amp;lhs == &amp;rhs)
            return true;
        else if((lhs.get_c() == rhs.get_c()) &amp;&amp; (lhs.get_d() == rhs.get_d()))
            return true;
        return false;
    }


When should I use the example 1 style over the example 2 style? What are the pros and cons of 1 vs 2? 

### **What's the deal with const member functions?** ###

This is more of a subtle confusion but it seems like in C++ the const keyword means different things base on the context in which it is used. I'm trying to develop a relatively nuanced understanding of what's happening under the hood and I most certainly have misunderstood many language features, especially because C++ has likely changed greatly in the last ~6-8 years.

### **When should I use enum classes versus plain old enum?** ###

To be honest I'm not entirely certain I fully understand the implications of using enum versus enum class in C++. 

This is made more confusing by the fact that there are subtle differences between the way C and C++ treat or permit various language constructs (const, enum, typedef, struct, void\*, pointer aliasing, type puning, tentative declarations). 

In C, enums decay to integer values at compile time. But in C++, the way I currently understand it, enums are their own type. Thus, in C, the following code would be valid, but a C++ compiler would generate a warning (or an error, haven't actually tested it)
    

    /* Example 3: (enums : Valid in C, invalid in C++ ) */
    enum COLOR
    {
        RED,
        BLUE,
        GREY
    };

    enum PET
    {
        CAT,
        DOG,
        FROG
    };

    /* This is compatible with a C-style enum conception but not C++ */
    enum SHAPE
    {
        BALL = RED, /* In C, these work because int = int is valid */
        CUBE = DOG, 
    };

If my understanding is indeed the case, do enums have an implicit namespace (language construct, not the C++ keyword) as in C? As an add-on to that, in C++, you can also declare enums as a sort of inherited type (below). What am I supposed to make of this? Should I just be using it to reduce code size when possible (similar to gcc option -fuse-packed-enums)? Since most processors are word based, would it be more performant to use the processor's word type than the syntax specified above?
    
    /* Example 4: (Purely C++ style enums, use of enum class/ enum struct) */
    /* C++ permits forward enum declaration with type specified */
    enum FRUIT : int;
    enum VEGGIE : short;

    enum FRUIT /* As I understand it, these are ints */
    {
        APPLE,
        ORANGE,
    };

    enum VEGGIE /* As I understand it, these are shorts */
    {
        CARROT,
        TURNIP,
    };

Complicating things even further, I've also seen the following syntax:

    /* What the heck is an enum class anyway? When should I use them */
    enum class THING
    {
        THING1,
        THING2,
        THING3
    };

    /* And if classes and structs are interchangable (minus assumptions
     * about default access specifiers), what does that mean for
     * the following definition?
     */
    enum struct FOO /* Is this even valid syntax? */
    {
        FOO1,
        FOO2,
        FOO3
    };


Given that enumerated types greatly improve code readability, I've been trying to wrap my head around all this. When should I be using the various language constructs? Are there any pitfalls in a given method?

### **When to use POD structs (a-la C style) versus a class implementation?** ###

If I had to take a stab at answering this question, my intuition would be to use POD structs for passing aggregate types (as in function arguments) and using classes for interface abstractions / object abstractions as in the example below:

    struct aggregate
    {
        unsigned int related_stuff1;
        unsigned int related_stuff2;
        char         name_of_the_related_stuff[20];
    };


    class abstraction
    {
    private:
        unsigned int private_member1;
        unsigned int private_member2;

    protected:
        unsigned int stuff_for_child_classes;

    public:
        /* big 3 */
        abstraction(void);
        abstraction(const abstraction &amp;other);
        ~abstraction(void);

        /* COPY semantic ( I have a better grasp on this abstraction than MOVE) */
        abstraction &amp;operator=(const abstraction &amp;rhs);

        /* MOVE semantic (subtle semantics of which I don't full grasp yet) */
        abstraction &amp;operator=(abstraction &amp;&amp;rhs);

        /*
         * I've seen implentations of this that use a copy + swap design pattern
         * but that relies on std::move and I realllllly don't get what is
         * happening under the hood in std::move
         */
        abstraction &amp;operator=(abstraction rhs);

        void do_some_stuff(void); /* member function */
    };


Is there an accepted best practice for thsi or is it entirely preference? Are there arguments for only using classes? What about vtables (where byte-wise alignment such as device register overlays and I have to guarantee placement of precise members)

### **Is there a best practice for integrating C code?** ###

Typically (and up to this point), I've just done the following:
     
    /* Example 5 : Linking a C library */
    /* Disable name-mangling, and then give the C++ linker / 
     * toolchain the compiled
     * binaries 
     */
    #ifdef __cplusplus
    extern "C" {
    #endif /* C linkage */

    #include "device_driver_header_or_a_c_library.h" 

    #ifdef __cplusplus
    }
    #endif /* C linkage */

    /* C++ code goes here */

As far as I know, this is the only way to prevent the C++ compiler from generating different object symbols than those in the C header file. Again, this may just be ignorance of C++ standards on my part.

### **What is the proper way to selectively incorporate RTTI without code size bloat?** ###

Is there even a way? I'm relatively fluent in CMake but I guess the underlying question is if binaries that incorporate RTTI are compatible with those that dont (and the pitfalls that may ensue when mixing the two).

### **What about compile time string formatting?** ###

One of my biggest gripes about C (particularly regarding string manipulation) frequently (especially on embedded targets) variadic arguments get handled at runtime. This makes string manipulation via the C standard library (printf-style format strings) uncomputable at compile time in C.

This is sadly the case even when the ranges and values of paramers and formatting outputs is entirely known beforehand. C++ template programming seems to be a big thing in "modern" C++ and I've seen a few projects on this sub that use the turing-completeness of the template system to do some crazy things at compile time. Is there a way to bypass this ABI limitation using C++ features like constexpr, templates, and lambdas? My (somewhat pessimistic) suspicion is that since the generated assembly must be ABI-compliant this isn't possible. Is there a way around this? What about the std::format stuff I've been seeing on this sub periodically?

### **Is there a standard practice for namespaces and when to start incorporating them?** ###

Is it from the start? Is it when the boundaries of a module become clearly defined? Or is it just personal preference / based on project scale and modularity?

If I had to make a guess it would be at the point that you get a "build group" for a project (group of source files that should be compiled together) as that would loosely define the boundaries of a series of abstractions APIs you may provide to other parts of a project.

--EDIT-- markdown formatting
## [6][CppCon 2020 will be held entirely online :(](https://www.reddit.com/r/cpp/comments/hqf0tc/cppcon_2020_will_be_held_entirely_online/)
- url: https://cppcon.org/going-virtual/
---

## [7][5 Curious C++ Lambda Examples: Recursion, constexpr, Containers and More](https://www.reddit.com/r/cpp/comments/hqc1a4/5_curious_c_lambda_examples_recursion_constexpr/)
- url: https://www.bfilipek.com/2020/07/lambdas5ex.html
---

## [8][How Cheerp supports 64-bit integers in both JavaScript and WebAssembly](https://www.reddit.com/r/cpp/comments/hqf9fp/how_cheerp_supports_64bit_integers_in_both/)
- url: https://medium.com/leaningtech/how-cheerp-supports-64-bit-integers-in-both-javascript-and-webassembly-79485761615a
---

## [9][Optimize function-level computation which is not used in some execution paths](https://www.reddit.com/r/cpp/comments/hqbjkm/optimize_functionlevel_computation_which_is_not/)
- url: https://www.reddit.com/r/cpp/comments/hqbjkm/optimize_functionlevel_computation_which_is_not/
---
Hello cpp!

(This is related to but does not assume [Is any optimizer able to cache same calls?](https://www.reddit.com/r/cpp/comments/horbq2/is_any_optimizer_able_to_cache_same_calls/))

I have following code:

    [[gnu::pure]] bool compute(const uint64_t n) noexcept;
    
    int f(const bool flag1, const bool flag2, const uint64_t n)
    {
        const auto c = compute(n);
        if (flag1 &amp;&amp; c)
            return 1;
        return flag2 || c ? 3 : 2;
    }

It's clear that when `flag1=false` and `flag2=true` value of `c` is unused.

So, I am wondering how to make compiler to unroll if-statements for me, to compute `c` only when required? e.g. to have asm equivalent to the following code:

    int f(const bool flag1, const bool flag2, const uint64_t n)
    {
        if (flag1)
        {
            if (compute(n))
                return 1;
            return flag2 ? 3 : 2;
        }
        else
        {
            return flag2 || compute(n) ? 3 : 2;
        }
    }

Code of `compute` doesn't matter (I just need something to model heavy computation). Here it is for reference. It's *available* to compiler:

    [[gnu::pure]] bool compute(const uint64_t n) noexcept
    {
        std::vector&lt;uint64_t&gt; primes;
        for (uint64_t i = 2; n / i &gt;= i; ++i)
        {
            if (std::none_of(std::begin(primes), std::end(primes),
                             [i](const auto p) { return i % p == 0; }))
                primes.push_back(i);
        }
        return primes.size() % 2 == 0;
    }
## [10][I'm new to c++ and need guidance](https://www.reddit.com/r/cpp/comments/hqdwte/im_new_to_c_and_need_guidance/)
- url: https://www.reddit.com/r/cpp/comments/hqdwte/im_new_to_c_and_need_guidance/
---
Hello everyone! I'm new to programming and have been learning from sololearn. I will list down what i have learned so far. Could you please guide what to learn next? .
I've learned:
Loops, 
Vectors, 
Arrays, 
Variables, 
Class and objects, 
Templates, function temp, class templates, 
Polymorphism, 
Inheritance, 
Text files (Write and read files), 
I have created student database, calculator and very basic projects.
## [11][Version 0.55.0 of the Meson build system is out, here's what's new](https://www.reddit.com/r/cpp/comments/hpw9xd/version_0550_of_the_meson_build_system_is_out/)
- url: https://mesonbuild.com/Release-notes-for-0-55-0.html
---

## [12][What is the std::swap two-step?](https://www.reddit.com/r/cpp/comments/hpqbdz/what_is_the_stdswap_twostep/)
- url: https://quuxplusone.github.io/blog/2020/07/11/the-std-swap-two-step/
---

