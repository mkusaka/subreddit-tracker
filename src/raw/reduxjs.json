{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "I'm using Redux with my React Hooks simple counter project. It worked without any bugs or problems when the only global state was a simple integer with +/- buttons to. Then I added a second global state for light/dark themes and found that the add/subtract buttons affect the light/dark variable! I think I'm misusing the useDispatch() hook or combining reducers incorrectly. I've tried moving things into different containers and fiddled a lot with the syntax. In the code below I have omitted `import` and `export` statements for brevity:  \n  \nApp.js:  \n  \n    const App = () =&gt; {\n        return (\n          &lt;div className=\"App\"&gt;\n            &lt;ThemeBar /&gt;\n            &lt;Counter /&gt;\n          &lt;/div&gt;\n        );\n    }\n  \nThemeBar.js:  \n  \n    const ThemeBar = () =&gt; {\n        const theme = useSelector(state =&gt; state.theme.themeIsLight)\n        const dispatch = useDispatch();\n    \n        return (\n            &lt;div&gt;\n                &lt;ThemeOutput value={theme} /&gt;\n                &lt;ThemeButton label=\"Toggle Theme\"\n                             clicked={()=&gt;dispatch({type: 'TOGGLE_THEME'})}/&gt;\n            &lt;/div&gt;\n        );\n    };\n  \nCounter.js:  \n  \n    const Counter = () =&gt; {\n        const count = useSelector(state =&gt; state.number.counter);\n        const dispatch = useDispatch();\n    \n            return (\n                &lt;div&gt;\n                    &lt;CounterOutput value={count} /&gt;\n                    &lt;CounterControl label=\"Increment\"\n                                    clicked={()=&gt;dispatch({ type: 'INCREMENT'})} /&gt;\n                    &lt;CounterControl label=\"Decrement\"\n                                    clicked={()=&gt;dispatch({ type: 'DECREMENT'})} /&gt;\n                    &lt;CounterControl label=\"Add 5\"\n                                    clicked={()=&gt;dispatch({ type: 'ADD', value: 5})} /&gt;\n                    &lt;CounterControl label=\"Subtract 5\"\n                                    clicked={()=&gt;dispatch({ type: 'SUBTRACT', value: 5})} /&gt;\n                &lt;/div&gt;\n            );\n    };  \n  \nthemeReducer.js:  \n  \n    const themeReducer = (state = initialState, action) =&gt; {\n        console.log('Theme: ' + state.themeIsLight);\n        if (action.type === 'TOGGLE_THEME')\n            return { themeIsLight: !state.themeIsLight};\n        return state;\n    };\n  \nglobalNumberReducer.js:  \n  \n    const globalNumberReducer = (state = initialState, action) =&gt; {\n        switch (action.type) {\n            case 'INCREMENT': return {counter: state.counter + 1};\n            case 'DECREMENT': return {counter: state.counter - 1};\n            case 'ADD': return {counter: state.counter + action.value};\n            case 'SUBTRACT': return {counter: state.counter - action.value};\n            default: return state;\n        }\n    };\n  \nindex.js:  \n  \n    const rootReducer = combineReducers({\n        number: globalNumberReducer,\n        theme:themeReducer\n    });\n    \n    const store = createStore(rootReducer);\n    console.log(store.getState());\n    \n    \n    ReactDOM.render(\n        &lt;Provider store={store}&gt;&lt;App /&gt;&lt;/Provider&gt;, document.getElementById('root')\n    );\n    registerServiceWorker();", "author_fullname": "t2_fxfaw", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Dispatching for one type of global state affects the other. Why?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_h7t6sq", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.67, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1592024882.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m using Redux with my React Hooks simple counter project. It worked without any bugs or problems when the only global state was a simple integer with +/- buttons to. Then I added a second global state for light/dark themes and found that the add/subtract buttons affect the light/dark variable! I think I&amp;#39;m misusing the useDispatch() hook or combining reducers incorrectly. I&amp;#39;ve tried moving things into different containers and fiddled a lot with the syntax. In the code below I have omitted &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; statements for brevity:  &lt;/p&gt;\n\n&lt;p&gt;App.js:  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const App = () =&amp;gt; {\n    return (\n      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;\n        &amp;lt;ThemeBar /&amp;gt;\n        &amp;lt;Counter /&amp;gt;\n      &amp;lt;/div&amp;gt;\n    );\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;ThemeBar.js:  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const ThemeBar = () =&amp;gt; {\n    const theme = useSelector(state =&amp;gt; state.theme.themeIsLight)\n    const dispatch = useDispatch();\n\n    return (\n        &amp;lt;div&amp;gt;\n            &amp;lt;ThemeOutput value={theme} /&amp;gt;\n            &amp;lt;ThemeButton label=&amp;quot;Toggle Theme&amp;quot;\n                         clicked={()=&amp;gt;dispatch({type: &amp;#39;TOGGLE_THEME&amp;#39;})}/&amp;gt;\n        &amp;lt;/div&amp;gt;\n    );\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Counter.js:  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const Counter = () =&amp;gt; {\n    const count = useSelector(state =&amp;gt; state.number.counter);\n    const dispatch = useDispatch();\n\n        return (\n            &amp;lt;div&amp;gt;\n                &amp;lt;CounterOutput value={count} /&amp;gt;\n                &amp;lt;CounterControl label=&amp;quot;Increment&amp;quot;\n                                clicked={()=&amp;gt;dispatch({ type: &amp;#39;INCREMENT&amp;#39;})} /&amp;gt;\n                &amp;lt;CounterControl label=&amp;quot;Decrement&amp;quot;\n                                clicked={()=&amp;gt;dispatch({ type: &amp;#39;DECREMENT&amp;#39;})} /&amp;gt;\n                &amp;lt;CounterControl label=&amp;quot;Add 5&amp;quot;\n                                clicked={()=&amp;gt;dispatch({ type: &amp;#39;ADD&amp;#39;, value: 5})} /&amp;gt;\n                &amp;lt;CounterControl label=&amp;quot;Subtract 5&amp;quot;\n                                clicked={()=&amp;gt;dispatch({ type: &amp;#39;SUBTRACT&amp;#39;, value: 5})} /&amp;gt;\n            &amp;lt;/div&amp;gt;\n        );\n};  \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;themeReducer.js:  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const themeReducer = (state = initialState, action) =&amp;gt; {\n    console.log(&amp;#39;Theme: &amp;#39; + state.themeIsLight);\n    if (action.type === &amp;#39;TOGGLE_THEME&amp;#39;)\n        return { themeIsLight: !state.themeIsLight};\n    return state;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;globalNumberReducer.js:  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const globalNumberReducer = (state = initialState, action) =&amp;gt; {\n    switch (action.type) {\n        case &amp;#39;INCREMENT&amp;#39;: return {counter: state.counter + 1};\n        case &amp;#39;DECREMENT&amp;#39;: return {counter: state.counter - 1};\n        case &amp;#39;ADD&amp;#39;: return {counter: state.counter + action.value};\n        case &amp;#39;SUBTRACT&amp;#39;: return {counter: state.counter - action.value};\n        default: return state;\n    }\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;index.js:  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const rootReducer = combineReducers({\n    number: globalNumberReducer,\n    theme:themeReducer\n});\n\nconst store = createStore(rootReducer);\nconsole.log(store.getState());\n\n\nReactDOM.render(\n    &amp;lt;Provider store={store}&amp;gt;&amp;lt;App /&amp;gt;&amp;lt;/Provider&amp;gt;, document.getElementById(&amp;#39;root&amp;#39;)\n);\nregisterServiceWorker();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "h7t6sq", "is_robot_indexable": true, "report_reasons": null, "author": "chunyukuo", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/h7t6sq/dispatching_for_one_type_of_global_state_affects/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/h7t6sq/dispatching_for_one_type_of_global_state_affects/", "subreddit_subscribers": 3491, "created_utc": 1591996082.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "**The problem:**\n\nI have a list of buttons that when each is clicked I dispatch some actions to fetch various bits of data from a server and populate the Redux store. Lets say the store looks like the following:\n\n`{ customerDetails: { name: \"John\", age: 25 }, tasks: [] }`\n\nand the actions are split into 2, the first fetches customer details and the other fetches tasks.\n\nIf the user clicks the first button to see Customer1 and then clicks to see Customer2 before all the async actions for Customer1 have come back then the Redux store can get into a state where it'll be populated with Customer1 data if the async actions from the first button come back \\_after\\_ the async actions from the second button click (Customer2).\n\n&amp;#x200B;\n\nI can think of a few solutions to this, but all seem slightly complex..\n\n1. Store a `latestButtonClickedID` in the store and when all the async actions come back they can then check whether they were dispatched with the same ID as the one that is in the store now. If the IDs match then we update the store, if the IDs do not match then we do nothing with the API response (i.e. do not update the store). This means I would have to pass in `latestButtonClickedID` into a lot of my actions that fetch data, not really ideal.\n2. Change the store to look like  `{ buttonID1: { customerDetails: { ... }, tasks [] }, buttonID2: { customerDetails: { ... }, tasks [] } }` I'd then need to pass the correct data into the presentational component by using a selector that selects the data for the correct `buttonID`, where the `buttonID` is set synchronously on button click. This would also involve passing `buttonID`'s around everywhere.\n3. Some sort of promise cancellation? Can anyone point me in the right direction for this if possible?\n4. Disable any other button from being clicked until all promises of fetching the data have resolved. I can't really do this as the buttons are from a 3rd party library.\n5. redux-saga `takeLatest`... I'd rather not as the team have found this to be fairly complex for our needs.\n\n&amp;#x200B;\n\nAny other suggestions? Thanks.", "author_fullname": "t2_2rp7wnuv", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Asynchronous actions, Redux store and race conditions.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_h7j059", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.75, "author_flair_background_color": null, "subreddit_type": "public", "ups": 4, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 4, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591990179.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;strong&gt;The problem:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;I have a list of buttons that when each is clicked I dispatch some actions to fetch various bits of data from a server and populate the Redux store. Lets say the store looks like the following:&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;{ customerDetails: { name: &amp;quot;John&amp;quot;, age: 25 }, tasks: [] }&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;and the actions are split into 2, the first fetches customer details and the other fetches tasks.&lt;/p&gt;\n\n&lt;p&gt;If the user clicks the first button to see Customer1 and then clicks to see Customer2 before all the async actions for Customer1 have come back then the Redux store can get into a state where it&amp;#39;ll be populated with Customer1 data if the async actions from the first button come back _after_ the async actions from the second button click (Customer2).&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;I can think of a few solutions to this, but all seem slightly complex..&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Store a &lt;code&gt;latestButtonClickedID&lt;/code&gt; in the store and when all the async actions come back they can then check whether they were dispatched with the same ID as the one that is in the store now. If the IDs match then we update the store, if the IDs do not match then we do nothing with the API response (i.e. do not update the store). This means I would have to pass in &lt;code&gt;latestButtonClickedID&lt;/code&gt; into a lot of my actions that fetch data, not really ideal.&lt;/li&gt;\n&lt;li&gt;Change the store to look like  &lt;code&gt;{ buttonID1: { customerDetails: { ... }, tasks [] }, buttonID2: { customerDetails: { ... }, tasks [] } }&lt;/code&gt; I&amp;#39;d then need to pass the correct data into the presentational component by using a selector that selects the data for the correct &lt;code&gt;buttonID&lt;/code&gt;, where the &lt;code&gt;buttonID&lt;/code&gt; is set synchronously on button click. This would also involve passing &lt;code&gt;buttonID&lt;/code&gt;&amp;#39;s around everywhere.&lt;/li&gt;\n&lt;li&gt;Some sort of promise cancellation? Can anyone point me in the right direction for this if possible?&lt;/li&gt;\n&lt;li&gt;Disable any other button from being clicked until all promises of fetching the data have resolved. I can&amp;#39;t really do this as the buttons are from a 3rd party library.&lt;/li&gt;\n&lt;li&gt;redux-saga &lt;code&gt;takeLatest&lt;/code&gt;... I&amp;#39;d rather not as the team have found this to be fairly complex for our needs.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;Any other suggestions? Thanks.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "h7j059", "is_robot_indexable": true, "report_reasons": null, "author": "jet810", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/h7j059/asynchronous_actions_redux_store_and_race/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/h7j059/asynchronous_actions_redux_store_and_race/", "subreddit_subscribers": 3491, "created_utc": 1591961379.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "At my work we use something along the lines of every real \"action\" having a pending, success, and fail action. Out of curiosity I checked some online resources and I'll see more of a SET vs GET sort of thing for actions. Just wondering if there is a best practice for this sort of thing for my own projects?\n\nThanks", "author_fullname": "t2_15a1fn", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Best practice for actions?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_h13l2y", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591924761.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;At my work we use something along the lines of every real &amp;quot;action&amp;quot; having a pending, success, and fail action. Out of curiosity I checked some online resources and I&amp;#39;ll see more of a SET vs GET sort of thing for actions. Just wondering if there is a best practice for this sort of thing for my own projects?&lt;/p&gt;\n\n&lt;p&gt;Thanks&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "h13l2y", "is_robot_indexable": true, "report_reasons": null, "author": "SweetestTeaCups", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/h13l2y/best_practice_for_actions/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/h13l2y/best_practice_for_actions/", "subreddit_subscribers": 3491, "created_utc": 1591895961.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "Reference from [Official docs](https://redux.js.org/recipes/writing-tests#action-creators):\n\nIn Redux, action creators are functions which return plain objects. When testing action creators, we want to test whether the correct action creator was called and also whether the right action was returned.\n\nBut my question is WHY?\n\nActionCreator is a function that returns an object. It's a pure function. All it does is returning an object with whatever data is passed while calling. Is there any risk of not testing this function?\n\n    export function addTodo(text) {\n      return {\n        type: types.ADD_TODO,\n        text\n      }\n    }\n\nIts more like creating two objects and doing deep comparison.\n\n&gt;expect(actions.addTodo(text)).toEqual(expectedAction)\n\nThe only scenario I can think of where unit tests can be useful is when someone accidentally changes this function to return an object with type: `types.EDIT_TODO`\n\nBut  is this the only case? Are there any other benefits  of writing tests cases for functions that does the obvious?  \n\n\nEDIT: I do use `redux-saga` for managing async actions (fetching data through API calls etc) and I do write unit tests for sagas. I'm only concerned  about writing unit tests for action creators!", "author_fullname": "t2_1yqbwig6", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Why should I write unit test for actionCreators?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_h0ue75", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1591861874.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591888959.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Reference from &lt;a href=\"https://redux.js.org/recipes/writing-tests#action-creators\"&gt;Official docs&lt;/a&gt;:&lt;/p&gt;\n\n&lt;p&gt;In Redux, action creators are functions which return plain objects. When testing action creators, we want to test whether the correct action creator was called and also whether the right action was returned.&lt;/p&gt;\n\n&lt;p&gt;But my question is WHY?&lt;/p&gt;\n\n&lt;p&gt;ActionCreator is a function that returns an object. It&amp;#39;s a pure function. All it does is returning an object with whatever data is passed while calling. Is there any risk of not testing this function?&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;export function addTodo(text) {\n  return {\n    type: types.ADD_TODO,\n    text\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Its more like creating two objects and doing deep comparison.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;expect(actions.addTodo(text)).toEqual(expectedAction)&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The only scenario I can think of where unit tests can be useful is when someone accidentally changes this function to return an object with type: &lt;code&gt;types.EDIT_TODO&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;But  is this the only case? Are there any other benefits  of writing tests cases for functions that does the obvious?  &lt;/p&gt;\n\n&lt;p&gt;EDIT: I do use &lt;code&gt;redux-saga&lt;/code&gt; for managing async actions (fetching data through API calls etc) and I do write unit tests for sagas. I&amp;#39;m only concerned  about writing unit tests for action creators!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "h0ue75", "is_robot_indexable": true, "report_reasons": null, "author": "rehman_00001", "discussion_type": null, "num_comments": 6, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/h0ue75/why_should_i_write_unit_test_for_actioncreators/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/h0ue75/why_should_i_write_unit_test_for_actioncreators/", "subreddit_subscribers": 3491, "created_utc": 1591860159.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "This might seem like a dumb question but this current code architecture I'm working with, each \"sibling component\" think left/right panels, have their own reducers(obviously?). Then they're joined into a parent reducer eg. `allReducers`.\n\nSo for the sake of an example we have: left panel, right panel\n\nIf right-panel has some state it's maintaining, can left-panel use it(without using that primary combined parent reducer).\n\nAnyway I know this is hard to imagine without code, also we're using saga which I don't know off hand what it's for. The saga files have function generators inside them. I don't think it's relevant.", "author_fullname": "t2_5wf87j7d", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Can you use reducers across sibling components?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_h0dbjw", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.67, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591832116.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;This might seem like a dumb question but this current code architecture I&amp;#39;m working with, each &amp;quot;sibling component&amp;quot; think left/right panels, have their own reducers(obviously?). Then they&amp;#39;re joined into a parent reducer eg. &lt;code&gt;allReducers&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;So for the sake of an example we have: left panel, right panel&lt;/p&gt;\n\n&lt;p&gt;If right-panel has some state it&amp;#39;s maintaining, can left-panel use it(without using that primary combined parent reducer).&lt;/p&gt;\n\n&lt;p&gt;Anyway I know this is hard to imagine without code, also we&amp;#39;re using saga which I don&amp;#39;t know off hand what it&amp;#39;s for. The saga files have function generators inside them. I don&amp;#39;t think it&amp;#39;s relevant.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "h0dbjw", "is_robot_indexable": true, "report_reasons": null, "author": "post_hazanko", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/h0dbjw/can_you_use_reducers_across_sibling_components/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/h0dbjw/can_you_use_reducers_across_sibling_components/", "subreddit_subscribers": 3491, "created_utc": 1591803316.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "This is probably a weird question but as I trace through(console log execution) of events when loading a component that is using `mapStateToProps` the value I set in the reducer state is what I see on the immediate load of the component.\n\nI have a case where there is a destructured \"key\" in the props that is the same name/key as an added prop from `mapStateToProps` so I'm wondering if this is expected or a clash/technically an error...\n\nAnd testing if I take out the `key: val` entry in the reducer state, the destructured prop is still there but the value is undefined.\n\nedit: here's a better idea of what I'm saying\n\n`const componentName = (props) =&gt; {`\n\n`const { isLoading } = props;`\n\n`}`\n\n`const mapStateToProps = state =&gt; ({`\n\n`isLoading: state.reducerState.isLoading`\n\n`})`\n\n`// rest of dispatch/connect`\n\nI don't know if this fully captures the issue, since we also have connected components going on, a main reducer/saga...", "author_fullname": "t2_5wf87j7d", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Does mapStateToProps run first before the component pulls in the props passed down into it?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_gz7hpt", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1591668209.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591677413.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;This is probably a weird question but as I trace through(console log execution) of events when loading a component that is using &lt;code&gt;mapStateToProps&lt;/code&gt; the value I set in the reducer state is what I see on the immediate load of the component.&lt;/p&gt;\n\n&lt;p&gt;I have a case where there is a destructured &amp;quot;key&amp;quot; in the props that is the same name/key as an added prop from &lt;code&gt;mapStateToProps&lt;/code&gt; so I&amp;#39;m wondering if this is expected or a clash/technically an error...&lt;/p&gt;\n\n&lt;p&gt;And testing if I take out the &lt;code&gt;key: val&lt;/code&gt; entry in the reducer state, the destructured prop is still there but the value is undefined.&lt;/p&gt;\n\n&lt;p&gt;edit: here&amp;#39;s a better idea of what I&amp;#39;m saying&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;const componentName = (props) =&amp;gt; {&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;const { isLoading } = props;&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;const mapStateToProps = state =&amp;gt; ({&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;isLoading: state.reducerState.isLoading&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;})&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;// rest of dispatch/connect&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;I don&amp;#39;t know if this fully captures the issue, since we also have connected components going on, a main reducer/saga...&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gz7hpt", "is_robot_indexable": true, "report_reasons": null, "author": "post_hazanko", "discussion_type": null, "num_comments": 15, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/gz7hpt/does_mapstatetoprops_run_first_before_the/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/gz7hpt/does_mapstatetoprops_run_first_before_the/", "subreddit_subscribers": 3491, "created_utc": 1591648613.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "I made a small app that fetches restaurant data, displays it, and allows filtering and searching cities and all the usual stuff using useReducer and now I am trying to refactor it to use Redux. I am not using Redux ToolKit yet but I plan on learning it for my next project.\n\nAnyway, I made my rootReducer, brought in Provider and createStore and hooked all that up but in Redux devtools I see Reddit's store for my user and not my app store. Here is my index.js code. And I did install redux and react-redux and I see it in package.json. I have not connected any components yet but should I not see my store in redux dev tools?\n\n    ...\n    import { createStore } from 'redux';\n    import { Provider } from 'react-redux';\n    import { rootReducer } from './reducers/rootReducer.js';\n    \n    const store = createStore(rootReducer);\n    \n    ReactDOM.render(\n      &lt;Provider store={store}&gt;\n        &lt;React.StrictMode&gt;\n          &lt;App /&gt;\n        &lt;/React.StrictMode&gt;\n      &lt;/Provider&gt;,\n      document.getElementById('root')\n    );\n    \n    ...\n\nThanks in advance for nay help\n\nEDIT: formatting", "author_fullname": "t2_n3fb7", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "I am getting Reddit's store in my app and not the one I created", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_gvduz0", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.86, "author_flair_background_color": null, "subreddit_type": "public", "ups": 5, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 5, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591154611.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I made a small app that fetches restaurant data, displays it, and allows filtering and searching cities and all the usual stuff using useReducer and now I am trying to refactor it to use Redux. I am not using Redux ToolKit yet but I plan on learning it for my next project.&lt;/p&gt;\n\n&lt;p&gt;Anyway, I made my rootReducer, brought in Provider and createStore and hooked all that up but in Redux devtools I see Reddit&amp;#39;s store for my user and not my app store. Here is my index.js code. And I did install redux and react-redux and I see it in package.json. I have not connected any components yet but should I not see my store in redux dev tools?&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;...\nimport { createStore } from &amp;#39;redux&amp;#39;;\nimport { Provider } from &amp;#39;react-redux&amp;#39;;\nimport { rootReducer } from &amp;#39;./reducers/rootReducer.js&amp;#39;;\n\nconst store = createStore(rootReducer);\n\nReactDOM.render(\n  &amp;lt;Provider store={store}&amp;gt;\n    &amp;lt;React.StrictMode&amp;gt;\n      &amp;lt;App /&amp;gt;\n    &amp;lt;/React.StrictMode&amp;gt;\n  &amp;lt;/Provider&amp;gt;,\n  document.getElementById(&amp;#39;root&amp;#39;)\n);\n\n...\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Thanks in advance for nay help&lt;/p&gt;\n\n&lt;p&gt;EDIT: formatting&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gvduz0", "is_robot_indexable": true, "report_reasons": null, "author": "mayaswelltrythis", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/gvduz0/i_am_getting_reddits_store_in_my_app_and_not_the/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/gvduz0/i_am_getting_reddits_store_in_my_app_and_not_the/", "subreddit_subscribers": 3491, "created_utc": 1591125811.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": " I was thinking that perhaps redux has too much indirection, maybe? I mean its a bit too much separation of concern with all the mapdispatch and mapstate and actions and reducers . If the point is to use a global store why not just import a singleton class and use its state with plain getters &amp; setters? or some other object with application level scope ?  Thanks in advance for reading and giving this some thought.\u00a0", "author_fullname": "t2_abn7qm5", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "[Q] Why so much work just for a global storage space?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_gv47ka", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.8, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591119279.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I was thinking that perhaps redux has too much indirection, maybe? I mean its a bit too much separation of concern with all the mapdispatch and mapstate and actions and reducers . If the point is to use a global store why not just import a singleton class and use its state with plain getters &amp;amp; setters? or some other object with application level scope ?  Thanks in advance for reading and giving this some thought.\u00a0&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gv47ka", "is_robot_indexable": true, "report_reasons": null, "author": "mrarthurwhite", "discussion_type": null, "num_comments": 6, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/gv47ka/q_why_so_much_work_just_for_a_global_storage_space/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/gv47ka/q_why_so_much_work_just_for_a_global_storage_space/", "subreddit_subscribers": 3491, "created_utc": 1591090479.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "", "author_fullname": "t2_qtig0", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Easy Peasy the React Redux wrapper", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_gv3kc9", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.4, "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1591115904.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "medium.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gv3kc9", "is_robot_indexable": true, "report_reasons": null, "author": "Fewthp", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/gv3kc9/easy_peasy_the_react_redux_wrapper/", "parent_whitelist_status": null, "stickied": false, "url": "https://medium.com//easy-peasy-the-react-redux-wrapper-b31a5911c5e3?source=friends_link&amp;sk=b5d0c558e24e3e0c7f40cf58dff17d70", "subreddit_subscribers": 3491, "created_utc": 1591087104.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "I've been hustling with this for a few days now and I can't find a satisfactory answer anywhere else.\n\nI'm currently working as an Ethereum Dapp Engineer and the crypto ecosystem is known to have some very poorly implemented libraries which almost everyone depends upon.\n\nI need multi-wallet support in my app and this is a lot of work for now. My team uses this library called [web3-react](https://github.com/NoahZinsmeister/web3-react). It is a React-centric lib that allows for easy integration with different wallet providers.\n\nTo integrate this with Redux, I need to tap into it at the higher levels of my app and dispatch some actions. This way I can store the current connector and library in the store:\n\n    function Initializer({ children }) {\n      const dispatch = useDispatch();\n      const web3React = useWeb3React();\n      const { account, library, connector } = web3React;\n    \n      React.useEffect(() =&gt; {\n        dispatch(\n          changeProvider({\n            connector,\n            library,\n           })\n        );\n      }, [connector, library, dispatch]);\n    \n      React.useEffect(() =&gt; {\n        dispatch(changeAccount(account));\n      }, [account, dispatch]);\n    \n      return children;\n    }\n\n**Problem #1**: `connector` and `library` are non-serializable and this is a NO-NO [according to the official style-guide](https://redux.js.org/style-guide/style-guide#do-not-put-non-serializable-values-in-state-or-actions).\n\nOkay, let's find some place else for them to be.\n\n**Approach #1:**\n\nSince I'm using [@reduxjs/toolkit](https://redux-toolkit.js.org/), by default it comes with `redux-thunk`.\n\nI created the following thunk to deal with provider connection:\n\n```\nexport const activateConnector = Object.assign(\n  ({ activate, setError, connectorName }) =&gt; async (dispatch, getState) =&gt; {\n    const currentConnectorName = selectConnectorName(getState());\n    if (currentConnectorName === connectorName) {\n      return;\n    }\n\n    try {\n      dispatch(activateConnector.pending(connectorName));\n\n      await activate(getConnector(connectorName), (err) =&gt; setError(err), true);\n\n      dispatch(activateConnector.fulfilled(connectorName));\n    } catch (err) {\n      dispatch(activateConnector.rejected(err.message));\n    }\n  },\n  {\n    pending: createAction(\"web3/activateConnector/pending\"),\n    fulfilled: createAction(\"web3/activateConnector/fulfilled\"),\n    rejected: createAction(\"web3/activateConnector/rejected\"),\n  }\n);\n```\n\nIn this scenario, my other thunks depend on `library` (to be more precise, they depend on both on `library` and some smart contract instances that depend on `library`). Since I can't put it in the store, I thought about using `thunk.withExtraArgument` API.\n\n**Problem #2:** `withExtraArgument` assumes the extra arg is resolved by the time the store is created. However, since the user can change the wallet provider at any time, I need a way to overwrite in runtime. That doesn't seem possible and [redux-thunk maintainers don't seem to eager to add such functionality](https://github.com/reduxjs/redux-thunk/issues/277).\n\nI managed to workaround that by injecting a mutable object in the thunk and using a custom middleware to change the reference whenever the library changes:\n\n    const createApi = (library) =&gt; {\n      return {\n        // This is a contrived example. Most methods are not just a passthrough.\n        async getBalance(account) {\n          return library.getBalance(account);\n        },\n      };\n    };\n    \n    const services = {\n      api: new Proxy(\n        {},\n        {\n          get: (target, prop, receiver) =&gt; {\n            return () =&gt; Promise.reject(new Error(\"Not initialized\"));\n          },\n        }\n      ),\n    };\n    \n    const store = configureStore({\n      reducer: rootReducer,\n      middleware: [\n        // this should probably be exported from the web3Slice.js file\n        (store) =&gt; (next) =&gt; (action) =&gt; {\n          if (changeLibrary.match(action)) {\n            services.api = createApi(action.payload);\n            // do not forward this action\n            return;\n          }\n    \n          return next(action);\n        },\n        thunk.withExtraArgument(services),\n        ...getDefaultMiddleware({\n          thunk: false,\n        }),\n      ],\n    });\n\nThe `Initializer` component is changed a little bit now:\n\n    //...\n      React.useEffect(() =&gt; {\n        dispatch(\n          activateConnector({\n            connectorName: \"network\",\n            activate,\n            setError,\n          })\n        );\n      }, [activate, dispatch, setError]);\n    \n      React.useEffect(() =&gt; {\n        dispatch(changeAccount(account));\n      }, [account, dispatch]);\n    \n      React.useEffect(() =&gt; {\n        dispatch(changeLibrary(library));\n      }, [library, dispatch]);\n    // ...\n\n**Problem #3:** While this solves the problem, this looks like a JavaScript-ey version of the Service Locator pattern (which many consider to be an anti-pattern).\n\nIt also just basically mutable global state, which could cause inconsistent state.\n\nImagine that I have thunk A and thunk B, which must perform sequential operations always as A -&gt; B. \n\n    const thunkA = () =&gt; async (dispatch, getState, { api }) =&gt; {\n      // ...\n      await api.doLongProcess();\n    \n      // ... dispatch some actions\n    \n      dispatch(thunkB());\n    }\n    \n    const thunkB = () =&gt; async (dispatch, getState, { api }) =&gt; {\n      await api.doOtherThing();\n    }\n\nWhile `api.doLongProcess` is in course, a `changeLibrary` event arrives. That will cause the `api` dependency to be changed, so what happens next is that when `thunkB` is called with the newer `api` instance. This is a big problem.\n\nWhat I believe should happpen is that upon `api` change, all in-course operations depending on it should be cancelled. That is not an easy thing to pull out with this setup.\n\nDoes anyone have a suggestion on how to approach this?", "author_fullname": "t2_130ztk", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Dynamic dependency injection with Redux", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_gutj9m", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1591122362.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591075899.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;ve been hustling with this for a few days now and I can&amp;#39;t find a satisfactory answer anywhere else.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m currently working as an Ethereum Dapp Engineer and the crypto ecosystem is known to have some very poorly implemented libraries which almost everyone depends upon.&lt;/p&gt;\n\n&lt;p&gt;I need multi-wallet support in my app and this is a lot of work for now. My team uses this library called &lt;a href=\"https://github.com/NoahZinsmeister/web3-react\"&gt;web3-react&lt;/a&gt;. It is a React-centric lib that allows for easy integration with different wallet providers.&lt;/p&gt;\n\n&lt;p&gt;To integrate this with Redux, I need to tap into it at the higher levels of my app and dispatch some actions. This way I can store the current connector and library in the store:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;function Initializer({ children }) {\n  const dispatch = useDispatch();\n  const web3React = useWeb3React();\n  const { account, library, connector } = web3React;\n\n  React.useEffect(() =&amp;gt; {\n    dispatch(\n      changeProvider({\n        connector,\n        library,\n       })\n    );\n  }, [connector, library, dispatch]);\n\n  React.useEffect(() =&amp;gt; {\n    dispatch(changeAccount(account));\n  }, [account, dispatch]);\n\n  return children;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Problem #1&lt;/strong&gt;: &lt;code&gt;connector&lt;/code&gt; and &lt;code&gt;library&lt;/code&gt; are non-serializable and this is a NO-NO &lt;a href=\"https://redux.js.org/style-guide/style-guide#do-not-put-non-serializable-values-in-state-or-actions\"&gt;according to the official style-guide&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;Okay, let&amp;#39;s find some place else for them to be.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Approach #1:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Since I&amp;#39;m using &lt;a href=\"https://redux-toolkit.js.org/\"&gt;@reduxjs/toolkit&lt;/a&gt;, by default it comes with &lt;code&gt;redux-thunk&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;I created the following thunk to deal with provider connection:&lt;/p&gt;\n\n&lt;p&gt;```\nexport const activateConnector = Object.assign(\n  ({ activate, setError, connectorName }) =&amp;gt; async (dispatch, getState) =&amp;gt; {\n    const currentConnectorName = selectConnectorName(getState());\n    if (currentConnectorName === connectorName) {\n      return;\n    }&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;try {\n  dispatch(activateConnector.pending(connectorName));\n\n  await activate(getConnector(connectorName), (err) =&amp;gt; setError(err), true);\n\n  dispatch(activateConnector.fulfilled(connectorName));\n} catch (err) {\n  dispatch(activateConnector.rejected(err.message));\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;},\n  {\n    pending: createAction(&amp;quot;web3/activateConnector/pending&amp;quot;),\n    fulfilled: createAction(&amp;quot;web3/activateConnector/fulfilled&amp;quot;),\n    rejected: createAction(&amp;quot;web3/activateConnector/rejected&amp;quot;),\n  }\n);\n```&lt;/p&gt;\n\n&lt;p&gt;In this scenario, my other thunks depend on &lt;code&gt;library&lt;/code&gt; (to be more precise, they depend on both on &lt;code&gt;library&lt;/code&gt; and some smart contract instances that depend on &lt;code&gt;library&lt;/code&gt;). Since I can&amp;#39;t put it in the store, I thought about using &lt;code&gt;thunk.withExtraArgument&lt;/code&gt; API.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Problem #2:&lt;/strong&gt; &lt;code&gt;withExtraArgument&lt;/code&gt; assumes the extra arg is resolved by the time the store is created. However, since the user can change the wallet provider at any time, I need a way to overwrite in runtime. That doesn&amp;#39;t seem possible and &lt;a href=\"https://github.com/reduxjs/redux-thunk/issues/277\"&gt;redux-thunk maintainers don&amp;#39;t seem to eager to add such functionality&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;I managed to workaround that by injecting a mutable object in the thunk and using a custom middleware to change the reference whenever the library changes:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const createApi = (library) =&amp;gt; {\n  return {\n    // This is a contrived example. Most methods are not just a passthrough.\n    async getBalance(account) {\n      return library.getBalance(account);\n    },\n  };\n};\n\nconst services = {\n  api: new Proxy(\n    {},\n    {\n      get: (target, prop, receiver) =&amp;gt; {\n        return () =&amp;gt; Promise.reject(new Error(&amp;quot;Not initialized&amp;quot;));\n      },\n    }\n  ),\n};\n\nconst store = configureStore({\n  reducer: rootReducer,\n  middleware: [\n    // this should probably be exported from the web3Slice.js file\n    (store) =&amp;gt; (next) =&amp;gt; (action) =&amp;gt; {\n      if (changeLibrary.match(action)) {\n        services.api = createApi(action.payload);\n        // do not forward this action\n        return;\n      }\n\n      return next(action);\n    },\n    thunk.withExtraArgument(services),\n    ...getDefaultMiddleware({\n      thunk: false,\n    }),\n  ],\n});\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The &lt;code&gt;Initializer&lt;/code&gt; component is changed a little bit now:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;//...\n  React.useEffect(() =&amp;gt; {\n    dispatch(\n      activateConnector({\n        connectorName: &amp;quot;network&amp;quot;,\n        activate,\n        setError,\n      })\n    );\n  }, [activate, dispatch, setError]);\n\n  React.useEffect(() =&amp;gt; {\n    dispatch(changeAccount(account));\n  }, [account, dispatch]);\n\n  React.useEffect(() =&amp;gt; {\n    dispatch(changeLibrary(library));\n  }, [library, dispatch]);\n// ...\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Problem #3:&lt;/strong&gt; While this solves the problem, this looks like a JavaScript-ey version of the Service Locator pattern (which many consider to be an anti-pattern).&lt;/p&gt;\n\n&lt;p&gt;It also just basically mutable global state, which could cause inconsistent state.&lt;/p&gt;\n\n&lt;p&gt;Imagine that I have thunk A and thunk B, which must perform sequential operations always as A -&amp;gt; B. &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const thunkA = () =&amp;gt; async (dispatch, getState, { api }) =&amp;gt; {\n  // ...\n  await api.doLongProcess();\n\n  // ... dispatch some actions\n\n  dispatch(thunkB());\n}\n\nconst thunkB = () =&amp;gt; async (dispatch, getState, { api }) =&amp;gt; {\n  await api.doOtherThing();\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;While &lt;code&gt;api.doLongProcess&lt;/code&gt; is in course, a &lt;code&gt;changeLibrary&lt;/code&gt; event arrives. That will cause the &lt;code&gt;api&lt;/code&gt; dependency to be changed, so what happens next is that when &lt;code&gt;thunkB&lt;/code&gt; is called with the newer &lt;code&gt;api&lt;/code&gt; instance. This is a big problem.&lt;/p&gt;\n\n&lt;p&gt;What I believe should happpen is that upon &lt;code&gt;api&lt;/code&gt; change, all in-course operations depending on it should be cancelled. That is not an easy thing to pull out with this setup.&lt;/p&gt;\n\n&lt;p&gt;Does anyone have a suggestion on how to approach this?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gutj9m", "is_robot_indexable": true, "report_reasons": null, "author": "hbarcelos", "discussion_type": null, "num_comments": 5, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/gutj9m/dynamic_dependency_injection_with_redux/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/gutj9m/dynamic_dependency_injection_with_redux/", "subreddit_subscribers": 3491, "created_utc": 1591047099.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_gutj9m", "before": null}}