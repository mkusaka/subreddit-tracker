{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_frybe", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "The Evolution of a Go Programmer", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f1hy9a", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 197, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 197, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581323099.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f1hy9a", "is_robot_indexable": true, "report_reasons": null, "author": "SuperPaintman", "discussion_type": null, "num_comments": 29, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/f1hy9a/the_evolution_of_a_go_programmer/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/SuperPaintman/the-evolution-of-a-go-programmer", "subreddit_subscribers": 102312, "created_utc": 1581294299.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_iaoxg", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Excelize 2.1.0 is Released \u2013 Go lib for reading and writing Excel (XLSX) files", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f1azwz", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 76, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 76, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581294789.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f1azwz", "is_robot_indexable": true, "report_reasons": null, "author": "luxurioust", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/f1azwz/excelize_210_is_released_go_lib_for_reading_and/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/360EntSecGroup-Skylar/excelize/releases/tag/v2.1.0", "subreddit_subscribers": 102312, "created_utc": 1581265989.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Looking for practical exercises related to goroutines and channels. Most of the things I found online are tutorials and would love to get some more exercises. Then these exercises would cover different sub-topics (eg. waiting). It would be nice if these exercises have solution sets too.", "author_fullname": "t2_11pjka", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Looking for Practical Goroutine / Channels Exercises", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f1bi58", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 57, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 57, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581296839.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Looking for practical exercises related to goroutines and channels. Most of the things I found online are tutorials and would love to get some more exercises. Then these exercises would cover different sub-topics (eg. waiting). It would be nice if these exercises have solution sets too.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f1bi58", "is_robot_indexable": true, "report_reasons": null, "author": "kolinkorr839", "discussion_type": null, "num_comments": 6, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/f1bi58/looking_for_practical_goroutine_channels_exercises/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/f1bi58/looking_for_practical_goroutine_channels_exercises/", "subreddit_subscribers": 102312, "created_utc": 1581268039.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_2ztajdv7", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "[Rob Pike][2012] Less is exponentially more", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f1nj16", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581352523.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "commandcenter.blogspot.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f1nj16", "is_robot_indexable": true, "report_reasons": null, "author": "hyperTrashPanda", "discussion_type": null, "num_comments": 0, "send_replies": false, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/f1nj16/rob_pike2012_less_is_exponentially_more/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html", "subreddit_subscribers": 102312, "created_utc": 1581323723.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_ghqes", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "8chipgo - Chip 8 implemented in Go with pixel library", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f1dhgv", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 26, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 26, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581304768.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "i.imgur.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f1dhgv", "is_robot_indexable": true, "report_reasons": null, "author": "thekidwithabrain", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/f1dhgv/8chipgo_chip_8_implemented_in_go_with_pixel/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://i.imgur.com/6C46vtD.gif", "subreddit_subscribers": 102312, "created_utc": 1581275968.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_i9xrk", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Bosun - Kibana Automatic Index Pattern Discovery and Other Curating Tasks with Go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_f1p7h7", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581364210.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f1p7h7", "is_robot_indexable": true, "report_reasons": null, "author": "SherifAbdelNaby", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/f1p7h7/bosun_kibana_automatic_index_pattern_discovery/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/sherifabdlnaby/bosun", "subreddit_subscribers": 102312, "created_utc": 1581335410.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_4kcgc0y9", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Go: Inlining Strategy &amp; Limitation", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f18oi1", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 56, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 56, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581284037.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "medium.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f18oi1", "is_robot_indexable": true, "report_reasons": null, "author": "a_journey_with_go", "discussion_type": null, "num_comments": 10, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/f18oi1/go_inlining_strategy_limitation/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://medium.com/a-journey-with-go/go-inlining-strategy-limitation-6b6d7fc3b1be", "subreddit_subscribers": 102312, "created_utc": 1581255237.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hey all,\n\nLittle frustrated as I can't quite put it together in my head on how to handle a scenario I have recently found myself in...\n\nBasically I am sending an API request (in go) to a server.. in a go func, the response of which could be a large number of records. Now, in the go func, I am passed a channel which expects the record type I get back in the API response. What I am not sure of is if the channel should be designed to take an array of struct.. and pass it all back in one call.... or if per the nature of channels.. a stream.. should I do a loop through the records I get back, sending each one through the channel and requiring the receiver to then put them together as an array before doing something with them.\n\nIn this particular situation, the receiver end is itself part of an API req/resp.. so it would essentially be waiting for ALL the individual channel structs.. building up an array of the struct, to then return it as a single JSON response.\n\nI think the right way to do this is the channel is set to stream one record at a time, and the receiver builds up the array of that struct, then marshalls the whole shabang in one JSON response.", "author_fullname": "t2_59hoyipd", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Channels, structs, etc", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f1kdem", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 4, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 4, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581334335.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hey all,&lt;/p&gt;\n\n&lt;p&gt;Little frustrated as I can&amp;#39;t quite put it together in my head on how to handle a scenario I have recently found myself in...&lt;/p&gt;\n\n&lt;p&gt;Basically I am sending an API request (in go) to a server.. in a go func, the response of which could be a large number of records. Now, in the go func, I am passed a channel which expects the record type I get back in the API response. What I am not sure of is if the channel should be designed to take an array of struct.. and pass it all back in one call.... or if per the nature of channels.. a stream.. should I do a loop through the records I get back, sending each one through the channel and requiring the receiver to then put them together as an array before doing something with them.&lt;/p&gt;\n\n&lt;p&gt;In this particular situation, the receiver end is itself part of an API req/resp.. so it would essentially be waiting for ALL the individual channel structs.. building up an array of the struct, to then return it as a single JSON response.&lt;/p&gt;\n\n&lt;p&gt;I think the right way to do this is the channel is set to stream one record at a time, and the receiver builds up the array of that struct, then marshalls the whole shabang in one JSON response.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f1kdem", "is_robot_indexable": true, "report_reasons": null, "author": "frustratedcoderlang", "discussion_type": null, "num_comments": 4, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/f1kdem/channels_structs_etc/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/f1kdem/channels_structs_etc/", "subreddit_subscribers": 102312, "created_utc": 1581305535.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_fptl1", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Paste - a web app to keep encrypted text snippets, easily deployable to Heroku", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f1ooo8", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581360825.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "gitlab.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f1ooo8", "is_robot_indexable": true, "report_reasons": null, "author": "opennota", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/f1ooo8/paste_a_web_app_to_keep_encrypted_text_snippets/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://gitlab.com/opennota/paste", "subreddit_subscribers": 102312, "created_utc": 1581332025.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hi gophers and other fellow life forms.\n\nAbout 6 months ago we have started a new project that font-end side with `JS`/`Node.js`/`React` and back-end side  with `Golang`. I was working for the back-end side everything was O.K. But the project grows the `'encoding/json'` package get inefficient. For example we are not able to change a 'key' or change any value with something else. Thats because we switch to some custom packages for manipulating JSON. \n\nAt this point. I figure out 'How about I wrote a packege for JSON manipulating'\n\nAnd than I start working on it. But dealing with such a project was not easy.\n\nFirst I had to find a way to validate my result. Manually writing unit tests was impossible for large data. Thats because I started to integrate Node.js to this project for test-case creation and validation. And it worked perfectly.\n\nI use a continius integration platform for test automation. And wrote a detailed documentation on __[GoDoc](https://godoc.org/github.com/ecoshub/jin)__.\n\nAnd It has a cool gopher logo you should see :)\n\nWell today its finally ready for public release. \n\nName of this package is __[JIN](https://github.com/ecoshub/jin)__\n\nIt is super easy to use and much more important its super fast.\nI just want to share with this to you guys.\n\nLet's look at with an example.\n\n```go\n\t// this is the JSON we will work on\n\tdata := []byte(`{\"repo\":{\"name\":\"ecoshub/jin\"},\"others\":[\"jin\",\"dev.to\"]}`)\n```\nwe are going to try to access the 'dev.to' string in 'others' array.\n\n```go\n\t// In order to Unmarshal a JSON.\n\t// first we have to define those structs properly.\n\ttype Repository struct {\n\t\tName string \t\t`json:\"name\"`\n\t}\n\n\ttype Data struct {\n\t\tRepo   Repository \t`json:\"repo\"`\n\t\tOthers []string \t`json:\"others\"`\n\t}\n\t// an empty data struct\n\tvar newData Data\n\n\t// finally Unmarshaling.\n\terr := json.Unmarshal(data, &amp;newData)\n\n\t// standard error implementation.\n\tif err != nil {\n\t\tfmt.Println(\"error:\", err)\n\t}\n\tfmt.Prinln(newData.Others[1])\n\n```\nOr you can use this. with no struct defination.\n\n```go\n\t// just one line of code.\n\tvalue, err := jin.Get(data, \"others\", \"1\")\n\n\t// standard error implementation.\n\tif err != nil {\n\t\tfmt.Println(\"error:\", err)\n\t}\n\tfmt.Println(string(value))\n```\n\nDo not miss-understand me I am not the first person who figure out this simple and elegant definition. I am just trying to expand and improve JSON manipulation.\n\nThis package has over __90__ functions/methods for ease JSON manipulation, build and formating needs. Some useful functions that i like to mention.\n \n-`Add()`, `AddKeyValue()`, `Set()`, `SetKey()` `Delete()`, `Insert()`, `IterateArray()`, `IterateKeyValue()` `Tree()`. \n\nThere is a very detailed explanations and lots of examples in __[GoDoc](https://godoc.org/github.com/ecoshub/jin)__ .\n\nAlso I think you have to  check out benchmark results :)\n\nThis is the link of repository:\nhttps://github.com/ecoshub/jin\n\nPlease do not hesitate to fork/clone pull-request.\n\nThank you so much for your time.\n\nHave a good day.", "author_fullname": "t2_52fkxbb3", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "New JSON parser/interpreter", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f1k1mt", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 5, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 5, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1581336908.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581332780.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hi gophers and other fellow life forms.&lt;/p&gt;\n\n&lt;p&gt;About 6 months ago we have started a new project that font-end side with &lt;code&gt;JS&lt;/code&gt;/&lt;code&gt;Node.js&lt;/code&gt;/&lt;code&gt;React&lt;/code&gt; and back-end side  with &lt;code&gt;Golang&lt;/code&gt;. I was working for the back-end side everything was O.K. But the project grows the &lt;code&gt;&amp;#39;encoding/json&amp;#39;&lt;/code&gt; package get inefficient. For example we are not able to change a &amp;#39;key&amp;#39; or change any value with something else. Thats because we switch to some custom packages for manipulating JSON. &lt;/p&gt;\n\n&lt;p&gt;At this point. I figure out &amp;#39;How about I wrote a packege for JSON manipulating&amp;#39;&lt;/p&gt;\n\n&lt;p&gt;And than I start working on it. But dealing with such a project was not easy.&lt;/p&gt;\n\n&lt;p&gt;First I had to find a way to validate my result. Manually writing unit tests was impossible for large data. Thats because I started to integrate Node.js to this project for test-case creation and validation. And it worked perfectly.&lt;/p&gt;\n\n&lt;p&gt;I use a continius integration platform for test automation. And wrote a detailed documentation on &lt;strong&gt;&lt;a href=\"https://godoc.org/github.com/ecoshub/jin\"&gt;GoDoc&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;And It has a cool gopher logo you should see :)&lt;/p&gt;\n\n&lt;p&gt;Well today its finally ready for public release. &lt;/p&gt;\n\n&lt;p&gt;Name of this package is &lt;strong&gt;&lt;a href=\"https://github.com/ecoshub/jin\"&gt;JIN&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;It is super easy to use and much more important its super fast.\nI just want to share with this to you guys.&lt;/p&gt;\n\n&lt;p&gt;Let&amp;#39;s look at with an example.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;go\n    // this is the JSON we will work on\n    data := []byte(`{&amp;quot;repo&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;ecoshub/jin&amp;quot;},&amp;quot;others&amp;quot;:[&amp;quot;jin&amp;quot;,&amp;quot;dev.to&amp;quot;]}`)\n&lt;/code&gt;\nwe are going to try to access the &amp;#39;dev.to&amp;#39; string in &amp;#39;others&amp;#39; array.&lt;/p&gt;\n\n&lt;p&gt;``&lt;code&gt;go\n    // In order to Unmarshal a JSON.\n    // first we have to define those structs properly.\n    type Repository struct {\n        Name string&lt;/code&gt;json:&amp;quot;name&amp;quot;`\n    }&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Data struct {\n    Repo   Repository   `json:&amp;quot;repo&amp;quot;`\n    Others []string     `json:&amp;quot;others&amp;quot;`\n}\n// an empty data struct\nvar newData Data\n\n// finally Unmarshaling.\nerr := json.Unmarshal(data, &amp;amp;newData)\n\n// standard error implementation.\nif err != nil {\n    fmt.Println(&amp;quot;error:&amp;quot;, err)\n}\nfmt.Prinln(newData.Others[1])\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;```\nOr you can use this. with no struct defination.&lt;/p&gt;\n\n&lt;p&gt;```go\n    // just one line of code.\n    value, err := jin.Get(data, &amp;quot;others&amp;quot;, &amp;quot;1&amp;quot;)&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// standard error implementation.\nif err != nil {\n    fmt.Println(&amp;quot;error:&amp;quot;, err)\n}\nfmt.Println(string(value))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;```&lt;/p&gt;\n\n&lt;p&gt;Do not miss-understand me I am not the first person who figure out this simple and elegant definition. I am just trying to expand and improve JSON manipulation.&lt;/p&gt;\n\n&lt;p&gt;This package has over &lt;strong&gt;90&lt;/strong&gt; functions/methods for ease JSON manipulation, build and formating needs. Some useful functions that i like to mention.&lt;/p&gt;\n\n&lt;p&gt;-&lt;code&gt;Add()&lt;/code&gt;, &lt;code&gt;AddKeyValue()&lt;/code&gt;, &lt;code&gt;Set()&lt;/code&gt;, &lt;code&gt;SetKey()&lt;/code&gt; &lt;code&gt;Delete()&lt;/code&gt;, &lt;code&gt;Insert()&lt;/code&gt;, &lt;code&gt;IterateArray()&lt;/code&gt;, &lt;code&gt;IterateKeyValue()&lt;/code&gt; &lt;code&gt;Tree()&lt;/code&gt;. &lt;/p&gt;\n\n&lt;p&gt;There is a very detailed explanations and lots of examples in &lt;strong&gt;&lt;a href=\"https://godoc.org/github.com/ecoshub/jin\"&gt;GoDoc&lt;/a&gt;&lt;/strong&gt; .&lt;/p&gt;\n\n&lt;p&gt;Also I think you have to  check out benchmark results :)&lt;/p&gt;\n\n&lt;p&gt;This is the link of repository:\n&lt;a href=\"https://github.com/ecoshub/jin\"&gt;https://github.com/ecoshub/jin&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Please do not hesitate to fork/clone pull-request.&lt;/p&gt;\n\n&lt;p&gt;Thank you so much for your time.&lt;/p&gt;\n\n&lt;p&gt;Have a good day.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f1k1mt", "is_robot_indexable": true, "report_reasons": null, "author": "eco9999", "discussion_type": null, "num_comments": 8, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/f1k1mt/new_json_parserinterpreter/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/f1k1mt/new_json_parserinterpreter/", "subreddit_subscribers": 102312, "created_utc": 1581303980.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_f1k1mt", "before": null}}