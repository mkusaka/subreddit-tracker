{"kind": "Listing", "data": {"modhash": "", "dist": 12, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "Rules For Individuals\n---------------------\n\n* **Don't** create top-level comments - those are for employers.\n* Feel free to reply to top-level comments with **on-topic** questions.\n* I will create one top-level comment for **meta** discussion.\n* I will create another top-level comment for **individuals looking for work** and **community groups looking for sponsors**.\n\nRules For Employers\n---------------------\n\n* You must be hiring **directly**. No third-party recruiters.\n* **One** top-level comment per employer. If you have multiple job openings, that's great, but please consolidate their descriptions or mention them in replies to your own top-level comment.\n* **Don't** use URL shorteners. [reddiquette](https://www.reddithelp.com/en/categories/reddit-101/reddit-basics/reddiquette) forbids them because they're opaque to the spam filter.\n* Templates are awesome. Please **use** the following template. As the \"formatting help\" says, use \\*\\*two stars\\*\\* to **bold text**. Use empty lines to separate sections.\n* **Proofread** your comment after posting it, and edit any formatting mistakes.\n\n---\n\n\\*\\*Company:\\*\\* [Company name; also, use the \"formatting help\" to make it a link to your company's website, or a specific careers page if you have one.]\n\n&amp;nbsp;\n\n\\*\\*Type:\\*\\* [Full time, part time, internship, contract, etc.]\n\n&amp;nbsp;\n\n\\*\\*Description:\\*\\* [What does your company do, and what are you hiring C++ devs for? How much experience are you looking for, and what seniority levels are you hiring for? The more details you provide, the better.]\n\n&amp;nbsp;\n\n\\*\\*Location:\\*\\* [Where's your office - or if you're hiring at multiple offices, list them. If your workplace language isn't English, please specify it.]\n\n&amp;nbsp;\n\n\\*\\*Remote:\\*\\* [Do you offer the option of working remotely? If so, do you require employees to live in certain areas or time zones?]\n\n&amp;nbsp;\n\n\\*\\*Visa Sponsorship:\\*\\* [Does your company sponsor visas?]\n\n&amp;nbsp;\n\n\\*\\*Technologies:\\*\\* [Required: do you mainly use C++98/03, C++11, C++14, C++17, or the C++20 working draft? Optional: do you use Linux/Mac/Windows, are there languages you use in addition to C++, are there technologies like OpenGL or libraries like Boost that you need/want/like experience with, etc.]\n\n&amp;nbsp;\n\n\\*\\*Contact:\\*\\* [How do you want to be contacted? Email, reddit PM, telepathy, gravitational waves?]\n\n---\n\nPrevious Post\n--------------\n\n* [C++ Jobs - Q4 2019](https://www.reddit.com/r/cpp/comments/dbqgbw/c_jobs_q4_2019/)", "author_fullname": "t2_21c1y", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "C++ Jobs - Q1 2020", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_eiila4", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": "", "subreddit_type": "public", "ups": 190, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 190, "approved_by": null, "author_premium": true, "thumbnail": "", "edited": 1579038018.0, "author_flair_css_class": "", "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1577915953.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;h2&gt;Rules For Individuals&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Don&amp;#39;t&lt;/strong&gt; create top-level comments - those are for employers.&lt;/li&gt;\n&lt;li&gt;Feel free to reply to top-level comments with &lt;strong&gt;on-topic&lt;/strong&gt; questions.&lt;/li&gt;\n&lt;li&gt;I will create one top-level comment for &lt;strong&gt;meta&lt;/strong&gt; discussion.&lt;/li&gt;\n&lt;li&gt;I will create another top-level comment for &lt;strong&gt;individuals looking for work&lt;/strong&gt; and &lt;strong&gt;community groups looking for sponsors&lt;/strong&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h2&gt;Rules For Employers&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;You must be hiring &lt;strong&gt;directly&lt;/strong&gt;. No third-party recruiters.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;One&lt;/strong&gt; top-level comment per employer. If you have multiple job openings, that&amp;#39;s great, but please consolidate their descriptions or mention them in replies to your own top-level comment.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Don&amp;#39;t&lt;/strong&gt; use URL shorteners. &lt;a href=\"https://www.reddithelp.com/en/categories/reddit-101/reddit-basics/reddiquette\"&gt;reddiquette&lt;/a&gt; forbids them because they&amp;#39;re opaque to the spam filter.&lt;/li&gt;\n&lt;li&gt;Templates are awesome. Please &lt;strong&gt;use&lt;/strong&gt; the following template. As the &amp;quot;formatting help&amp;quot; says, use **two stars** to &lt;strong&gt;bold text&lt;/strong&gt;. Use empty lines to separate sections.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Proofread&lt;/strong&gt; your comment after posting it, and edit any formatting mistakes.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;**Company:** [Company name; also, use the &amp;quot;formatting help&amp;quot; to make it a link to your company&amp;#39;s website, or a specific careers page if you have one.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Type:** [Full time, part time, internship, contract, etc.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Description:** [What does your company do, and what are you hiring C++ devs for? How much experience are you looking for, and what seniority levels are you hiring for? The more details you provide, the better.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Location:** [Where&amp;#39;s your office - or if you&amp;#39;re hiring at multiple offices, list them. If your workplace language isn&amp;#39;t English, please specify it.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Remote:** [Do you offer the option of working remotely? If so, do you require employees to live in certain areas or time zones?]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Visa Sponsorship:** [Does your company sponsor visas?]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Technologies:** [Required: do you mainly use C++98/03, C++11, C++14, C++17, or the C++20 working draft? Optional: do you use Linux/Mac/Windows, are there languages you use in addition to C++, are there technologies like OpenGL or libraries like Boost that you need/want/like experience with, etc.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Contact:** [How do you want to be contacted? Email, reddit PM, telepathy, gravitational waves?]&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h2&gt;Previous Post&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://www.reddit.com/r/cpp/comments/dbqgbw/c_jobs_q4_2019/\"&gt;C++ Jobs - Q4 2019&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": "new", "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": "MSVC STL Dev", "visited": false, "removed_by": null, "num_reports": null, "distinguished": "moderator", "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "eiila4", "is_robot_indexable": true, "report_reasons": null, "author": "STL", "discussion_type": null, "num_comments": 78, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": "dark", "permalink": "/r/cpp/comments/eiila4/c_jobs_q1_2020/", "parent_whitelist_status": "all_ads", "stickied": true, "url": "https://www.reddit.com/r/cpp/comments/eiila4/c_jobs_q1_2020/", "subreddit_subscribers": 121680, "created_utc": 1577887153.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "**C++20, the most impactful revision of C++ in a decade, is done!** \ud83c\udf89\ud83c\udf8a\ud83e\udd73\n\nAt the ISO C++ Committee meeting in Prague \ud83c\udde8\ud83c\uddff, hosted by [Avast](https://www.avast.com/), we completed the C++20 Committee Draft and voted to send the Draft International Standard (DIS) out for final approval and publication. Procedurally, it's possible that the DIS could be rejected, but due to our procedures and process, it's very unlikely to happen. This means that C++20 is complete, and in a few months the standard will be published.\n\nDuring this meeting, we also [adopted a plan for C++23](https://wg21.link/P0592), which includes prioritizing a modular standard library, library support for coroutines, executors, and networking.\n\nA big thanks to everyone who made C++20 happen - the proposal authors, the minute takers, the implementers, and everyone else involved!\n\n[This was the largest C++ committee meeting ever - 252 people attended!](https://i.imgur.com/umP0qke.jpg) Our generous host, [Avast](https://www.avast.com/), did an amazing job hosting the meeting and also organized a lovely evening event for everyone attending.\n\n&amp;nbsp;\n\nThis week, we made the following changes and additions to the C++20 draft:\n\n- [Improved the context-sensitive recognition of 'module' and 'import' to make it easier for non-compiler tools such as build systems to determine build dependencies](https://wg21.link/P1857).\n- Added [several new rangified algorithms](https://wg21.link/p1243).\n- Added [`ranges::ssize`](https://wg21.link/p1970).\n- Refined the meaning of 'static' and 'inline' in module interfaces ([P1779](https://wg21.link/P1779) and [P1815](https://wg21.link/P1815)).\n- Resolved a lot of open core language and library issues and made many substantial improvements to specification.\n\n&amp;nbsp;\n\nThe following notable features are in C++20:\n\n- [**Modules**](https://en.cppreference.com/w/cpp/language/modules).\n- [**Coroutines**](https://en.cppreference.com/w/cpp/language/coroutines).\n- [**Concepts**](https://en.cppreference.com/w/cpp/concepts).\n- [**Ranges**](https://en.cppreference.com/w/cpp/ranges).\n- **`constexpr`ification: [`constinit`](https://wg21.link/P1143), [`consteval`](https://wg21.link/P1073), [`std::is_constant_evaluated`](https://wg21.link/P0595), [`constexpr` allocation](https://wg21.link/P0784), [`constexpr` `std::vector`](https://wg21.link/P1004), [`constexpr` `std::string`](https://wg21.link/P0980), [`constexpr` `union`](https://wg21.link/P1330), [`constexpr` `try` and `catch`](https://wg21.link/P1002), [`constexpr` `dynamic_cast` and `typeid`](https://wg21.link/P1327).**\n- **[`std::format(\"For C++{}\", 20)`](https://wg21.link/P0645).**\n-  [**`operator&lt;=&gt;`**](https://en.cppreference.com/w/cpp/utility#Relational_operators_and_comparison).\n- [Feature test macros](https://en.cppreference.com/w/cpp/feature_test).\n- [`std::span`](https://en.cppreference.com/w/cpp/container/span).\n- [Synchronized output](https://en.cppreference.com/w/cpp/io#Synchronized_output).\n- [`std::source_location`](https://wg21.link/P1208).\n- [`std::atomic_ref`](https://en.cppreference.com/w/cpp/atomic/atomic_ref).\n- [`std::atomic::wait`, `std::atomic::notify`, `std::latch`, `std::barrier`, `std::counting_semaphore`, etc](https://wg21.link/P1135).\n- [`std::jthread` and `std::stop_*`](https://wg21.link/P0660).\n\n&amp;nbsp;\n\n****\n\n# ABI Discussion\n\n****\n\nWe had a very important discussion about [ABI stability and the priorities of C++](https://wg21.link/P1863) this week in a joint session of the Language Evolution and Library Evolution group.\n\nAlthough there was strong interest in exploring how to evolve ABI in the future, we are not pursuing making C++23 a clean ABI breaking release at this time. We did, however, affirm that authors should be encouraged to bring individual papers for consideration, even if those would be an ABI break. Many in the committee are interested in considering targeted ABI breaks when that would signify significant performance gains.\n\n&gt;\n&gt; \u201fHow many C++ developers does it take to change a lightbulb?\u201d \u2014 [@tvaneerd](https://twitter.com/tvaneerd/status/1060646821247119360)\n&gt;\n&gt; \u201fNone: changing the light bulb is an ABI break.\u201d \u2014 [@LouisDionne](https://twitter.com/LouisDionne/status/1062724316905775106)\n&gt;\n\n&amp;nbsp;\n\n*****\n\n# Language Progress\n\n*****\n\n### Evolution Working Group Incubator (EWGI) Progress\n\n*****\n\nThe EWG Incubator met for three days in Prague and looked at and gave feedback to 22 papers for C++23. 10 of those papers were forwarded to Evolution, possibly with some revisions requested. Notably:\n\n- [Guaranteed copy elision for named return objects](https://wg21.link/p2025)\n- [Generalized pack declaration and usage](https://wg21.link/P1858)\n- [Member templates for local classes](https://wg21.link/p2044)\n- [Object relocation in terms of move plus destroy](https://wg21.link/p1144)\n\nSeveral papers received a lot of feedback and will return to the Incubator, hopefully in Varna:\n\n- [A pipeline-rewrite operator](https://wg21.link/P2011)\n- [Universal template parameters](https://wg21.link/P1985)\n- [Partially mutable lambda captures](https://wg21.link/p2034)\n- [C++ should support just-in-time compilation](https://wg21.link/p1609)\n- [`move = bitcopies`](https://wg21.link/P1029)\n- [Partially mutable lambda captures](https://wg21.link/P2034)\n\nNotably, [the proposed epochs language facility](https://wg21.link/p1881) received no consensus to proceed. One significant problem pointed out was that in a concepts and modules world, we really cannot make any language changes that may change the satisfaction of a concept for a set of types. If one TU thinks `C&lt;T&gt;` is true, but another TU in a later epoch thinks `C&lt;T&gt;` is false, that easily leads to ODR violations. Many of the suggested changes in the paper run afoul of this problem. However, we\u2019re interested in solving the problem, so welcome an alternative approach.\n\n*****\n\n### Evolution Working Group (EWG) Progress\n\n*****\n\nThe top priority of EWG was again fixing the final national body comments for C++20. Once that was done, we started looking at C++23 papers. We saw a total of 36 papers.\n\nPapers of note:\n\n* We adopted the [C++ IS schedule](https://wg21.link/P1000).\n* We adopted a [plan for C++23](https://wg21.link/P0592).\n* We adopted a [process for evolutionary proposals](https://wg21.link/P1999), to make sure that we reduce the chance that we\u2019ll make mistakes\n* We agreed to pursue the Undefined Behavior group\u2019s effort to [document Core Undefined or Unspecified Behavior](https://wg21.link/P2118) going forward. They\u2019re documenting all language undefined behavior that C++ contains today, and we agreed to document and justify any new language undefined behavior going forward.\n\nWe marked 3 papers as tentatively ready for C++23:\n\n* [Make declaration order layout mandated](https://wg21.link/P1847)\n* [Guaranteed copy elision for named return objects](https://wg21.link/P2025)\n* [C++ Identifier Syntax using Unicode Standard Annex 31](https://wg21.link/P1949)\n\nThey\u2019ll proceed to the Core language group at the next meeting if no issues are raised with these papers.\n\nWe continued reviewing [pattern matching](https://wg21.link/p1371). This is one of our top priorities going forward. It\u2019s looking better and better as we explore the design space and figure out how all the corner cases should work. One large discussion point at the moment is what happens when no match occurs, and whether we should mandate exhaustiveness. There\u2019s exploration around the expression versus statement form. We\u2019re looking for implementation experience to prove the design.\n\nWe really liked [deducing `this`](https://wg21.link/P0847), a proposal that eliminates the boilerplate associated with having `const` and non-`const`, `&amp;` and `&amp;&amp;` member function overloads. It still needs wording and implementation experience, but has strong support.\n\nWe continue discussing floating-point [fixed-layout types](https://wg21.link/P1468) and [extended floating point types](https://wg21.link/P1467), which are mandating IEEE 754 support for the new C++ `float16_t`, `float32_t`, `float64_t`, and adding support for `bfloat16_t`.\n\n[`std::embed`](https://wg21.link/P1040), which allows embedding strings from files, is making good progress.\n\nIn collaboration with the Unicode group, [named universal character escapes](https://wg21.link/P2071) got strong support.\n\n[`if consteval`](https://wg21.link/P1938) was reviewed. We\u2019re not sure this is exactly the right solution, but we\u2019re interested in solving problems in this general area.\n\nWe saw a really cute paper on [deleting variable templates](https://wg21.link/P2041) and decided to expand its scope such that more things can be marked as `= delete` in the language. This will make C++ much more regular, and reduce the need for expert-only solutions to tricky problems.\n\n&amp;nbsp;\n\n*****\n\n### Core Working Group (CWG) Progress\n\n*****\n\nThe top priority of CWG was finishing processing national body comments for C++20. CWG spent most of its remaining time this week working through papers and issues improving the detailed specification for new C++20 features.\n\nWe finished reviewing four papers that fine-tune the semantics of modules:\n\n- We [clarified the meaning of `static`](https://wg21.link/p1815r2) (and unnamed namespaces) in module interfaces: such entities are now kept internal and cannot be exposed in the interface / ABI of the module. In non-modules compilations, we deprecated cases where internal-linkage entities are used from external-linkage entities. (These cases typically lead to violations of the One Definition Rule.)\n\n- We [clarified the meaning of `inline`](https://wg21.link/p1779r3) in module interfaces: the intent is that bodies of functions that are not explicitly declared `inline` are not part of the ABI of a module, even if those function bodies appear in the module interface. In order to give module authors more control over their ABI, member functions defined in class bodies in module interfaces are no longer implicitly `inline`.\n\n- We tweaked the context-sensitive recognition of the `module` and `import` keyword in order to avoid changing the meaning of more existing code that uses these identifiers, and to make it more straightforward for a scanning tool to recognize these declarations without full preprocessing.\n\n- We improved backwards compatibility with unnamed enumerations in legacy header files (particularly C header files). Such unnamed enumerations will now be properly merged across header files if they're reachable in multiple different ways via imports.\n\n- We finalized some subtle rules for concepts: a [syntax gotcha](https://wg21.link/p2092r0) in `requires` expressions was fixed, and we allowed [caching of concept values](https://wg21.link/p2104r0), which has been shown to dramatically improve performance in some cases.\n\n- We agreed to (retroactively, via the defect report process) [treat initialization of a `bool` from a pointer as narrowing](https://wg21.link/p2104r0), improving language safety.\n\n- We added permission for a comparison function to be defaulted outside its class, so long as the comparison function is a member or friend of the class, for consistency and to allow a defaulted comparison function to be non-inline.\n\n&amp;nbsp;\n\n*****\n\n# Library Progress\n\n*****\n\n### Library Evolution Working Group Incubator (LEWGI) Progress\n\n*****\n\nLEWGI met for three and a half days this week and reviewed 22 papers. Most of our work this week was on various numerics proposals during joint sessions with the Numerics group. A lot of this work may end up going into the proposed Numerics Technical Specification, whose [scope and goals we are working to define](https://wg21.link/P2004). We also spent a chunk of time working on [modern I/O](https://wg21.link/P1883) and concurrent data structures for the upcoming Concurrency Technical Specification Version 2.\n\nLEWGI looked at the following proposals, among others:\n\n- Numerics:\n  - [Physical Units Library](https://wg21.link/P1930).\n  - [Linear Algebra](https://wg21.link/P1385).\n- Concurrency:\n  - [Concurrent Queues](https://wg21.link/P1958).\n- Low-level File I/O\n  - [Mapped File Handle](https://wg21.link/P1883).\n- Narrowing Conversions\n  - [std::is_narrowing_conversion](https://wg21.link/P0870).\n  - [std::narrow_cast](https://wg21.link/P1998).\n- Random Numbers\n  - [Improving std::random_device](https://wg21.link/P2058).\n  - [Portable Distributions](https://wg21.link/P2059).\n  - [Improving Engine Seeding](https://wg21.link/P2059).\n\n&amp;nbsp;\n\n*****\n\n### Library Evolution Working Group (LEWG) Progress\n\n*****\n\nAfter handling the few remaining National Body comments to fix issues with C++20, LEWG focused on making general policy decisions about standard library design standards. For example, we [formally codified](https://wg21.link/P1851) the guidelines for concept names in the standard library, and clarified [SD-8](https://isocpp.org/std/standing-documents/sd-8-standard-library-compatibility), our document listing the compatibility guarantees we make to our users. Then we started looking at C++23 library proposals.\n\n[Moved-from objects need not be valid](https://wg21.link/P2027) generated much internal discussion in the weeks leading up to the meeting as well as at the meeting itself.  While the exact solution outlined in the paper wasn\u2019t adopted, we are tightening up the wording around algorithms on what operations are performed on objects that are temporarily put in the moved-from state during the execution of an algorithm.\n\nThe biggest C++23 news: LEWG spent an entire day with the concurrency experts of SG1 to review the [**executors** proposal](https://wg21.link/P0443) \u2014 we liked the direction! This is a huge step, which will enable **networking**, **audio**, **coroutine library support**, and more.\n\nOther C++23 proposals reviewed include\n\n- [a new `status_code` facility](https://wg21.link/P1208)\n- [an ability for containers and allocators to communicate about the actual allocation size](https://wg21.link/P0401)\n- [iterator range constructors for `std::stack` and `std::queue`](https://wg21.link/P1425)\n\nWe\u2019ve also decided to [deprecate `std::string`\u2019s assignment operator taking a `char`](https://wg21.link/P2037) (pending LWG).\n\n&amp;nbsp;\n\n*****\n\n### Library Working Group (LWG) Progress\n\n*****\n\nThe primary goals were to finish processing NB comments and to [rebase](https://wg21.link/P2081) the Library Fundamentals TS on C++20.  We met both of those goals.\n\nWe looked at all 48 open library-related NB comments and responded to them.  Some were accepted for C++20.  Some were accepted for C++20 with changes.  For some, we agreed with the problem but considered the fix to be too risky for C++20, so an issue was opened for consideration in C++23.  For many the response was \u201cNo consensus for change,\u201d which can mean a variety of things from \u201cthis is not really a problem\u201d to \u201cthe problem is not worth fixing.\u201d\n\nThe last of the [mandating papers](https://wg21.link/P1460) was reviewed and approved.  All of the standard library should now be cleaned up to use the latest [library wording guidelines](https://wg21.link/P1369), such as using \u201cMandates\u201d and \u201cConstraints\u201d clauses rather than \u201cRequires\u201d clauses.\n\nSome time was spent going through the LWG open issues list.  We dealt with all open P1 issues (\u201cmust fix for C++20\u201d).  Many of the open P2 issues related to new C++20 features were dealt with, in an attempt to fix bugs before we ship them.\n\nThis was Marshall Clow\u2019s last meeting as LWG chair.  He received a standing ovation in plenary.\n\n&amp;nbsp;\n\n*****\n\n### Concurrency and Parallelism Study Group (SG1) Progress\n\n*****\n\nSG1 focused on C++23 this week, primarily on driving executors, one of the major planned features on our roadmap. Executors is a foundational technology that we'll build all sorts of modern asynchronous facilities on top of, so it's important that we land it in the standard early in the C++23 cycle.\n\nAt this meeting, LEWG approved of the [executors](https://wg21.link/P0443R12) design, and asked  the authors to return with a full specification and wording for review at the next meeting.\n\nSG1 reviewed and approved of a [refinement](https://wg21.link/P2006R0) to the design of the sender/receiver concepts. This change unifies the lifetime model of coroutines and sender/receiver and allows us to statically eliminate the need for heap allocations for many kinds of async algorithms.\n\nGoing forward, SG1 will start working on proposals that build on top of executors, such as concurrent algorithms, parallel algorithms work, networking, asynchronous I/O, etc.\n\n&amp;nbsp;\n\n*****\n\n### Networking Study Group (SG4) Progress\n\n*****\n\nSG4 started processing review feedback on the [networking TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4771.pdf) aimed at modernizing it for inclusion in C++23. SG4 also reviewed a proposal to [unify low-level I/O with the high-level asynchronous abstractions](https://wg21.link/p2052) and gave feedback to the author.\n\n&amp;nbsp;\n\n*****\n\n### Numerics Study Group (SG6) Progress\n\n*****\n\nThe Numerics group met on Monday this week, and also jointly with LEWGI on Tuesday and Thursday, and with SG19 on Friday.\n\nWe reviewed papers on a number of topics, including:\n\n- [The scope and goals for the Numerics TS](https://wg21.link/P2004).\n- [Linear algebra](https://wg21.link/P1385).\n- [Units library](https://wg21.link/P1935).\n\n&amp;nbsp;\n\n*****\n\n### Compile-Time Programming Study Group (SG7) Progress\n\n*****\n\n[Circle](https://www.circle-lang.org/) is a fork of C++ that enables arbitrary compile-time execution (e.g. a compile-time `std::cout`), coupled with reflection to allow powerful meta-programming. SG7 was interested in it and [considered copying parts of it](https://wg21.link/P2043). However, concerns were [raised](https://wg21.link/P2062) about security and usability problems, so the ability to execute arbitrary code at compile-time was rejected.\n\nBesides that, we also continued to make progress on C++ reflection including naming of reflection keywords and potential to enable lazy evaluation of function arguments.\n\nWe also looked at [the JIT proposal](https://wg21.link/P1609) and asked authors to try to unify the design with current reflection proposals.\n\n&amp;nbsp;\n\n*****\n\n### Undefined Behavior Study Group (SG12)/Vulnerabilities Working Group (WG23) Progress\n\n*****\n\nWe set out to [enumerate all undefined and unspecified behavior](https://wg21.link/P1705). We\u2019ve decided that upcoming papers adding new undefined or unspecified behavior need to include rationale and examples.\n\nSG12 also collaborated with the [MISRA standard](https://www.misra.org.uk/)  for coding standards in embedded systems to help them update the guidelines for newer C++ revisions.\n\n&amp;nbsp;\n\n*****\n\n### Human Machine Interface and Input/Output Study Group (SG13) Progress\n\n*****\n\nSG13 had a brief presentation of extracts from the [2019 CppCon keynote](https://www.youtube.com/watch?v=5N4b-rU-OAA) featuring Ben Smith (from 1:05:00) \n\nWe looked at [A Brief 2D Graphics Review](http://wg21.link/P2005R0) and encouraged exploration of work towards a separable color proposal.\n\nFinally, we worked through the use cases in [Audio I/O Software Use Cases](http://wg21.link/P2054). We have a couple of weeks before the post meeting mailing deadline to collect additional use cases and will then solicit feedback on them from WG21 and the wider C++ community.\n\n&amp;nbsp;\n\n*****\n\n### Tooling Study Group (SG15) Progress\n\n*****\n\nThe Tooling study group met this week to continue work on the Module Ecosystem Technical Report. Three of the papers targeting the Technical Report are fairly mature at this point, so we've directed the authors of those papers to work together to create an initial draft of the Technical Report for the Varna meeting. Those papers are:\n\n- [Dependency Information Format](https://wg21.link/P1689) \n- [Module Recipe and BMI Reuse](https://wg21.link/P1788)\n- [User-Facing Lexicon and File Extensions](https://wg21.link/P1838)\n\nThis draft will give us a shared vehicle to start hammering out the details of the Technical Report, and a target for people to write papers against.\n\nWe also discussed two proposals, about [debugging C++ coroutines](https://wg21.link/P2073) and [asynchronous call stacks](https://wg21.link/P2074).\n\n&amp;nbsp;\n\n*****\n\n### Unicode and Text Study Group (SG16) Progress\n\n*****\n\nOur most interesting topic of the week concerned the interaction of execution character set and compile-time programming.  Proposed features for `std::embed` and reflection require the evaluation of strings at compile time and this occurs at translation phase 7.  This is after translation phase 5 in which character and string literals are converted to the execution character set.  These features require interaction with file names or the internal symbol table of a compiler.  In cross compilation scenarios in which the target execution character set is not compatible with the compiler\u2019s host system or internal encoding, interesting things happen.  As in so many other cases, we found an answer in UTF-8 and will be recommending that these facilities operate solely in UTF-8.\n\nWe forwarded [Named Universal Character Escapes](https://wg21.link/P2071) and [C++ Identifier Syntax using Unicode Standard Annex 31](https://wg21.link/P1949) to EWG.\nBoth papers were seen by EWG this week and are on track for approval for C++23 in meetings later this year.\n\nWe forwarded [Naming Text Encodings to Demystify Them](https://wg21.link/P1885) to LEWG.\n\nWe declined to forward a paper to enhance `std::regex` to better support Unicode due to severe ABI restrictions; the `std::regex` design exposes many internal details of the implementation to the ABI and implementers indicated that they cannot make any significant changes.  Given the current state of `std::regex` is such that we cannot fix either its interface or its well-known performance issues, a number of volunteers agreed to bring a paper to deprecate `std::regex` at a future meeting.\n\n&amp;nbsp;\n\n*****\n\n### Machine Learning Study Group (SG19) Progress\n\n*****\n\nSG19 met for a full day, one half day with SG14 (Low Latency), and one half day with SG6 (Numerics).\n\nSignificant feedback from a ML perspective was provided on [Simple Statistics functions](https://wg21.link/P1708), especially regarding the handling of missing data, non-numeric data, and various potential performance issues.\n\nThere was an excellent presentation of \"Review of P1708: Simple Statistical Functions\" which presented an analysis across Python, R, SAS and Matlab for common statistical methods.\n\nThe [graph library](http://wg21.link/P1709) paper had a great reaction, was also discussed, and will proceed.\n\nAlso, support for differentiable programming in C++, important for well-integrated support for ML back-propagation, was discussed in the context of [differentiable programming for C++](https://wg21.link/P2072).\n\nThe freestanding library took a few steps forward, with some interesting proposals, including [Freestanding Language: Optional `::operator new`](https://wg21.link/P2013R0)\n\nOne of the biggest decisions was on [Low-Cost Deterministic C++ Exceptions for Embedded Systems](https://www.research.ed.ac.uk/portal/files/78829292/low_cost_deterministic_C_exceptions_for_embedded_systems.pdf) which got great reactions. We will probably hear more about it!\n\n&amp;nbsp;\n\n*****\n\n### Contracts Study Group (SG21) Progress\n\n*****\n\nIn a half-day session, we discussed one of the major points of contention from previous proposals, which was the relationship between \u201cassume\u201d and \u201cassert\u201d, disentangling colloquial and technical interpretations. We also discussed when one implies the other, and which combinations a future facility should support.\n\n- [Previous Disagreements](https://wg21.link/P2076)\n- [Assumptions](https://wg21.link/P2064)\n- [Portable Assumptions](https://wg21.link/P1774)\n\n&amp;nbsp;\n\n*****\n\n# C++ Release Schedule\n\n*****\n\n***NOTE: This is a plan not a promise. Treat it as speculative and tentative. See [P1000](https://wg21.link/P1000) for the latest plan.***\n\n* IS = International Standard. The C++ programming language. C++11, C++14, C++17, etc.\n* TS = Technical Specification. \"Feature branches\" available on some but not all implementations. Coroutines TS v1, Modules TS v1, etc.\n* CD = Committee Draft. A draft of an IS/TS that is sent out to national standards bodies for review and feedback (\"beta testing\"). \n\nMeeting | Location | Objective\n-|-|-\n~~2018 Summer LWG Meeting~~ | ~~Chicago \ud83c\uddfa\ud83c\uddf8~~ | ~~Work on wording for C++20 features.~~\n~~2018 Fall EWG Modules Meeting~~ | ~~Seattle \ud83c\uddfa\ud83c\uddf8~~ | ~~Design modules for C++20.~~\n~~2018 Fall LEWG/SG1 Executors Meeting~~ | ~~Seattle \ud83c\uddfa\ud83c\uddf8~~ | ~~Design executors for C++20.~~\n~~2018 Fall Meeting~~ | ~~San Diego \ud83c\uddfa\ud83c\uddf8~~ | ~~C++20 major language feature freeze.~~\n~~2019 Spring Meeting~~ | ~~Kona \ud83c\uddfa\ud83c\uddf8~~ | ~~C++20 feature freeze. C++20 design is feature-complete.~~\n~~2019 Summer Meeting~~ | ~~Cologne \ud83c\udde9\ud83c\uddea~~ | ~~Complete C++20 CD wording. Start C++20 CD balloting (\"beta testing\").~~\n~~2019 Fall Meeting~~ | ~~Belfast \ud83c\uddec\ud83c\udde7~~ | ~~C++20 CD ballot comment resolution (\"bug fixes\").~~\n**2020 Spring Meeting** | **Prague \ud83c\udde8\ud83c\uddff** | **C++20 CD ballot comment resolution (\"bug fixes\"), C++20 completed.**\n2020 Summer Meeting | Varna \ud83c\udde7\ud83c\uddec | First meeting of C++23.\n2020 Fall Meeting | New York \ud83c\uddfa\ud83c\uddf8 | Design major C++23 features.\n2021 Winter Meeting | Kona \ud83c\uddfa\ud83c\uddf8 | Design major C++23 features.\n2021 Summer Meeting | Montr\u00e9al \ud83c\udde8\ud83c\udde6 \u269c\ufe0f | Design major C++23 features.\n2021 Fall Meeting | \ud83d\uddfa\ufe0f | C++23 major language feature freeze.\n2022 Spring Meeting | Portland \ud83c\uddfa\ud83c\uddf8 | C++23 feature freeze. C++23 design is feature-complete.\n2022 Summer Meeting | \ud83d\uddfa\ufe0f | Complete C++23 CD wording. Start C++23 CD balloting (\"beta testing\").\n2022 Fall Meeting | \ud83d\uddfa\ufe0f | C++23 CD ballot comment resolution (\"bug fixes\").\n2023 Spring Meeting | \ud83d\uddfa\ufe0f | C++23 CD ballot comment resolution (\"bug fixes\"), C++23 completed.\n2023 Summer Meeting | \ud83d\uddfa\ufe0f | First meeting of C++26.\n\n&amp;nbsp;\n\n*****\n\n# Status of Major C++ Feature Development\n\n*****\n\n***NOTE: This is a plan not a promise. Treat it as speculative and tentative.***\n\n* IS = International Standard. The C++ programming language. C++11, C++14, C++17, etc.\n* TS = Technical Specification. \"Feature branches\" available on some but not all implementations. Coroutines TS v1, Modules TS v1, etc.\n* CD = Committee Draft. A draft of an IS/TS that is sent out to national standards bodies for review and feedback (\"beta testing\"). \n\n**Changes since last meeting are in bold.**\n\nFeature | Status | Depends On | Current Target (Conservative Estimate) | Current Target (Optimistic Estimate)\n-|-|-|-|-\n[Concepts](https://en.cppreference.com/w/cpp/language/constraints) | Concepts TS v1 published and merged into C++20 | | C++20 | C++20\n[Ranges](https://en.cppreference.com/w/cpp/experimental/ranges) | Ranges TS v1 published and merged into C++20 | Concepts | C++20 | C++20\n[Modules](https://wg21.link/P1103) | Merged design approved for C++20 | | C++20 | C++20\n[Coroutines](https://wg21.link/N4723) | Coroutines TS v1 published and merged into C++20 | | C++20 | C++20\n[Executors](https://wg21.link/P1658) | New compromise design approved for C++23 | | C++26 | **C++23 (Planned)**\n[Contracts](https://wg21.link/P0542) | Moved to Study Group | | C++26 | C++23\n[Networking](https://wg21.link/N4711) | Networking TS v1 published | Executors | C++26 | **C++23 (Planned)**\n[Reflection](https://wg21.link/P0194) | Reflection TS v1 published | | C++26 |C++23\n[Pattern Matching](https://wg21.link/P1371) | | | C++26 | C++23\n**[Modularized Standard Library](https://wg21.link/P1453)** | | | **C++23** | **C++23 (Planned)**\n\n&amp;nbsp;\n\n[**Last Meeting's Reddit Trip Report.**](https://www.eddit.com/r/cpp/comments/dtuov8/201911_belfast_iso_c_committee_trip_report/)\n\n&amp;nbsp;\n\n**If you have any questions, ask them in this thread!**\n\n&amp;nbsp;\n\n&amp;nbsp;\n\n*/u/blelbach, Tooling (SG15) Chair, Library Evolution Incubator (SG18) Chair*\n\n*/u/bigcheesegs*\n\n*/u/c0r3ntin*\n\n*/u/jfbastien, Evolution (EWG) Chair*\n\n*/u/arkethos (aka code_report)*\n\n*/u/vulder*\n\n*/u/hanickadot, Compile-Time Programming (SG7) Chair*\n\n*/u/tahonermann, Text and Unicode (SG16) Chair*\n\n*/u/cjdb-ns, Education (SG20) Lieutenant*\n\n*/u/nliber*\n\n*/u/sphere991*\n\n*/u/tituswinters, Library Evolution (LEWG) Chair*\n\n*/u/HalFinkel, US National Body (PL22.16) Vice Chair*\n\n*/u/ErichKeane, Evolution Incubator (SG17) Assistant Chair*\n\n*/u/sempuki*\n\n*/u/ckennelly*\n\n*/u/mathstuf*\n\n*/u/david-stone, Modules (SG2) Chair and Evolution (EWG) Vice Chair*\n\n*/u/je4d, Networking (SG4) Chair*\n\n*/u/FabioFracassi, German National Body Chair*\n\n*/u/redbeard0531*\n\n*/u/nliber*\n\n*/u/foonathan*\n\n*/u/InbalL, Israel National Body Chair*\n\n*/u/zygoloid, C++ Project Editor*\n\n*\u22ef and others \u22ef*", "author_fullname": "t2_f77gj", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "2020-02 Prague ISO C++ Committee Trip Report \u2014 \ud83c\udf89 C++20 is Done! \ud83c\udf89", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f47x4o", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 634, "total_awards_received": 1, "media_embed": {}, "author_flair_template_id": "7bf857c8-4dcc-11e6-b84d-0e5fbba92363", "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 634, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1581793803.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {"gid_1": 1}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581792749.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;strong&gt;C++20, the most impactful revision of C++ in a decade, is done!&lt;/strong&gt; \ud83c\udf89\ud83c\udf8a\ud83e\udd73&lt;/p&gt;\n\n&lt;p&gt;At the ISO C++ Committee meeting in Prague \ud83c\udde8\ud83c\uddff, hosted by &lt;a href=\"https://www.avast.com/\"&gt;Avast&lt;/a&gt;, we completed the C++20 Committee Draft and voted to send the Draft International Standard (DIS) out for final approval and publication. Procedurally, it&amp;#39;s possible that the DIS could be rejected, but due to our procedures and process, it&amp;#39;s very unlikely to happen. This means that C++20 is complete, and in a few months the standard will be published.&lt;/p&gt;\n\n&lt;p&gt;During this meeting, we also &lt;a href=\"https://wg21.link/P0592\"&gt;adopted a plan for C++23&lt;/a&gt;, which includes prioritizing a modular standard library, library support for coroutines, executors, and networking.&lt;/p&gt;\n\n&lt;p&gt;A big thanks to everyone who made C++20 happen - the proposal authors, the minute takers, the implementers, and everyone else involved!&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://i.imgur.com/umP0qke.jpg\"&gt;This was the largest C++ committee meeting ever - 252 people attended!&lt;/a&gt; Our generous host, &lt;a href=\"https://www.avast.com/\"&gt;Avast&lt;/a&gt;, did an amazing job hosting the meeting and also organized a lovely evening event for everyone attending.&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;This week, we made the following changes and additions to the C++20 draft:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1857\"&gt;Improved the context-sensitive recognition of &amp;#39;module&amp;#39; and &amp;#39;import&amp;#39; to make it easier for non-compiler tools such as build systems to determine build dependencies&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;Added &lt;a href=\"https://wg21.link/p1243\"&gt;several new rangified algorithms&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;Added &lt;a href=\"https://wg21.link/p1970\"&gt;&lt;code&gt;ranges::ssize&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;Refined the meaning of &amp;#39;static&amp;#39; and &amp;#39;inline&amp;#39; in module interfaces (&lt;a href=\"https://wg21.link/P1779\"&gt;P1779&lt;/a&gt; and &lt;a href=\"https://wg21.link/P1815\"&gt;P1815&lt;/a&gt;).&lt;/li&gt;\n&lt;li&gt;Resolved a lot of open core language and library issues and made many substantial improvements to specification.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;The following notable features are in C++20:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://en.cppreference.com/w/cpp/language/modules\"&gt;&lt;strong&gt;Modules&lt;/strong&gt;&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://en.cppreference.com/w/cpp/language/coroutines\"&gt;&lt;strong&gt;Coroutines&lt;/strong&gt;&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://en.cppreference.com/w/cpp/concepts\"&gt;&lt;strong&gt;Concepts&lt;/strong&gt;&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://en.cppreference.com/w/cpp/ranges\"&gt;&lt;strong&gt;Ranges&lt;/strong&gt;&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;&lt;code&gt;constexpr&lt;/code&gt;ification: &lt;a href=\"https://wg21.link/P1143\"&gt;&lt;code&gt;constinit&lt;/code&gt;&lt;/a&gt;, &lt;a href=\"https://wg21.link/P1073\"&gt;&lt;code&gt;consteval&lt;/code&gt;&lt;/a&gt;, &lt;a href=\"https://wg21.link/P0595\"&gt;&lt;code&gt;std::is_constant_evaluated&lt;/code&gt;&lt;/a&gt;, &lt;a href=\"https://wg21.link/P0784\"&gt;&lt;code&gt;constexpr&lt;/code&gt; allocation&lt;/a&gt;, &lt;a href=\"https://wg21.link/P1004\"&gt;&lt;code&gt;constexpr&lt;/code&gt; &lt;code&gt;std::vector&lt;/code&gt;&lt;/a&gt;, &lt;a href=\"https://wg21.link/P0980\"&gt;&lt;code&gt;constexpr&lt;/code&gt; &lt;code&gt;std::string&lt;/code&gt;&lt;/a&gt;, &lt;a href=\"https://wg21.link/P1330\"&gt;&lt;code&gt;constexpr&lt;/code&gt; &lt;code&gt;union&lt;/code&gt;&lt;/a&gt;, &lt;a href=\"https://wg21.link/P1002\"&gt;&lt;code&gt;constexpr&lt;/code&gt; &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt;&lt;/a&gt;, &lt;a href=\"https://wg21.link/P1327\"&gt;&lt;code&gt;constexpr&lt;/code&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; and &lt;code&gt;typeid&lt;/code&gt;&lt;/a&gt;.&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;&lt;a href=\"https://wg21.link/P0645\"&gt;&lt;code&gt;std::format(&amp;quot;For C++{}&amp;quot;, 20)&lt;/code&gt;&lt;/a&gt;.&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt; &lt;a href=\"https://en.cppreference.com/w/cpp/utility#Relational_operators_and_comparison\"&gt;&lt;strong&gt;&lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://en.cppreference.com/w/cpp/feature_test\"&gt;Feature test macros&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://en.cppreference.com/w/cpp/container/span\"&gt;&lt;code&gt;std::span&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://en.cppreference.com/w/cpp/io#Synchronized_output\"&gt;Synchronized output&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1208\"&gt;&lt;code&gt;std::source_location&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://en.cppreference.com/w/cpp/atomic/atomic_ref\"&gt;&lt;code&gt;std::atomic_ref&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1135\"&gt;&lt;code&gt;std::atomic::wait&lt;/code&gt;, &lt;code&gt;std::atomic::notify&lt;/code&gt;, &lt;code&gt;std::latch&lt;/code&gt;, &lt;code&gt;std::barrier&lt;/code&gt;, &lt;code&gt;std::counting_semaphore&lt;/code&gt;, etc&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P0660\"&gt;&lt;code&gt;std::jthread&lt;/code&gt; and &lt;code&gt;std::stop_*&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h1&gt;ABI Discussion&lt;/h1&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;We had a very important discussion about &lt;a href=\"https://wg21.link/P1863\"&gt;ABI stability and the priorities of C++&lt;/a&gt; this week in a joint session of the Language Evolution and Library Evolution group.&lt;/p&gt;\n\n&lt;p&gt;Although there was strong interest in exploring how to evolve ABI in the future, we are not pursuing making C++23 a clean ABI breaking release at this time. We did, however, affirm that authors should be encouraged to bring individual papers for consideration, even if those would be an ABI break. Many in the committee are interested in considering targeted ABI breaks when that would signify significant performance gains.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;\u201fHow many C++ developers does it take to change a lightbulb?\u201d \u2014 &lt;a href=\"https://twitter.com/tvaneerd/status/1060646821247119360\"&gt;@tvaneerd&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;\u201fNone: changing the light bulb is an ABI break.\u201d \u2014 &lt;a href=\"https://twitter.com/LouisDionne/status/1062724316905775106\"&gt;@LouisDionne&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h1&gt;Language Progress&lt;/h1&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Evolution Working Group Incubator (EWGI) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;The EWG Incubator met for three days in Prague and looked at and gave feedback to 22 papers for C++23. 10 of those papers were forwarded to Evolution, possibly with some revisions requested. Notably:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/p2025\"&gt;Guaranteed copy elision for named return objects&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1858\"&gt;Generalized pack declaration and usage&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/p2044\"&gt;Member templates for local classes&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/p1144\"&gt;Object relocation in terms of move plus destroy&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Several papers received a lot of feedback and will return to the Incubator, hopefully in Varna:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P2011\"&gt;A pipeline-rewrite operator&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1985\"&gt;Universal template parameters&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/p2034\"&gt;Partially mutable lambda captures&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/p1609\"&gt;C++ should support just-in-time compilation&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1029\"&gt;&lt;code&gt;move = bitcopies&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P2034\"&gt;Partially mutable lambda captures&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Notably, &lt;a href=\"https://wg21.link/p1881\"&gt;the proposed epochs language facility&lt;/a&gt; received no consensus to proceed. One significant problem pointed out was that in a concepts and modules world, we really cannot make any language changes that may change the satisfaction of a concept for a set of types. If one TU thinks &lt;code&gt;C&amp;lt;T&amp;gt;&lt;/code&gt; is true, but another TU in a later epoch thinks &lt;code&gt;C&amp;lt;T&amp;gt;&lt;/code&gt; is false, that easily leads to ODR violations. Many of the suggested changes in the paper run afoul of this problem. However, we\u2019re interested in solving the problem, so welcome an alternative approach.&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Evolution Working Group (EWG) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;The top priority of EWG was again fixing the final national body comments for C++20. Once that was done, we started looking at C++23 papers. We saw a total of 36 papers.&lt;/p&gt;\n\n&lt;p&gt;Papers of note:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;We adopted the &lt;a href=\"https://wg21.link/P1000\"&gt;C++ IS schedule&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;We adopted a &lt;a href=\"https://wg21.link/P0592\"&gt;plan for C++23&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;We adopted a &lt;a href=\"https://wg21.link/P1999\"&gt;process for evolutionary proposals&lt;/a&gt;, to make sure that we reduce the chance that we\u2019ll make mistakes&lt;/li&gt;\n&lt;li&gt;We agreed to pursue the Undefined Behavior group\u2019s effort to &lt;a href=\"https://wg21.link/P2118\"&gt;document Core Undefined or Unspecified Behavior&lt;/a&gt; going forward. They\u2019re documenting all language undefined behavior that C++ contains today, and we agreed to document and justify any new language undefined behavior going forward.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;We marked 3 papers as tentatively ready for C++23:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1847\"&gt;Make declaration order layout mandated&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P2025\"&gt;Guaranteed copy elision for named return objects&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1949\"&gt;C++ Identifier Syntax using Unicode Standard Annex 31&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;They\u2019ll proceed to the Core language group at the next meeting if no issues are raised with these papers.&lt;/p&gt;\n\n&lt;p&gt;We continued reviewing &lt;a href=\"https://wg21.link/p1371\"&gt;pattern matching&lt;/a&gt;. This is one of our top priorities going forward. It\u2019s looking better and better as we explore the design space and figure out how all the corner cases should work. One large discussion point at the moment is what happens when no match occurs, and whether we should mandate exhaustiveness. There\u2019s exploration around the expression versus statement form. We\u2019re looking for implementation experience to prove the design.&lt;/p&gt;\n\n&lt;p&gt;We really liked &lt;a href=\"https://wg21.link/P0847\"&gt;deducing &lt;code&gt;this&lt;/code&gt;&lt;/a&gt;, a proposal that eliminates the boilerplate associated with having &lt;code&gt;const&lt;/code&gt; and non-&lt;code&gt;const&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; member function overloads. It still needs wording and implementation experience, but has strong support.&lt;/p&gt;\n\n&lt;p&gt;We continue discussing floating-point &lt;a href=\"https://wg21.link/P1468\"&gt;fixed-layout types&lt;/a&gt; and &lt;a href=\"https://wg21.link/P1467\"&gt;extended floating point types&lt;/a&gt;, which are mandating IEEE 754 support for the new C++ &lt;code&gt;float16_t&lt;/code&gt;, &lt;code&gt;float32_t&lt;/code&gt;, &lt;code&gt;float64_t&lt;/code&gt;, and adding support for &lt;code&gt;bfloat16_t&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://wg21.link/P1040\"&gt;&lt;code&gt;std::embed&lt;/code&gt;&lt;/a&gt;, which allows embedding strings from files, is making good progress.&lt;/p&gt;\n\n&lt;p&gt;In collaboration with the Unicode group, &lt;a href=\"https://wg21.link/P2071\"&gt;named universal character escapes&lt;/a&gt; got strong support.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://wg21.link/P1938\"&gt;&lt;code&gt;if consteval&lt;/code&gt;&lt;/a&gt; was reviewed. We\u2019re not sure this is exactly the right solution, but we\u2019re interested in solving problems in this general area.&lt;/p&gt;\n\n&lt;p&gt;We saw a really cute paper on &lt;a href=\"https://wg21.link/P2041\"&gt;deleting variable templates&lt;/a&gt; and decided to expand its scope such that more things can be marked as &lt;code&gt;= delete&lt;/code&gt; in the language. This will make C++ much more regular, and reduce the need for expert-only solutions to tricky problems.&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Core Working Group (CWG) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;The top priority of CWG was finishing processing national body comments for C++20. CWG spent most of its remaining time this week working through papers and issues improving the detailed specification for new C++20 features.&lt;/p&gt;\n\n&lt;p&gt;We finished reviewing four papers that fine-tune the semantics of modules:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;We &lt;a href=\"https://wg21.link/p1815r2\"&gt;clarified the meaning of &lt;code&gt;static&lt;/code&gt;&lt;/a&gt; (and unnamed namespaces) in module interfaces: such entities are now kept internal and cannot be exposed in the interface / ABI of the module. In non-modules compilations, we deprecated cases where internal-linkage entities are used from external-linkage entities. (These cases typically lead to violations of the One Definition Rule.)&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;We &lt;a href=\"https://wg21.link/p1779r3\"&gt;clarified the meaning of &lt;code&gt;inline&lt;/code&gt;&lt;/a&gt; in module interfaces: the intent is that bodies of functions that are not explicitly declared &lt;code&gt;inline&lt;/code&gt; are not part of the ABI of a module, even if those function bodies appear in the module interface. In order to give module authors more control over their ABI, member functions defined in class bodies in module interfaces are no longer implicitly &lt;code&gt;inline&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;We tweaked the context-sensitive recognition of the &lt;code&gt;module&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; keyword in order to avoid changing the meaning of more existing code that uses these identifiers, and to make it more straightforward for a scanning tool to recognize these declarations without full preprocessing.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;We improved backwards compatibility with unnamed enumerations in legacy header files (particularly C header files). Such unnamed enumerations will now be properly merged across header files if they&amp;#39;re reachable in multiple different ways via imports.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;We finalized some subtle rules for concepts: a &lt;a href=\"https://wg21.link/p2092r0\"&gt;syntax gotcha&lt;/a&gt; in &lt;code&gt;requires&lt;/code&gt; expressions was fixed, and we allowed &lt;a href=\"https://wg21.link/p2104r0\"&gt;caching of concept values&lt;/a&gt;, which has been shown to dramatically improve performance in some cases.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;We agreed to (retroactively, via the defect report process) &lt;a href=\"https://wg21.link/p2104r0\"&gt;treat initialization of a &lt;code&gt;bool&lt;/code&gt; from a pointer as narrowing&lt;/a&gt;, improving language safety.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;We added permission for a comparison function to be defaulted outside its class, so long as the comparison function is a member or friend of the class, for consistency and to allow a defaulted comparison function to be non-inline.&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h1&gt;Library Progress&lt;/h1&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Library Evolution Working Group Incubator (LEWGI) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;LEWGI met for three and a half days this week and reviewed 22 papers. Most of our work this week was on various numerics proposals during joint sessions with the Numerics group. A lot of this work may end up going into the proposed Numerics Technical Specification, whose &lt;a href=\"https://wg21.link/P2004\"&gt;scope and goals we are working to define&lt;/a&gt;. We also spent a chunk of time working on &lt;a href=\"https://wg21.link/P1883\"&gt;modern I/O&lt;/a&gt; and concurrent data structures for the upcoming Concurrency Technical Specification Version 2.&lt;/p&gt;\n\n&lt;p&gt;LEWGI looked at the following proposals, among others:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Numerics:\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1930\"&gt;Physical Units Library&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1385\"&gt;Linear Algebra&lt;/a&gt;.&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;Concurrency:\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1958\"&gt;Concurrent Queues&lt;/a&gt;.&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;Low-level File I/O\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1883\"&gt;Mapped File Handle&lt;/a&gt;.&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;Narrowing Conversions\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P0870\"&gt;std::is_narrowing_conversion&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1998\"&gt;std::narrow_cast&lt;/a&gt;.&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;Random Numbers\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P2058\"&gt;Improving std::random_device&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P2059\"&gt;Portable Distributions&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P2059\"&gt;Improving Engine Seeding&lt;/a&gt;.&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Library Evolution Working Group (LEWG) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;After handling the few remaining National Body comments to fix issues with C++20, LEWG focused on making general policy decisions about standard library design standards. For example, we &lt;a href=\"https://wg21.link/P1851\"&gt;formally codified&lt;/a&gt; the guidelines for concept names in the standard library, and clarified &lt;a href=\"https://isocpp.org/std/standing-documents/sd-8-standard-library-compatibility\"&gt;SD-8&lt;/a&gt;, our document listing the compatibility guarantees we make to our users. Then we started looking at C++23 library proposals.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://wg21.link/P2027\"&gt;Moved-from objects need not be valid&lt;/a&gt; generated much internal discussion in the weeks leading up to the meeting as well as at the meeting itself.  While the exact solution outlined in the paper wasn\u2019t adopted, we are tightening up the wording around algorithms on what operations are performed on objects that are temporarily put in the moved-from state during the execution of an algorithm.&lt;/p&gt;\n\n&lt;p&gt;The biggest C++23 news: LEWG spent an entire day with the concurrency experts of SG1 to review the &lt;a href=\"https://wg21.link/P0443\"&gt;&lt;strong&gt;executors&lt;/strong&gt; proposal&lt;/a&gt; \u2014 we liked the direction! This is a huge step, which will enable &lt;strong&gt;networking&lt;/strong&gt;, &lt;strong&gt;audio&lt;/strong&gt;, &lt;strong&gt;coroutine library support&lt;/strong&gt;, and more.&lt;/p&gt;\n\n&lt;p&gt;Other C++23 proposals reviewed include&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1208\"&gt;a new &lt;code&gt;status_code&lt;/code&gt; facility&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P0401\"&gt;an ability for containers and allocators to communicate about the actual allocation size&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1425\"&gt;iterator range constructors for &lt;code&gt;std::stack&lt;/code&gt; and &lt;code&gt;std::queue&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;We\u2019ve also decided to &lt;a href=\"https://wg21.link/P2037\"&gt;deprecate &lt;code&gt;std::string&lt;/code&gt;\u2019s assignment operator taking a &lt;code&gt;char&lt;/code&gt;&lt;/a&gt; (pending LWG).&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Library Working Group (LWG) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;The primary goals were to finish processing NB comments and to &lt;a href=\"https://wg21.link/P2081\"&gt;rebase&lt;/a&gt; the Library Fundamentals TS on C++20.  We met both of those goals.&lt;/p&gt;\n\n&lt;p&gt;We looked at all 48 open library-related NB comments and responded to them.  Some were accepted for C++20.  Some were accepted for C++20 with changes.  For some, we agreed with the problem but considered the fix to be too risky for C++20, so an issue was opened for consideration in C++23.  For many the response was \u201cNo consensus for change,\u201d which can mean a variety of things from \u201cthis is not really a problem\u201d to \u201cthe problem is not worth fixing.\u201d&lt;/p&gt;\n\n&lt;p&gt;The last of the &lt;a href=\"https://wg21.link/P1460\"&gt;mandating papers&lt;/a&gt; was reviewed and approved.  All of the standard library should now be cleaned up to use the latest &lt;a href=\"https://wg21.link/P1369\"&gt;library wording guidelines&lt;/a&gt;, such as using \u201cMandates\u201d and \u201cConstraints\u201d clauses rather than \u201cRequires\u201d clauses.&lt;/p&gt;\n\n&lt;p&gt;Some time was spent going through the LWG open issues list.  We dealt with all open P1 issues (\u201cmust fix for C++20\u201d).  Many of the open P2 issues related to new C++20 features were dealt with, in an attempt to fix bugs before we ship them.&lt;/p&gt;\n\n&lt;p&gt;This was Marshall Clow\u2019s last meeting as LWG chair.  He received a standing ovation in plenary.&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Concurrency and Parallelism Study Group (SG1) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;SG1 focused on C++23 this week, primarily on driving executors, one of the major planned features on our roadmap. Executors is a foundational technology that we&amp;#39;ll build all sorts of modern asynchronous facilities on top of, so it&amp;#39;s important that we land it in the standard early in the C++23 cycle.&lt;/p&gt;\n\n&lt;p&gt;At this meeting, LEWG approved of the &lt;a href=\"https://wg21.link/P0443R12\"&gt;executors&lt;/a&gt; design, and asked  the authors to return with a full specification and wording for review at the next meeting.&lt;/p&gt;\n\n&lt;p&gt;SG1 reviewed and approved of a &lt;a href=\"https://wg21.link/P2006R0\"&gt;refinement&lt;/a&gt; to the design of the sender/receiver concepts. This change unifies the lifetime model of coroutines and sender/receiver and allows us to statically eliminate the need for heap allocations for many kinds of async algorithms.&lt;/p&gt;\n\n&lt;p&gt;Going forward, SG1 will start working on proposals that build on top of executors, such as concurrent algorithms, parallel algorithms work, networking, asynchronous I/O, etc.&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Networking Study Group (SG4) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;SG4 started processing review feedback on the &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4771.pdf\"&gt;networking TS&lt;/a&gt; aimed at modernizing it for inclusion in C++23. SG4 also reviewed a proposal to &lt;a href=\"https://wg21.link/p2052\"&gt;unify low-level I/O with the high-level asynchronous abstractions&lt;/a&gt; and gave feedback to the author.&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Numerics Study Group (SG6) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;The Numerics group met on Monday this week, and also jointly with LEWGI on Tuesday and Thursday, and with SG19 on Friday.&lt;/p&gt;\n\n&lt;p&gt;We reviewed papers on a number of topics, including:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P2004\"&gt;The scope and goals for the Numerics TS&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1385\"&gt;Linear algebra&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1935\"&gt;Units library&lt;/a&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Compile-Time Programming Study Group (SG7) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;&lt;a href=\"https://www.circle-lang.org/\"&gt;Circle&lt;/a&gt; is a fork of C++ that enables arbitrary compile-time execution (e.g. a compile-time &lt;code&gt;std::cout&lt;/code&gt;), coupled with reflection to allow powerful meta-programming. SG7 was interested in it and &lt;a href=\"https://wg21.link/P2043\"&gt;considered copying parts of it&lt;/a&gt;. However, concerns were &lt;a href=\"https://wg21.link/P2062\"&gt;raised&lt;/a&gt; about security and usability problems, so the ability to execute arbitrary code at compile-time was rejected.&lt;/p&gt;\n\n&lt;p&gt;Besides that, we also continued to make progress on C++ reflection including naming of reflection keywords and potential to enable lazy evaluation of function arguments.&lt;/p&gt;\n\n&lt;p&gt;We also looked at &lt;a href=\"https://wg21.link/P1609\"&gt;the JIT proposal&lt;/a&gt; and asked authors to try to unify the design with current reflection proposals.&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Undefined Behavior Study Group (SG12)/Vulnerabilities Working Group (WG23) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;We set out to &lt;a href=\"https://wg21.link/P1705\"&gt;enumerate all undefined and unspecified behavior&lt;/a&gt;. We\u2019ve decided that upcoming papers adding new undefined or unspecified behavior need to include rationale and examples.&lt;/p&gt;\n\n&lt;p&gt;SG12 also collaborated with the &lt;a href=\"https://www.misra.org.uk/\"&gt;MISRA standard&lt;/a&gt;  for coding standards in embedded systems to help them update the guidelines for newer C++ revisions.&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Human Machine Interface and Input/Output Study Group (SG13) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;SG13 had a brief presentation of extracts from the &lt;a href=\"https://www.youtube.com/watch?v=5N4b-rU-OAA\"&gt;2019 CppCon keynote&lt;/a&gt; featuring Ben Smith (from 1:05:00) &lt;/p&gt;\n\n&lt;p&gt;We looked at &lt;a href=\"http://wg21.link/P2005R0\"&gt;A Brief 2D Graphics Review&lt;/a&gt; and encouraged exploration of work towards a separable color proposal.&lt;/p&gt;\n\n&lt;p&gt;Finally, we worked through the use cases in &lt;a href=\"http://wg21.link/P2054\"&gt;Audio I/O Software Use Cases&lt;/a&gt;. We have a couple of weeks before the post meeting mailing deadline to collect additional use cases and will then solicit feedback on them from WG21 and the wider C++ community.&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Tooling Study Group (SG15) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;The Tooling study group met this week to continue work on the Module Ecosystem Technical Report. Three of the papers targeting the Technical Report are fairly mature at this point, so we&amp;#39;ve directed the authors of those papers to work together to create an initial draft of the Technical Report for the Varna meeting. Those papers are:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1689\"&gt;Dependency Information Format&lt;/a&gt; &lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1788\"&gt;Module Recipe and BMI Reuse&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1838\"&gt;User-Facing Lexicon and File Extensions&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;This draft will give us a shared vehicle to start hammering out the details of the Technical Report, and a target for people to write papers against.&lt;/p&gt;\n\n&lt;p&gt;We also discussed two proposals, about &lt;a href=\"https://wg21.link/P2073\"&gt;debugging C++ coroutines&lt;/a&gt; and &lt;a href=\"https://wg21.link/P2074\"&gt;asynchronous call stacks&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Unicode and Text Study Group (SG16) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;Our most interesting topic of the week concerned the interaction of execution character set and compile-time programming.  Proposed features for &lt;code&gt;std::embed&lt;/code&gt; and reflection require the evaluation of strings at compile time and this occurs at translation phase 7.  This is after translation phase 5 in which character and string literals are converted to the execution character set.  These features require interaction with file names or the internal symbol table of a compiler.  In cross compilation scenarios in which the target execution character set is not compatible with the compiler\u2019s host system or internal encoding, interesting things happen.  As in so many other cases, we found an answer in UTF-8 and will be recommending that these facilities operate solely in UTF-8.&lt;/p&gt;\n\n&lt;p&gt;We forwarded &lt;a href=\"https://wg21.link/P2071\"&gt;Named Universal Character Escapes&lt;/a&gt; and &lt;a href=\"https://wg21.link/P1949\"&gt;C++ Identifier Syntax using Unicode Standard Annex 31&lt;/a&gt; to EWG.\nBoth papers were seen by EWG this week and are on track for approval for C++23 in meetings later this year.&lt;/p&gt;\n\n&lt;p&gt;We forwarded &lt;a href=\"https://wg21.link/P1885\"&gt;Naming Text Encodings to Demystify Them&lt;/a&gt; to LEWG.&lt;/p&gt;\n\n&lt;p&gt;We declined to forward a paper to enhance &lt;code&gt;std::regex&lt;/code&gt; to better support Unicode due to severe ABI restrictions; the &lt;code&gt;std::regex&lt;/code&gt; design exposes many internal details of the implementation to the ABI and implementers indicated that they cannot make any significant changes.  Given the current state of &lt;code&gt;std::regex&lt;/code&gt; is such that we cannot fix either its interface or its well-known performance issues, a number of volunteers agreed to bring a paper to deprecate &lt;code&gt;std::regex&lt;/code&gt; at a future meeting.&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Machine Learning Study Group (SG19) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;SG19 met for a full day, one half day with SG14 (Low Latency), and one half day with SG6 (Numerics).&lt;/p&gt;\n\n&lt;p&gt;Significant feedback from a ML perspective was provided on &lt;a href=\"https://wg21.link/P1708\"&gt;Simple Statistics functions&lt;/a&gt;, especially regarding the handling of missing data, non-numeric data, and various potential performance issues.&lt;/p&gt;\n\n&lt;p&gt;There was an excellent presentation of &amp;quot;Review of P1708: Simple Statistical Functions&amp;quot; which presented an analysis across Python, R, SAS and Matlab for common statistical methods.&lt;/p&gt;\n\n&lt;p&gt;The &lt;a href=\"http://wg21.link/P1709\"&gt;graph library&lt;/a&gt; paper had a great reaction, was also discussed, and will proceed.&lt;/p&gt;\n\n&lt;p&gt;Also, support for differentiable programming in C++, important for well-integrated support for ML back-propagation, was discussed in the context of &lt;a href=\"https://wg21.link/P2072\"&gt;differentiable programming for C++&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;The freestanding library took a few steps forward, with some interesting proposals, including &lt;a href=\"https://wg21.link/P2013R0\"&gt;Freestanding Language: Optional &lt;code&gt;::operator new&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;One of the biggest decisions was on &lt;a href=\"https://www.research.ed.ac.uk/portal/files/78829292/low_cost_deterministic_C_exceptions_for_embedded_systems.pdf\"&gt;Low-Cost Deterministic C++ Exceptions for Embedded Systems&lt;/a&gt; which got great reactions. We will probably hear more about it!&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h3&gt;Contracts Study Group (SG21) Progress&lt;/h3&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;In a half-day session, we discussed one of the major points of contention from previous proposals, which was the relationship between \u201cassume\u201d and \u201cassert\u201d, disentangling colloquial and technical interpretations. We also discussed when one implies the other, and which combinations a future facility should support.&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P2076\"&gt;Previous Disagreements&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P2064\"&gt;Assumptions&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://wg21.link/P1774\"&gt;Portable Assumptions&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h1&gt;C++ Release Schedule&lt;/h1&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;NOTE: This is a plan not a promise. Treat it as speculative and tentative. See &lt;a href=\"https://wg21.link/P1000\"&gt;P1000&lt;/a&gt; for the latest plan.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;IS = International Standard. The C++ programming language. C++11, C++14, C++17, etc.&lt;/li&gt;\n&lt;li&gt;TS = Technical Specification. &amp;quot;Feature branches&amp;quot; available on some but not all implementations. Coroutines TS v1, Modules TS v1, etc.&lt;/li&gt;\n&lt;li&gt;CD = Committee Draft. A draft of an IS/TS that is sent out to national standards bodies for review and feedback (&amp;quot;beta testing&amp;quot;). &lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;table&gt;&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;Meeting&lt;/th&gt;\n&lt;th&gt;Location&lt;/th&gt;\n&lt;th&gt;Objective&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;del&gt;2018 Summer LWG Meeting&lt;/del&gt;&lt;/td&gt;\n&lt;td&gt;&lt;del&gt;Chicago \ud83c\uddfa\ud83c\uddf8&lt;/del&gt;&lt;/td&gt;\n&lt;td&gt;&lt;del&gt;Work on wording for C++20 features.&lt;/del&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;del&gt;2018 Fall EWG Modules Meeting&lt;/del&gt;&lt;/td&gt;\n&lt;td&gt;&lt;del&gt;Seattle \ud83c\uddfa\ud83c\uddf8&lt;/del&gt;&lt;/td&gt;\n&lt;td&gt;&lt;del&gt;Design modules for C++20.&lt;/del&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;del&gt;2018 Fall LEWG/SG1 Executors Meeting&lt;/del&gt;&lt;/td&gt;\n&lt;td&gt;&lt;del&gt;Seattle \ud83c\uddfa\ud83c\uddf8&lt;/del&gt;&lt;/td&gt;\n&lt;td&gt;&lt;del&gt;Design executors for C++20.&lt;/del&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;del&gt;2018 Fall Meeting&lt;/del&gt;&lt;/td&gt;\n&lt;td&gt;&lt;del&gt;San Diego \ud83c\uddfa\ud83c\uddf8&lt;/del&gt;&lt;/td&gt;\n&lt;td&gt;&lt;del&gt;C++20 major language feature freeze.&lt;/del&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;del&gt;2019 Spring Meeting&lt;/del&gt;&lt;/td&gt;\n&lt;td&gt;&lt;del&gt;Kona \ud83c\uddfa\ud83c\uddf8&lt;/del&gt;&lt;/td&gt;\n&lt;td&gt;&lt;del&gt;C++20 feature freeze. C++20 design is feature-complete.&lt;/del&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;del&gt;2019 Summer Meeting&lt;/del&gt;&lt;/td&gt;\n&lt;td&gt;&lt;del&gt;Cologne \ud83c\udde9\ud83c\uddea&lt;/del&gt;&lt;/td&gt;\n&lt;td&gt;&lt;del&gt;Complete C++20 CD wording. Start C++20 CD balloting (&amp;quot;beta testing&amp;quot;).&lt;/del&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;del&gt;2019 Fall Meeting&lt;/del&gt;&lt;/td&gt;\n&lt;td&gt;&lt;del&gt;Belfast \ud83c\uddec\ud83c\udde7&lt;/del&gt;&lt;/td&gt;\n&lt;td&gt;&lt;del&gt;C++20 CD ballot comment resolution (&amp;quot;bug fixes&amp;quot;).&lt;/del&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;strong&gt;2020 Spring Meeting&lt;/strong&gt;&lt;/td&gt;\n&lt;td&gt;&lt;strong&gt;Prague \ud83c\udde8\ud83c\uddff&lt;/strong&gt;&lt;/td&gt;\n&lt;td&gt;&lt;strong&gt;C++20 CD ballot comment resolution (&amp;quot;bug fixes&amp;quot;), C++20 completed.&lt;/strong&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;2020 Summer Meeting&lt;/td&gt;\n&lt;td&gt;Varna \ud83c\udde7\ud83c\uddec&lt;/td&gt;\n&lt;td&gt;First meeting of C++23.&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;2020 Fall Meeting&lt;/td&gt;\n&lt;td&gt;New York \ud83c\uddfa\ud83c\uddf8&lt;/td&gt;\n&lt;td&gt;Design major C++23 features.&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;2021 Winter Meeting&lt;/td&gt;\n&lt;td&gt;Kona \ud83c\uddfa\ud83c\uddf8&lt;/td&gt;\n&lt;td&gt;Design major C++23 features.&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;2021 Summer Meeting&lt;/td&gt;\n&lt;td&gt;Montr\u00e9al \ud83c\udde8\ud83c\udde6 \u269c\ufe0f&lt;/td&gt;\n&lt;td&gt;Design major C++23 features.&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;2021 Fall Meeting&lt;/td&gt;\n&lt;td&gt;\ud83d\uddfa\ufe0f&lt;/td&gt;\n&lt;td&gt;C++23 major language feature freeze.&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;2022 Spring Meeting&lt;/td&gt;\n&lt;td&gt;Portland \ud83c\uddfa\ud83c\uddf8&lt;/td&gt;\n&lt;td&gt;C++23 feature freeze. C++23 design is feature-complete.&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;2022 Summer Meeting&lt;/td&gt;\n&lt;td&gt;\ud83d\uddfa\ufe0f&lt;/td&gt;\n&lt;td&gt;Complete C++23 CD wording. Start C++23 CD balloting (&amp;quot;beta testing&amp;quot;).&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;2022 Fall Meeting&lt;/td&gt;\n&lt;td&gt;\ud83d\uddfa\ufe0f&lt;/td&gt;\n&lt;td&gt;C++23 CD ballot comment resolution (&amp;quot;bug fixes&amp;quot;).&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;2023 Spring Meeting&lt;/td&gt;\n&lt;td&gt;\ud83d\uddfa\ufe0f&lt;/td&gt;\n&lt;td&gt;C++23 CD ballot comment resolution (&amp;quot;bug fixes&amp;quot;), C++23 completed.&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;2023 Summer Meeting&lt;/td&gt;\n&lt;td&gt;\ud83d\uddfa\ufe0f&lt;/td&gt;\n&lt;td&gt;First meeting of C++26.&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h1&gt;Status of Major C++ Feature Development&lt;/h1&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;NOTE: This is a plan not a promise. Treat it as speculative and tentative.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;IS = International Standard. The C++ programming language. C++11, C++14, C++17, etc.&lt;/li&gt;\n&lt;li&gt;TS = Technical Specification. &amp;quot;Feature branches&amp;quot; available on some but not all implementations. Coroutines TS v1, Modules TS v1, etc.&lt;/li&gt;\n&lt;li&gt;CD = Committee Draft. A draft of an IS/TS that is sent out to national standards bodies for review and feedback (&amp;quot;beta testing&amp;quot;). &lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;strong&gt;Changes since last meeting are in bold.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;table&gt;&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;Feature&lt;/th&gt;\n&lt;th&gt;Status&lt;/th&gt;\n&lt;th&gt;Depends On&lt;/th&gt;\n&lt;th&gt;Current Target (Conservative Estimate)&lt;/th&gt;\n&lt;th&gt;Current Target (Optimistic Estimate)&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;a href=\"https://en.cppreference.com/w/cpp/language/constraints\"&gt;Concepts&lt;/a&gt;&lt;/td&gt;\n&lt;td&gt;Concepts TS v1 published and merged into C++20&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;C++20&lt;/td&gt;\n&lt;td&gt;C++20&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;a href=\"https://en.cppreference.com/w/cpp/experimental/ranges\"&gt;Ranges&lt;/a&gt;&lt;/td&gt;\n&lt;td&gt;Ranges TS v1 published and merged into C++20&lt;/td&gt;\n&lt;td&gt;Concepts&lt;/td&gt;\n&lt;td&gt;C++20&lt;/td&gt;\n&lt;td&gt;C++20&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;a href=\"https://wg21.link/P1103\"&gt;Modules&lt;/a&gt;&lt;/td&gt;\n&lt;td&gt;Merged design approved for C++20&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;C++20&lt;/td&gt;\n&lt;td&gt;C++20&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;a href=\"https://wg21.link/N4723\"&gt;Coroutines&lt;/a&gt;&lt;/td&gt;\n&lt;td&gt;Coroutines TS v1 published and merged into C++20&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;C++20&lt;/td&gt;\n&lt;td&gt;C++20&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;a href=\"https://wg21.link/P1658\"&gt;Executors&lt;/a&gt;&lt;/td&gt;\n&lt;td&gt;New compromise design approved for C++23&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;C++26&lt;/td&gt;\n&lt;td&gt;&lt;strong&gt;C++23 (Planned)&lt;/strong&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;a href=\"https://wg21.link/P0542\"&gt;Contracts&lt;/a&gt;&lt;/td&gt;\n&lt;td&gt;Moved to Study Group&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;C++26&lt;/td&gt;\n&lt;td&gt;C++23&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;a href=\"https://wg21.link/N4711\"&gt;Networking&lt;/a&gt;&lt;/td&gt;\n&lt;td&gt;Networking TS v1 published&lt;/td&gt;\n&lt;td&gt;Executors&lt;/td&gt;\n&lt;td&gt;C++26&lt;/td&gt;\n&lt;td&gt;&lt;strong&gt;C++23 (Planned)&lt;/strong&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;a href=\"https://wg21.link/P0194\"&gt;Reflection&lt;/a&gt;&lt;/td&gt;\n&lt;td&gt;Reflection TS v1 published&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;C++26&lt;/td&gt;\n&lt;td&gt;C++23&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;a href=\"https://wg21.link/P1371\"&gt;Pattern Matching&lt;/a&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;C++26&lt;/td&gt;\n&lt;td&gt;C++23&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;strong&gt;&lt;a href=\"https://wg21.link/P1453\"&gt;Modularized Standard Library&lt;/a&gt;&lt;/strong&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;strong&gt;C++23&lt;/strong&gt;&lt;/td&gt;\n&lt;td&gt;&lt;strong&gt;C++23 (Planned)&lt;/strong&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://www.eddit.com/r/cpp/comments/dtuov8/201911_belfast_iso_c_committee_trip_report/\"&gt;&lt;strong&gt;Last Meeting&amp;#39;s Reddit Trip Report.&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;If you have any questions, ask them in this thread!&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/blelbach\"&gt;/u/blelbach&lt;/a&gt;, Tooling (SG15) Chair, Library Evolution Incubator (SG18) Chair&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/bigcheesegs\"&gt;/u/bigcheesegs&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/c0r3ntin\"&gt;/u/c0r3ntin&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/jfbastien\"&gt;/u/jfbastien&lt;/a&gt;, Evolution (EWG) Chair&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/arkethos\"&gt;/u/arkethos&lt;/a&gt; (aka code_report)&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/vulder\"&gt;/u/vulder&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/hanickadot\"&gt;/u/hanickadot&lt;/a&gt;, Compile-Time Programming (SG7) Chair&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/tahonermann\"&gt;/u/tahonermann&lt;/a&gt;, Text and Unicode (SG16) Chair&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/cjdb-ns\"&gt;/u/cjdb-ns&lt;/a&gt;, Education (SG20) Lieutenant&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/nliber\"&gt;/u/nliber&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/sphere991\"&gt;/u/sphere991&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/tituswinters\"&gt;/u/tituswinters&lt;/a&gt;, Library Evolution (LEWG) Chair&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/HalFinkel\"&gt;/u/HalFinkel&lt;/a&gt;, US National Body (PL22.16) Vice Chair&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/ErichKeane\"&gt;/u/ErichKeane&lt;/a&gt;, Evolution Incubator (SG17) Assistant Chair&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/sempuki\"&gt;/u/sempuki&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/ckennelly\"&gt;/u/ckennelly&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/mathstuf\"&gt;/u/mathstuf&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/david-stone\"&gt;/u/david-stone&lt;/a&gt;, Modules (SG2) Chair and Evolution (EWG) Vice Chair&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/je4d\"&gt;/u/je4d&lt;/a&gt;, Networking (SG4) Chair&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/FabioFracassi\"&gt;/u/FabioFracassi&lt;/a&gt;, German National Body Chair&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/redbeard0531\"&gt;/u/redbeard0531&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/nliber\"&gt;/u/nliber&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/foonathan\"&gt;/u/foonathan&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/InbalL\"&gt;/u/InbalL&lt;/a&gt;, Israel National Body Chair&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;&lt;a href=\"/u/zygoloid\"&gt;/u/zygoloid&lt;/a&gt;, C++ Project Editor&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;\u22ef and others \u22ef&lt;/em&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [{"count": 1, "is_enabled": true, "subreddit_id": null, "description": "Shows the Silver Award... and that's it.", "end_date": null, "coin_reward": 0, "icon_url": "https://www.redditstatic.com/gold/awards/icon/silver_512.png", "days_of_premium": 0, "coin_price": 100, "is_new": false, "icon_format": null, "award_sub_type": "GLOBAL", "resized_icons": [{"url": "https://www.redditstatic.com/gold/awards/icon/silver_16.png", "width": 16, "height": 16}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_32.png", "width": 32, "height": 32}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_48.png", "width": 48, "height": 48}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_64.png", "width": 64, "height": 64}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_128.png", "width": 128, "height": 128}], "icon_height": 512, "award_type": "global", "start_date": null, "days_of_drip_extension": 0, "id": "gid_1", "icon_width": 512, "subreddit_coin_reward": 0, "name": "Silver"}], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": "NVIDIA | ISO C++ Library Incubator Chair | ISO C++ Tooling Chair", "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f47x4o", "is_robot_indexable": true, "report_reasons": null, "author": "blelbach", "discussion_type": null, "num_comments": 429, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": "dark", "permalink": "/r/cpp/comments/f47x4o/202002_prague_iso_c_committee_trip_report_c20_is/", "parent_whitelist_status": "all_ads", "stickied": true, "url": "https://www.reddit.com/r/cpp/comments/f47x4o/202002_prague_iso_c_committee_trip_report_c20_is/", "subreddit_subscribers": 121680, "created_utc": 1581763949.0, "num_crossposts": 1, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "### My Favorite Unknown C++20 Feature\n\n*by Nathan Myers*\n\nC++2020 was voted out yesterday, its final stamp of technical\napproval before it goes to ISO for legal certification.\nThis is a big, big release, comparable to C++2011 a decade\nago, that will change, again, how we write, and think about,\nour programs.\nThe big features--Concepts, Coroutines, Modules--will get\nplenty of coverage elsewhere in the days ahead, but the \nmyriad smaller features, taken together, may make as great\na difference in the code that most of us will write. \n\nHere I will call your attention to one small feature that, \nnonetheless, represents a change to the very foundations of\nthe language.\nIt is usually called, cryptically, the \"unified comma operator\",\na name that belies it importance.\nIt represents only the *second* time, since the ISO Standard C++\neffort began in 1990, that the language grammar has ever been\nsimplified.\n(The first was eliminating \"implicit int\", the fix for a wart\ninherited from C, a fix that C has since also adopted.)\n\nOn its face, comma unification is simple enough.\nUp through C++17, the comma has had several different meanings\nin expression contexts, each with its own place in the formal\nlanguage grammar.\nThe most frequent use separates function actual arguments.\nSimilar uses appear in aggregate initializers--between elements \nbeing initialized in curly brackets--and in initializer-lists,\nlikewise.\nFinally, it is a sequence operator, which may also be overloaded\nby user code for, usually, expression-template libraries.\n\nThere was no motivation to unify these meanings before we got \nanother important language feature: parameter packs.\nParameter packs were introduced in C++11 with very restricted\ncapabilities, only just enough to support integrating variadic\nargument lists into the type system.\nThose restrictions have been progressively relaxed in each\nsubsequent Standard, with new syntax greatly amplifying their\nvalue.  We have lately dropped \"parameter\" from the name, because\nof their expanding usefulness, and just call them \"packs\".\n\nPacks have come increasingly to resemble a language-native, \nfirst-class version of the library feature `std::tuple&lt;&gt;`.\nComma-operator unification takes the next step toward this future.\nThe comma has now become, effectively, the pack construction operator.\nAppearing in a function-call argument context, it constructs an\nargument pack.\n(Every function, now, takes just a single actual, pack, argument.)\nAppearing in an aggregate initialization, the pack it constructs\nconforms to the shape of the target aggregate.\n\nC++ has a long history, and a complicated inheritance.\nC++20 inherits not only from C, but also C++98, C++03, C++11,\nC++14, and C++17.\nNothing new in C++ can be as simple as it might be if we could\nstart from a clean slate.\nThe comma already means things.\nWhat it means, for observable effects of existing code, mustn't\nchange, if backward compatibility is to be preserved.\n\nSo, when constructing an argument pack, the values have to be\nconverted to match formal arguments of the selected function\noverload, and the initial type and number of the pack elements\ndrive the choice of that overload.\nIn an aggregate initializer, similarly, the pack's values must\nbe made to conform to the aggregate they initialize.\nAggregate initialization still needs to be disambiguated from\na uniform initializer-list.\nIn a scalar expression, all but the last element of the pack must\nbe computed and then discarded--except where they need to become\narguments to an overloaded comma-operator call, instead.\n\nWhen totting up new features in C++20, comma unification is often\nneglected, because it it doesn't yet change what programs can be\nwritten, or how.\nBut you will hear more about it as each new feature it enables\nsurfaces.\nComma unification is all about what will come to be.\nFirst-class packs, in C++23 and moreso in C++26, will enable\ncoding in C++ to feel more like using newer scripting and \nfunctional languages, and enable writing more powerful libraries\nwith cleaner, simpler, safer interfaces.\n\nSometimes it's not the marquee features that have the biggest impact, in the longer term.", "author_fullname": "t2_4b6mlatj", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "My Favorite Unknown C++20 Feature", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f50ag6", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 123, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 123, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581929155.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;h3&gt;My Favorite Unknown C++20 Feature&lt;/h3&gt;\n\n&lt;p&gt;&lt;em&gt;by Nathan Myers&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;C++2020 was voted out yesterday, its final stamp of technical\napproval before it goes to ISO for legal certification.\nThis is a big, big release, comparable to C++2011 a decade\nago, that will change, again, how we write, and think about,\nour programs.\nThe big features--Concepts, Coroutines, Modules--will get\nplenty of coverage elsewhere in the days ahead, but the \nmyriad smaller features, taken together, may make as great\na difference in the code that most of us will write. &lt;/p&gt;\n\n&lt;p&gt;Here I will call your attention to one small feature that, \nnonetheless, represents a change to the very foundations of\nthe language.\nIt is usually called, cryptically, the &amp;quot;unified comma operator&amp;quot;,\na name that belies it importance.\nIt represents only the &lt;em&gt;second&lt;/em&gt; time, since the ISO Standard C++\neffort began in 1990, that the language grammar has ever been\nsimplified.\n(The first was eliminating &amp;quot;implicit int&amp;quot;, the fix for a wart\ninherited from C, a fix that C has since also adopted.)&lt;/p&gt;\n\n&lt;p&gt;On its face, comma unification is simple enough.\nUp through C++17, the comma has had several different meanings\nin expression contexts, each with its own place in the formal\nlanguage grammar.\nThe most frequent use separates function actual arguments.\nSimilar uses appear in aggregate initializers--between elements \nbeing initialized in curly brackets--and in initializer-lists,\nlikewise.\nFinally, it is a sequence operator, which may also be overloaded\nby user code for, usually, expression-template libraries.&lt;/p&gt;\n\n&lt;p&gt;There was no motivation to unify these meanings before we got \nanother important language feature: parameter packs.\nParameter packs were introduced in C++11 with very restricted\ncapabilities, only just enough to support integrating variadic\nargument lists into the type system.\nThose restrictions have been progressively relaxed in each\nsubsequent Standard, with new syntax greatly amplifying their\nvalue.  We have lately dropped &amp;quot;parameter&amp;quot; from the name, because\nof their expanding usefulness, and just call them &amp;quot;packs&amp;quot;.&lt;/p&gt;\n\n&lt;p&gt;Packs have come increasingly to resemble a language-native, \nfirst-class version of the library feature &lt;code&gt;std::tuple&amp;lt;&amp;gt;&lt;/code&gt;.\nComma-operator unification takes the next step toward this future.\nThe comma has now become, effectively, the pack construction operator.\nAppearing in a function-call argument context, it constructs an\nargument pack.\n(Every function, now, takes just a single actual, pack, argument.)\nAppearing in an aggregate initialization, the pack it constructs\nconforms to the shape of the target aggregate.&lt;/p&gt;\n\n&lt;p&gt;C++ has a long history, and a complicated inheritance.\nC++20 inherits not only from C, but also C++98, C++03, C++11,\nC++14, and C++17.\nNothing new in C++ can be as simple as it might be if we could\nstart from a clean slate.\nThe comma already means things.\nWhat it means, for observable effects of existing code, mustn&amp;#39;t\nchange, if backward compatibility is to be preserved.&lt;/p&gt;\n\n&lt;p&gt;So, when constructing an argument pack, the values have to be\nconverted to match formal arguments of the selected function\noverload, and the initial type and number of the pack elements\ndrive the choice of that overload.\nIn an aggregate initializer, similarly, the pack&amp;#39;s values must\nbe made to conform to the aggregate they initialize.\nAggregate initialization still needs to be disambiguated from\na uniform initializer-list.\nIn a scalar expression, all but the last element of the pack must\nbe computed and then discarded--except where they need to become\narguments to an overloaded comma-operator call, instead.&lt;/p&gt;\n\n&lt;p&gt;When totting up new features in C++20, comma unification is often\nneglected, because it it doesn&amp;#39;t yet change what programs can be\nwritten, or how.\nBut you will hear more about it as each new feature it enables\nsurfaces.\nComma unification is all about what will come to be.\nFirst-class packs, in C++23 and moreso in C++26, will enable\ncoding in C++ to feel more like using newer scripting and \nfunctional languages, and enable writing more powerful libraries\nwith cleaner, simpler, safer interfaces.&lt;/p&gt;\n\n&lt;p&gt;Sometimes it&amp;#39;s not the marquee features that have the biggest impact, in the longer term.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f50ag6", "is_robot_indexable": true, "report_reasons": null, "author": "ContractorInChief", "discussion_type": null, "num_comments": 61, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/f50ag6/my_favorite_unknown_c20_feature/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/f50ag6/my_favorite_unknown_c20_feature/", "subreddit_subscribers": 121680, "created_utc": 1581900355.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "", "author_fullname": "t2_hoaut", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "An Extraterrestrial Guide to C++20 Text Formatting", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f56u0v", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 14, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 14, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581963849.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "bfilipek.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f56u0v", "is_robot_indexable": true, "report_reasons": null, "author": "drodri", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/f56u0v/an_extraterrestrial_guide_to_c20_text_formatting/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.bfilipek.com/2020/02/extra-format-cpp20.html", "subreddit_subscribers": 121680, "created_utc": 1581935049.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "We have opened today the registrations for the C++ conference using std::cpp 2020 to be held in Madrid on April 16th.\n\nThe complete program is still to be announced but some talks are already confirmed.\n\nAnd the best of all registration is FREE.\n\nhttps://eventos.uc3m.es/go/usingstdcpp2020\n\nCome to Spain for a  one day conference 100% devoted to C++.", "author_fullname": "t2_i92k2", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "C++ conference in Madrid", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f57egn", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 7, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 7, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581967417.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;We have opened today the registrations for the C++ conference using std::cpp 2020 to be held in Madrid on April 16th.&lt;/p&gt;\n\n&lt;p&gt;The complete program is still to be announced but some talks are already confirmed.&lt;/p&gt;\n\n&lt;p&gt;And the best of all registration is FREE.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://eventos.uc3m.es/go/usingstdcpp2020\"&gt;https://eventos.uc3m.es/go/usingstdcpp2020&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Come to Spain for a  one day conference 100% devoted to C++.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f57egn", "is_robot_indexable": true, "report_reasons": null, "author": "jdgarciauc3m", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/f57egn/c_conference_in_madrid/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/f57egn/c_conference_in_madrid/", "subreddit_subscribers": 121680, "created_utc": 1581938617.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "I just created Qt car game, where you can compete with a genetic algorithm, or just see how it evolves. Let me know your thoughts.\nhttps://github.com/swordey/2DCarGameWithGA", "author_fullname": "t2_3bwyvygf", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Qt car game with genetic algorithm", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f53w80", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 5, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 5, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581946233.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I just created Qt car game, where you can compete with a genetic algorithm, or just see how it evolves. Let me know your thoughts.\n&lt;a href=\"https://github.com/swordey/2DCarGameWithGA\"&gt;https://github.com/swordey/2DCarGameWithGA&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f53w80", "is_robot_indexable": true, "report_reasons": null, "author": "swordythomas", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/f53w80/qt_car_game_with_genetic_algorithm/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/f53w80/qt_car_game_with_genetic_algorithm/", "subreddit_subscribers": 121680, "created_utc": 1581917433.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "", "author_fullname": "t2_f77gj", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Herb Sutter's Trip Winter ISO C++ Standards Meeting (Prague) Trip Report", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f4p2nn", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 109, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": "7bf857c8-4dcc-11e6-b84d-0e5fbba92363", "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 109, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581878497.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "herbsutter.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": "NVIDIA | ISO C++ Library Incubator Chair | ISO C++ Tooling Chair", "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f4p2nn", "is_robot_indexable": true, "report_reasons": null, "author": "blelbach", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": "dark", "permalink": "/r/cpp/comments/f4p2nn/herb_sutters_trip_winter_iso_c_standards_meeting/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://herbsutter.com/2020/02/15/trip-report-winter-iso-c-standards-meeting-prague/", "subreddit_subscribers": 121680, "created_utc": 1581849697.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "I recently had an idea for an efficient immutable vector.  \nIt is basically a copy-on-write array behind a shared pointer. The array grows exponentially and the `push_back` operation reuses the array if possible (if there is still space left and  if it is the first `push_back` for a given array and size).\nThe result is a vector with an O(1) copy operation and `push_back` (also `pop_back`) operations with an amortized O(1) best case complexity. The worst case complexity for `push_back` is O(n) but only happens if you create a copy of a given vector and then push_back to both the original vector and the copy, in which case it is no worse than the standard vector since the standard vector has an O(n) complexity for copying. All other operations should have the same complexity as the standard vector: O(1) lookup, O(n) insert and erase.\n\nYou can find a prototype implementation of this data structure here: https://gist.github.com/eyelash/87a3fe849b31a37c58eca4ef398a71dc\n\nI believe that from a (somewhat theoretical) big-O perspective this vector is strictly better than the standard vector, since there is no sequence of operations that has a worse complexity. (Is this actually correct?)\n\nI'm surely not the first to come up with this data structure. Is there a name for it? Is there somewhere I can find more information or a more robust implementation? I'm aware of a few implementations of immutable vectors (e.g. [immer](https://github.com/arximboldi/immer)) but they all use trees internally. What is the reason for that?\n\n**Edit**: Thinking about it some more I realize the big difference is in updating a single element which can be done in O(log n) in a tree and will be O(n) for an array-based immutable vector.", "author_fullname": "t2_so4t6", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "an efficient immutable vector", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f4szkn", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 14, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 14, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1581881624.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581899489.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I recently had an idea for an efficient immutable vector.&lt;br/&gt;\nIt is basically a copy-on-write array behind a shared pointer. The array grows exponentially and the &lt;code&gt;push_back&lt;/code&gt; operation reuses the array if possible (if there is still space left and  if it is the first &lt;code&gt;push_back&lt;/code&gt; for a given array and size).\nThe result is a vector with an O(1) copy operation and &lt;code&gt;push_back&lt;/code&gt; (also &lt;code&gt;pop_back&lt;/code&gt;) operations with an amortized O(1) best case complexity. The worst case complexity for &lt;code&gt;push_back&lt;/code&gt; is O(n) but only happens if you create a copy of a given vector and then push_back to both the original vector and the copy, in which case it is no worse than the standard vector since the standard vector has an O(n) complexity for copying. All other operations should have the same complexity as the standard vector: O(1) lookup, O(n) insert and erase.&lt;/p&gt;\n\n&lt;p&gt;You can find a prototype implementation of this data structure here: &lt;a href=\"https://gist.github.com/eyelash/87a3fe849b31a37c58eca4ef398a71dc\"&gt;https://gist.github.com/eyelash/87a3fe849b31a37c58eca4ef398a71dc&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;I believe that from a (somewhat theoretical) big-O perspective this vector is strictly better than the standard vector, since there is no sequence of operations that has a worse complexity. (Is this actually correct?)&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m surely not the first to come up with this data structure. Is there a name for it? Is there somewhere I can find more information or a more robust implementation? I&amp;#39;m aware of a few implementations of immutable vectors (e.g. &lt;a href=\"https://github.com/arximboldi/immer\"&gt;immer&lt;/a&gt;) but they all use trees internally. What is the reason for that?&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: Thinking about it some more I realize the big difference is in updating a single element which can be done in O(log n) in a tree and will be O(n) for an array-based immutable vector.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f4szkn", "is_robot_indexable": true, "report_reasons": null, "author": "_eyelash", "discussion_type": null, "num_comments": 24, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/f4szkn/an_efficient_immutable_vector/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/f4szkn/an_efficient_immutable_vector/", "subreddit_subscribers": 121680, "created_utc": 1581870689.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "-Edit- Learn programming linked me to a stackoverflow answer that gave me enough information to figure it out https://www.reddit.com/r/learnprogramming/comments/f50dvb/choose_optimization_in_c/ https://stackoverflow.com/questions/15548023/clang-optimization-levels Basically I need -inline to get all the data into a single function then -sroa to reduce the struct into allocs which eliminates the struct. So it appears that optimizers can get rid of structs outright but may not reduce the members in it (at least I don't see any passes for that)\n\nI  want to double check if an optimization works in a very specific situation. The optimization doesn't happen if I use -O1 but the compiler optimizes out pretty much the  entire app if I do -O2 (so I can't completely confirm if it does a thing without another thing). Is there a way to specify which passes I want? I  see a list of passes here but I have no idea how to specify it [https://llvm.org/docs/Passes.html](https://llvm.org/docs/Passes.html)\n\nI prefer the solution to be in clang\n\n-Edit- What I'd like to check is if the optimizer will reduce the size of the struct. If I copy b.c into a.c the optimizer will remove the struct completely. If they're in seperate files the struct is the full size. I tried to use undefined behavior to see if it might trigger but clang knows I'm passing the struct and leaves it intact\n\n----\n\n\n    //a.c\n    #include &lt;stdio.h&gt;\n\n    struct Dummy\n    {\n        int a, b, c, d, e, f;\n    };\n\n    static void test3(struct Dummy*p)\n    {\n        printf(\"%d %d\\n\", p-&gt;e, sizeof(struct Dummy));\n    }\n\n    //void test2(void *p, void (*f)(void *));\n    void test2(long int z, void (*f)(void *));\n    static void test(int c)\n    {\n        struct Dummy z;\n        z.e = c*2;\n        test2((long int)&amp;z, test3);\n    }\n\n    int main(int argc, char *argv[])\n    {\n        test(argc);\n        return 0;\n    }\n\n    //b.c\n    void test2(long int z, void (*f)(void*))\n    {\n        f((void*)z);\n    }", "author_fullname": "t2_5j0penen", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Choose optimization in C++? (Preferally clang)", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f50etd", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1581910796.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581929706.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;-Edit- Learn programming linked me to a stackoverflow answer that gave me enough information to figure it out &lt;a href=\"https://www.reddit.com/r/learnprogramming/comments/f50dvb/choose_optimization_in_c/\"&gt;https://www.reddit.com/r/learnprogramming/comments/f50dvb/choose_optimization_in_c/&lt;/a&gt; &lt;a href=\"https://stackoverflow.com/questions/15548023/clang-optimization-levels\"&gt;https://stackoverflow.com/questions/15548023/clang-optimization-levels&lt;/a&gt; Basically I need -inline to get all the data into a single function then -sroa to reduce the struct into allocs which eliminates the struct. So it appears that optimizers can get rid of structs outright but may not reduce the members in it (at least I don&amp;#39;t see any passes for that)&lt;/p&gt;\n\n&lt;p&gt;I  want to double check if an optimization works in a very specific situation. The optimization doesn&amp;#39;t happen if I use -O1 but the compiler optimizes out pretty much the  entire app if I do -O2 (so I can&amp;#39;t completely confirm if it does a thing without another thing). Is there a way to specify which passes I want? I  see a list of passes here but I have no idea how to specify it &lt;a href=\"https://llvm.org/docs/Passes.html\"&gt;https://llvm.org/docs/Passes.html&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;I prefer the solution to be in clang&lt;/p&gt;\n\n&lt;p&gt;-Edit- What I&amp;#39;d like to check is if the optimizer will reduce the size of the struct. If I copy b.c into a.c the optimizer will remove the struct completely. If they&amp;#39;re in seperate files the struct is the full size. I tried to use undefined behavior to see if it might trigger but clang knows I&amp;#39;m passing the struct and leaves it intact&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;pre&gt;&lt;code&gt;//a.c\n#include &amp;lt;stdio.h&amp;gt;\n\nstruct Dummy\n{\n    int a, b, c, d, e, f;\n};\n\nstatic void test3(struct Dummy*p)\n{\n    printf(&amp;quot;%d %d\\n&amp;quot;, p-&amp;gt;e, sizeof(struct Dummy));\n}\n\n//void test2(void *p, void (*f)(void *));\nvoid test2(long int z, void (*f)(void *));\nstatic void test(int c)\n{\n    struct Dummy z;\n    z.e = c*2;\n    test2((long int)&amp;amp;z, test3);\n}\n\nint main(int argc, char *argv[])\n{\n    test(argc);\n    return 0;\n}\n\n//b.c\nvoid test2(long int z, void (*f)(void*))\n{\n    f((void*)z);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f50etd", "is_robot_indexable": true, "report_reasons": null, "author": "PresentConnection999", "discussion_type": null, "num_comments": 5, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/f50etd/choose_optimization_in_c_preferally_clang/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/f50etd/choose_optimization_in_c_preferally_clang/", "subreddit_subscribers": 121680, "created_utc": 1581900906.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "For all of its complexity, bad design decisions, and interactions between features that weren't explicitly considered, it all somehow *works*. The compilers and standard library implementations aren't riddled with bugs. Everything works as designed, even if that design sometimes has flaws. The compilers generate correct code and the standard library functions don't crash.\n\nHow do they do it?", "author_fullname": "t2_60u4x", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "One problem that C++ surprisingly doesn't seem to have", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f4x7fc", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581915817.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;For all of its complexity, bad design decisions, and interactions between features that weren&amp;#39;t explicitly considered, it all somehow &lt;em&gt;works&lt;/em&gt;. The compilers and standard library implementations aren&amp;#39;t riddled with bugs. Everything works as designed, even if that design sometimes has flaws. The compilers generate correct code and the standard library functions don&amp;#39;t crash.&lt;/p&gt;\n\n&lt;p&gt;How do they do it?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f4x7fc", "is_robot_indexable": true, "report_reasons": null, "author": "Frogging101", "discussion_type": null, "num_comments": 49, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/f4x7fc/one_problem_that_c_surprisingly_doesnt_seem_to/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/f4x7fc/one_problem_that_c_surprisingly_doesnt_seem_to/", "subreddit_subscribers": 121680, "created_utc": 1581887017.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "I appologize if this is not well thought out/has already been proposed and for poor english.\n\n#Precompiling generic code\n\n\nWith C++20 concepts, and with upcoming reflections/metaclasses, C++ is encouraging even more generic programming. \nHowever, generic programming is already bottlenecked by compile time. Adding more feature to generic programming\nwill only make it worse as more people uses it (and convenient features might encourage costly operations for the compiler). \n\nThe main reason for that is that you cannot precompile generic code, and I think we can improve that.\n\n##Templates as a compiler function:\n\nA templated function\n \n    f&lt;type A,type B&gt;(A a, B b) -&gt; C\n\ncan be reinterpreted as \n\n    f: &lt;type A, type B&gt; -&gt; fAB = ( (A a,B b) -&gt; C )\n\nwhere fAB is non templated function. This was described in a paper which I cannot remember, I appologize for that.\n\nDuring compilation, the function `f` will be constructued from the code, then evaluated for some types A and B, and a  function fAB will be generated by the compiler.\nAll this is essentialy working as an *interpreter* with all the associated costs.\n\nNow imagine that this function `f` was hardcoded in the compiler. Given some internal representation for type A and type B, it would generate a function fAB.\nThis would go much faster, since this hardcoded function `f` would not require to parse any AST, and more importantly, it would be *compiled*! \nWe can expect such function to perform much faster than it's interpreted counterpart.\n\nA natural question is what should be the target language for fAB? should it be some internal representation for the compiler (llvm IR)? or assembly?\nThe first leaves out time consuming optimisation, but should be much easier to implement.\n\n##Precompiling generic code: a dynamic library for the compiler\nIn what was said above, we assumed there was a hardcoded function f in the compiler. This is obviously not realistic.\nHowever, such function could be loaded dynamically as a Plugin by the compiler, and the execute the function f from that plugin.\nEssentially, a precompiled generic library would be targeting the compiler instead of the executable.\n\nThe previous example was demonstrated with a function, but it should also work with templated data type generation.   \n\n  \n&amp;nbsp;  \n\nWhat do you all think?\n\nEdit: added in a comment bellow:\n\nIf we look at what module brings, we have from to https://vector-of-bool.github.io/2019/01/27/modules-doa.html:\n\n\n1. Tokenization caching - Because of TU isolation, tokenizing a TU can be cached when the module is later imported into another TU.\n2. Parse-tree caching - Same as above. Tokenization and parsing are some of the most expensive operations in compiling C++. In my own tests, parsing can consume up to 30% of compilation time for files with a large preprocessed output.\n3. Lazy re-generation - If foo imports bar, and we later make changes to the implementation of bar, we may be able to omit recompilation of foo. Only changes to the interface of bar necessitate recompilation of foo.\n4. Template specialization memoization - This one is a bit more subtle and may take more work to implement, but the potential speedups are enormous. In short: A specialization of a class or function template appearing in the module interface unit can be cached and loaded from disk later.\n5. Inline function codegen caching - Codegen results for inline functions (including function templates and member functions of class templates) can be cached and later re-loaded by the 6. Inline function codegen elision - extern template allows the compiler to omit performing codegen for function and class templates. This is hugely beneficial for the linker when it performs de-dup. Modules may allow the compiler to perform more extern template-style optimizations implicitly.\n\n4 and 5 are pretty independant from what I'm proposing. \n\nWhat about 1,2 and 3? Well my proposal would essentially be seen as a possible implementation of those points! \n\nHowever, this approach has an important other benefit: using a template function/type from a library should be **almost as fast as having this function/type hard coded in the compiler!**", "author_fullname": "t2_4jghonfq", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Improving C++ compile time: precompiling generic code", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f4pt34", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 5, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 5, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1581872311.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581883358.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I appologize if this is not well thought out/has already been proposed and for poor english.&lt;/p&gt;\n\n&lt;h1&gt;Precompiling generic code&lt;/h1&gt;\n\n&lt;p&gt;With C++20 concepts, and with upcoming reflections/metaclasses, C++ is encouraging even more generic programming. \nHowever, generic programming is already bottlenecked by compile time. Adding more feature to generic programming\nwill only make it worse as more people uses it (and convenient features might encourage costly operations for the compiler). &lt;/p&gt;\n\n&lt;p&gt;The main reason for that is that you cannot precompile generic code, and I think we can improve that.&lt;/p&gt;\n\n&lt;h2&gt;Templates as a compiler function:&lt;/h2&gt;\n\n&lt;p&gt;A templated function&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;f&amp;lt;type A,type B&amp;gt;(A a, B b) -&amp;gt; C\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;can be reinterpreted as &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;f: &amp;lt;type A, type B&amp;gt; -&amp;gt; fAB = ( (A a,B b) -&amp;gt; C )\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;where fAB is non templated function. This was described in a paper which I cannot remember, I appologize for that.&lt;/p&gt;\n\n&lt;p&gt;During compilation, the function &lt;code&gt;f&lt;/code&gt; will be constructued from the code, then evaluated for some types A and B, and a  function fAB will be generated by the compiler.\nAll this is essentialy working as an &lt;em&gt;interpreter&lt;/em&gt; with all the associated costs.&lt;/p&gt;\n\n&lt;p&gt;Now imagine that this function &lt;code&gt;f&lt;/code&gt; was hardcoded in the compiler. Given some internal representation for type A and type B, it would generate a function fAB.\nThis would go much faster, since this hardcoded function &lt;code&gt;f&lt;/code&gt; would not require to parse any AST, and more importantly, it would be &lt;em&gt;compiled&lt;/em&gt;! \nWe can expect such function to perform much faster than it&amp;#39;s interpreted counterpart.&lt;/p&gt;\n\n&lt;p&gt;A natural question is what should be the target language for fAB? should it be some internal representation for the compiler (llvm IR)? or assembly?\nThe first leaves out time consuming optimisation, but should be much easier to implement.&lt;/p&gt;\n\n&lt;h2&gt;Precompiling generic code: a dynamic library for the compiler&lt;/h2&gt;\n\n&lt;p&gt;In what was said above, we assumed there was a hardcoded function f in the compiler. This is obviously not realistic.\nHowever, such function could be loaded dynamically as a Plugin by the compiler, and the execute the function f from that plugin.\nEssentially, a precompiled generic library would be targeting the compiler instead of the executable.&lt;/p&gt;\n\n&lt;p&gt;The previous example was demonstrated with a function, but it should also work with templated data type generation.   &lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;  &lt;/p&gt;\n\n&lt;p&gt;What do you all think?&lt;/p&gt;\n\n&lt;p&gt;Edit: added in a comment bellow:&lt;/p&gt;\n\n&lt;p&gt;If we look at what module brings, we have from to &lt;a href=\"https://vector-of-bool.github.io/2019/01/27/modules-doa.html:\"&gt;https://vector-of-bool.github.io/2019/01/27/modules-doa.html:&lt;/a&gt;&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Tokenization caching - Because of TU isolation, tokenizing a TU can be cached when the module is later imported into another TU.&lt;/li&gt;\n&lt;li&gt;Parse-tree caching - Same as above. Tokenization and parsing are some of the most expensive operations in compiling C++. In my own tests, parsing can consume up to 30% of compilation time for files with a large preprocessed output.&lt;/li&gt;\n&lt;li&gt;Lazy re-generation - If foo imports bar, and we later make changes to the implementation of bar, we may be able to omit recompilation of foo. Only changes to the interface of bar necessitate recompilation of foo.&lt;/li&gt;\n&lt;li&gt;Template specialization memoization - This one is a bit more subtle and may take more work to implement, but the potential speedups are enormous. In short: A specialization of a class or function template appearing in the module interface unit can be cached and loaded from disk later.&lt;/li&gt;\n&lt;li&gt;Inline function codegen caching - Codegen results for inline functions (including function templates and member functions of class templates) can be cached and later re-loaded by the 6. Inline function codegen elision - extern template allows the compiler to omit performing codegen for function and class templates. This is hugely beneficial for the linker when it performs de-dup. Modules may allow the compiler to perform more extern template-style optimizations implicitly.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;4 and 5 are pretty independant from what I&amp;#39;m proposing. &lt;/p&gt;\n\n&lt;p&gt;What about 1,2 and 3? Well my proposal would essentially be seen as a possible implementation of those points! &lt;/p&gt;\n\n&lt;p&gt;However, this approach has an important other benefit: using a template function/type from a library should be &lt;strong&gt;almost as fast as having this function/type hard coded in the compiler!&lt;/strong&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f4pt34", "is_robot_indexable": true, "report_reasons": null, "author": "acTruffles", "discussion_type": null, "num_comments": 15, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/f4pt34/improving_c_compile_time_precompiling_generic_code/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/f4pt34/improving_c_compile_time_precompiling_generic_code/", "subreddit_subscribers": 121680, "created_utc": 1581854558.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "Hi, I just wanted to share an article about declarative format that I'm working on in CMakeSL. Here's a teaser:\n\n&amp;#x200B;\n\nhttps://reddit.com/link/f4ge4k/video/ull8d9f3s5h41/player\n\nAnd the art: [https://gist.github.com/stryku/4c69aa510711c9da6705fa4df4545515](https://gist.github.com/stryku/4c69aa510711c9da6705fa4df4545515)\n\nLet me know what do you think about all this (:", "author_fullname": "t2_16xks0", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Declarative support in CMakeSL", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "media_metadata": {"ull8d9f3s5h41": {"status": "valid", "e": "RedditVideo", "dashUrl": "https://v.redd.it/link/f4ge4k/asset/ull8d9f3s5h41/DASHPlaylist.mpd", "x": 424, "y": 240, "hlsUrl": "https://v.redd.it/link/f4ge4k/asset/ull8d9f3s5h41/HLSPlaylist.m3u8", "id": "ull8d9f3s5h41", "isGif": false}}, "name": "t3_f4ge4k", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 37, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 37, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581832314.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hi, I just wanted to share an article about declarative format that I&amp;#39;m working on in CMakeSL. Here&amp;#39;s a teaser:&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://reddit.com/link/f4ge4k/video/ull8d9f3s5h41/player\"&gt;https://reddit.com/link/f4ge4k/video/ull8d9f3s5h41/player&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;And the art: &lt;a href=\"https://gist.github.com/stryku/4c69aa510711c9da6705fa4df4545515\"&gt;https://gist.github.com/stryku/4c69aa510711c9da6705fa4df4545515&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Let me know what do you think about all this (:&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f4ge4k", "is_robot_indexable": true, "report_reasons": null, "author": "stryku2393", "discussion_type": null, "num_comments": 5, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/f4ge4k/declarative_support_in_cmakesl/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/f4ge4k/declarative_support_in_cmakesl/", "subreddit_subscribers": 121680, "created_utc": 1581803514.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_f4ge4k", "before": null}}