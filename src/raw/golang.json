{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_zyvj0", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "What feature of Go is used very often by experienced programmers, but not so much by a newbie?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_hp4mk3", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.98, "author_flair_background_color": null, "subreddit_type": "public", "ups": 91, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 91, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1594473897.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "hp4mk3", "is_robot_indexable": true, "report_reasons": null, "author": "availchet", "discussion_type": null, "num_comments": 59, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/hp4mk3/what_feature_of_go_is_used_very_often_by/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/hp4mk3/what_feature_of_go_is_used_very_often_by/", "subreddit_subscribers": 118670, "created_utc": 1594445097.0, "num_crossposts": 1, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Suggestions please!", "author_fullname": "t2_578dvau5", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Resources to learn Web Programming with Go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_hozqjs", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.81, "author_flair_background_color": null, "subreddit_type": "public", "ups": 40, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 40, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1594452931.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Suggestions please!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "hozqjs", "is_robot_indexable": true, "report_reasons": null, "author": "ken_morel", "discussion_type": null, "num_comments": 15, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/hozqjs/resources_to_learn_web_programming_with_go/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/hozqjs/resources_to_learn_web_programming_with_go/", "subreddit_subscribers": 118670, "created_utc": 1594424131.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_effgz", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Under the hood of Go's context", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": true, "name": "t3_hp8s68", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1594497301.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "vishnubharathi.codes", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://vishnubharathi.codes/blog/go-contexts/", "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "hp8s68", "is_robot_indexable": true, "report_reasons": null, "author": "scriptnull", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/hp8s68/under_the_hood_of_gos_context/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://vishnubharathi.codes/blog/go-contexts/", "subreddit_subscribers": 118670, "created_utc": 1594468501.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hey there,\n\nI would like to get your opinion on something which happend to me last week:\n\nA coworker wrote a function which initially gave back a bool based on some checking. Then he realised that he needs three states (start, stop and nothing).\nHe then changed the func to return a pointer to a bool which was not initialized when to do nothing.\n\nI totally disagree with this and told him to use enums. But he said he likes his idea better.\n\nSo, what do you think is the better approach?\n\nThanks in advance", "author_fullname": "t2_53jbt0m", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Bool vs enum", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_hp6a7h", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.81, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1594483002.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hey there,&lt;/p&gt;\n\n&lt;p&gt;I would like to get your opinion on something which happend to me last week:&lt;/p&gt;\n\n&lt;p&gt;A coworker wrote a function which initially gave back a bool based on some checking. Then he realised that he needs three states (start, stop and nothing).\nHe then changed the func to return a pointer to a bool which was not initialized when to do nothing.&lt;/p&gt;\n\n&lt;p&gt;I totally disagree with this and told him to use enums. But he said he likes his idea better.&lt;/p&gt;\n\n&lt;p&gt;So, what do you think is the better approach?&lt;/p&gt;\n\n&lt;p&gt;Thanks in advance&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "hp6a7h", "is_robot_indexable": true, "report_reasons": null, "author": "jphein", "discussion_type": null, "num_comments": 9, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/hp6a7h/bool_vs_enum/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/hp6a7h/bool_vs_enum/", "subreddit_subscribers": 118670, "created_utc": 1594454202.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "I'm coming to the Go world from Java. And I'm especially new to the \"web\" frameworks. I've been using Echo on 2 services, and found that it's pretty nice.   \n\n\nThe biggest thing I'm missing is the automatic generation of Swagger/OpenAPI spec from source.  \nI found tools that can read the source code and look for special annotation, but it's still a lot of manual work to add around, where in Java it's done without those.\n\nI'm not sure if it's possible in Go..", "author_fullname": "t2_100beg", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Web framework that can automatically generate OpenAPI/Swagger", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": true, "name": "t3_hp94nf", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.5, "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1594499050.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m coming to the Go world from Java. And I&amp;#39;m especially new to the &amp;quot;web&amp;quot; frameworks. I&amp;#39;ve been using Echo on 2 services, and found that it&amp;#39;s pretty nice.   &lt;/p&gt;\n\n&lt;p&gt;The biggest thing I&amp;#39;m missing is the automatic generation of Swagger/OpenAPI spec from source.&lt;br/&gt;\nI found tools that can read the source code and look for special annotation, but it&amp;#39;s still a lot of manual work to add around, where in Java it&amp;#39;s done without those.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m not sure if it&amp;#39;s possible in Go..&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "hp94nf", "is_robot_indexable": true, "report_reasons": null, "author": "aclokay", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/hp94nf/web_framework_that_can_automatically_generate/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/hp94nf/web_framework_that_can_automatically_generate/", "subreddit_subscribers": 118670, "created_utc": 1594470250.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "This [PR](https://github.com/rpm-software-management/libdnf/pull/988) adds Swig bindings to libdnf (the lib behind the Redhat/Fedora/CentOS/Mageia package manager), but currently there is nobody checking if this is actually working for Go. So if you've got a use case for that, please go check it out and provide some feedback!", "author_fullname": "t2_h0rk5", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "DNF5 needs your help with Go bindings", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_hoq5p3", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.83, "author_flair_background_color": null, "subreddit_type": "public", "ups": 31, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 31, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1594421040.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;This &lt;a href=\"https://github.com/rpm-software-management/libdnf/pull/988\"&gt;PR&lt;/a&gt; adds Swig bindings to libdnf (the lib behind the Redhat/Fedora/CentOS/Mageia package manager), but currently there is nobody checking if this is actually working for Go. So if you&amp;#39;ve got a use case for that, please go check it out and provide some feedback!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "hoq5p3", "is_robot_indexable": true, "report_reasons": null, "author": "brejoc", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/hoq5p3/dnf5_needs_your_help_with_go_bindings/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/hoq5p3/dnf5_needs_your_help_with_go_bindings/", "subreddit_subscribers": 118670, "created_utc": 1594392240.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_ix1tair", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Google's go safeweb. Collection of libraries to write safe web servers in go by default.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_hp6aqy", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.5, "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1594483094.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://github.com/google/go-safeweb", "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "hp6aqy", "is_robot_indexable": true, "report_reasons": null, "author": "vishal24anand", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/hp6aqy/googles_go_safeweb_collection_of_libraries_to/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/google/go-safeweb", "subreddit_subscribers": 118670, "created_utc": 1594454294.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_14hncs", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "An Analyzer makes the go/analysis.Analyzer be able to ignore diagnostics with //nolint comment", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_hp41af", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.67, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1594470994.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://github.com/kyoh86/nolint/blob/master/README.md", "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "hp41af", "is_robot_indexable": true, "report_reasons": null, "author": "kyoh86", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/hp41af/an_analyzer_makes_the_goanalysisanalyzer_be_able/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/kyoh86/nolint/blob/master/README.md", "subreddit_subscribers": 118670, "created_utc": 1594442194.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Couple years back, I worked on serviceq ([https://github.com/gptankit/serviceq](https://github.com/gptankit/serviceq)) which is a load balancer written in Go, that aims to dynamically adapt to errors in downstream nodes. It does this by   \na) adaptive routing  \nb) queueing and retrying failed requests\n\nHave exposed the adaptive routing logic as a package - harmonic ([https://github.com/gptankit/harmonic](https://github.com/gptankit/harmonic)) - which can be used from client apps, load balancers or test suites, if needed.\n\nComments/suggestions are welcome.", "author_fullname": "t2_27kidk2u", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Adaptive routing for load balancing", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_homsvy", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.92, "author_flair_background_color": null, "subreddit_type": "public", "ups": 25, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 25, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1594406934.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Couple years back, I worked on serviceq (&lt;a href=\"https://github.com/gptankit/serviceq\"&gt;https://github.com/gptankit/serviceq&lt;/a&gt;) which is a load balancer written in Go, that aims to dynamically adapt to errors in downstream nodes. It does this by&lt;br/&gt;\na) adaptive routing&lt;br/&gt;\nb) queueing and retrying failed requests&lt;/p&gt;\n\n&lt;p&gt;Have exposed the adaptive routing logic as a package - harmonic (&lt;a href=\"https://github.com/gptankit/harmonic\"&gt;https://github.com/gptankit/harmonic&lt;/a&gt;) - which can be used from client apps, load balancers or test suites, if needed.&lt;/p&gt;\n\n&lt;p&gt;Comments/suggestions are welcome.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "homsvy", "is_robot_indexable": true, "report_reasons": null, "author": "gptankit", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/homsvy/adaptive_routing_for_load_balancing/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/homsvy/adaptive_routing_for_load_balancing/", "subreddit_subscribers": 118670, "created_utc": 1594378134.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hey,\n\n&amp;#x200B;\n\nI'm building a web app and trying to learn unit test at the same time. I end up having alot of boiler plate in each test because of having to mock and inject dependencies alot. How could I write better test ?\n\nSmall example below :\n\n\tfunc TestHandlerGetUser(t *testing.T) {\n\t\tservice := new(mocks.Service)\n\t\thandler := user.NewHandler(service)\n\t\te := echo.New()\n\n\t\tvar u domain.User\n\t\tfaker.FakeData(&amp;u)\n\n\t\tt.Run(\"should return user with given id\", func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\t\t\trec := httptest.NewRecorder()\n\t\t\tc := e.NewContext(req, rec)\n\t\t\tservice.On(\"GetByID\", mock.Anything, u.ID).Return(u, nil).Once()\n\t\t\tc.SetPath(\"/api/users/:id\")\n\t\t\tc.SetParamNames(\"id\")\n\t\t\tc.SetParamValues(strconv.Itoa(u.ID))\n\n\t\t\terr := handler.GetUser(c)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\n\t\t\tbody, _ := ioutil.ReadAll(rec.Result().Body)\n\t\t\tvar responseUser domain.User\n\t\t\tjson.Unmarshal(body, &amp;responseUser)\n\t\t\tassert.EqualValues(t, u, responseUser)\n\t\t})\n\n\t\tt.Run(\"should return bad request with wrong params\", func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\t\t\trec := httptest.NewRecorder()\n\t\t\tc := e.NewContext(req, rec)\n\t\t\tc.SetPath(\"/api/users/:id\")\n\t\t\tc.SetParamNames(\"id\")\n\t\t\tc.SetParamValues(u.Email)\n\n\t\t\terr := handler.GetUser(c)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, http.StatusBadRequest, rec.Code)\n\t\t})\n\n\t\tt.Run(\"should return not found\", func(t *testing.T) {\n\t\t\tservice.On(\"GetByID\", mock.Anything, u.ID).Return(domain.User{}, sql.ErrNoRows).Once()\n\t\t\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\t\t\trec := httptest.NewRecorder()\n\t\t\tc := e.NewContext(req, rec)\n\t\t\tc.SetPath(\"/api/users/:id\")\n\t\t\tc.SetParamNames(\"id\")\n\t\t\tc.SetParamValues(strconv.Itoa(u.ID))\n\n\t\t\terr := handler.GetUser(c)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, http.StatusNotFound, rec.Code)\n\t\t})\n\n\t\tt.Run(\"should return internal server error\", func(t *testing.T) {\n\t\t\tservice.On(\"GetByID\", mock.Anything, u.ID).Return(domain.User{}, errors.New(\"fail\")).Once()\n\t\t\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\t\t\trec := httptest.NewRecorder()\n\t\t\tc := e.NewContext(req, rec)\n\t\t\tc.SetPath(\"/api/users/:id\")\n\t\t\tc.SetParamNames(\"id\")\n\t\t\tc.SetParamValues(strconv.Itoa(u.ID))\n\n\t\t\terr := handler.GetUser(c)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, http.StatusInternalServerError, rec.Code)\n\t\t})\n\n\t}\n\nMy handler function is the following :\n\n\tfunc (h *handler) GetUser(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, err := strconv.Atoi(c.Param(\"id\"))\n\t\tif err != nil {\n\t\t\treturn c.String(http.StatusBadRequest, \"invalid request\")\n\t\t}\n\t\tu, err := h.service.GetByID(ctx, userID)\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn c.String(http.StatusNotFound, \"user not found\")\n\t\t}\n\t\tif err != nil {\n\t\t\treturn c.String(http.StatusInternalServerError, \"unable to get user\")\n\t\t}\n\t\treturn c.JSON(http.StatusOK, u)\n\t}\n\nLittle update, tried to follow faabiosr comment :\n\n\tfunc TestHandlerGetUser(t *testing.T) {\n\t\te := echo.New()\n\t\tvar u domain.User\n\t\tfaker.FakeData(&amp;u)\n\n\t\ttype test struct {\n\t\t\tname         string\n\t\t\tparam        string\n\t\t\tstatus       int\n\t\t\tserviceError error\n\t\t\tbody         interface{}\n\t\t}\n\n\t\ttable := []test{\n\t\t\t{\"should return user\", strconv.Itoa(u.ID), 200, nil, u},\n\t\t\t{\"should return wrong parameters\", u.Email, http.StatusBadRequest, nil, \"invalid request\"},\n\t\t\t{\"should return no user found\", strconv.Itoa(u.ID), http.StatusNotFound, sql.ErrNoRows, \"user not found\"},\n\t\t\t{\"should return internal server error\", strconv.Itoa(u.ID), http.StatusInternalServerError, errors.New(\"fail\"), \"unable to get user\"},\n\t\t}\n\n\t\tfor _, test := range table {\n\t\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t\tservice := new(mocks.Service)\n\t\t\t\thandler := user.NewHandler(service)\n\t\t\t\tservice.On(\"GetByID\", mock.Anything, u.ID).Return(u, test.serviceError).Once()\n\n\t\t\t\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\t\t\t\trec := httptest.NewRecorder()\n\t\t\t\tc := e.NewContext(req, rec)\n\t\t\t\tc.SetPath(\"/api/users/:id\")\n\t\t\t\tc.SetParamNames(\"id\")\n\t\t\t\tc.SetParamValues(test.param)\n\n\t\t\t\terr := handler.GetUser(c)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, test.status, rec.Code)\n\n\t\t\t\trecBody, _ := ioutil.ReadAll(rec.Result().Body)\n\t\t\t\tvar recBodyContent interface{}\n\t\t\t\tvar testBodyContent interface{}\n\t\t\t\ttestBody, _ := json.Marshal(test.body)\n\t\t\t\tjson.Unmarshal(recBody, &amp;recBodyContent)\n\t\t\t\tjson.Unmarshal(testBody, &amp;testBodyContent)\n\t\t\t\tassert.EqualValues(t, testBodyContent, recBodyContent)\n\t\t\t})\n\t\t}\n\t}", "author_fullname": "t2_9x47q", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How to reduce unit test function size ?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_hp0qc0", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.5, "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1594432621.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1594456810.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hey,&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m building a web app and trying to learn unit test at the same time. I end up having alot of boiler plate in each test because of having to mock and inject dependencies alot. How could I write better test ?&lt;/p&gt;\n\n&lt;p&gt;Small example below :&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func TestHandlerGetUser(t *testing.T) {\n    service := new(mocks.Service)\n    handler := user.NewHandler(service)\n    e := echo.New()\n\n    var u domain.User\n    faker.FakeData(&amp;amp;u)\n\n    t.Run(&amp;quot;should return user with given id&amp;quot;, func(t *testing.T) {\n        req := httptest.NewRequest(http.MethodGet, &amp;quot;/&amp;quot;, nil)\n        rec := httptest.NewRecorder()\n        c := e.NewContext(req, rec)\n        service.On(&amp;quot;GetByID&amp;quot;, mock.Anything, u.ID).Return(u, nil).Once()\n        c.SetPath(&amp;quot;/api/users/:id&amp;quot;)\n        c.SetParamNames(&amp;quot;id&amp;quot;)\n        c.SetParamValues(strconv.Itoa(u.ID))\n\n        err := handler.GetUser(c)\n        assert.NoError(t, err)\n        assert.Equal(t, http.StatusOK, rec.Code)\n\n        body, _ := ioutil.ReadAll(rec.Result().Body)\n        var responseUser domain.User\n        json.Unmarshal(body, &amp;amp;responseUser)\n        assert.EqualValues(t, u, responseUser)\n    })\n\n    t.Run(&amp;quot;should return bad request with wrong params&amp;quot;, func(t *testing.T) {\n        req := httptest.NewRequest(http.MethodGet, &amp;quot;/&amp;quot;, nil)\n        rec := httptest.NewRecorder()\n        c := e.NewContext(req, rec)\n        c.SetPath(&amp;quot;/api/users/:id&amp;quot;)\n        c.SetParamNames(&amp;quot;id&amp;quot;)\n        c.SetParamValues(u.Email)\n\n        err := handler.GetUser(c)\n        assert.NoError(t, err)\n        assert.Equal(t, http.StatusBadRequest, rec.Code)\n    })\n\n    t.Run(&amp;quot;should return not found&amp;quot;, func(t *testing.T) {\n        service.On(&amp;quot;GetByID&amp;quot;, mock.Anything, u.ID).Return(domain.User{}, sql.ErrNoRows).Once()\n        req := httptest.NewRequest(http.MethodGet, &amp;quot;/&amp;quot;, nil)\n        rec := httptest.NewRecorder()\n        c := e.NewContext(req, rec)\n        c.SetPath(&amp;quot;/api/users/:id&amp;quot;)\n        c.SetParamNames(&amp;quot;id&amp;quot;)\n        c.SetParamValues(strconv.Itoa(u.ID))\n\n        err := handler.GetUser(c)\n        assert.NoError(t, err)\n        assert.Equal(t, http.StatusNotFound, rec.Code)\n    })\n\n    t.Run(&amp;quot;should return internal server error&amp;quot;, func(t *testing.T) {\n        service.On(&amp;quot;GetByID&amp;quot;, mock.Anything, u.ID).Return(domain.User{}, errors.New(&amp;quot;fail&amp;quot;)).Once()\n        req := httptest.NewRequest(http.MethodGet, &amp;quot;/&amp;quot;, nil)\n        rec := httptest.NewRecorder()\n        c := e.NewContext(req, rec)\n        c.SetPath(&amp;quot;/api/users/:id&amp;quot;)\n        c.SetParamNames(&amp;quot;id&amp;quot;)\n        c.SetParamValues(strconv.Itoa(u.ID))\n\n        err := handler.GetUser(c)\n        assert.NoError(t, err)\n        assert.Equal(t, http.StatusInternalServerError, rec.Code)\n    })\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;My handler function is the following :&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (h *handler) GetUser(c echo.Context) error {\n    ctx := c.Request().Context()\n    userID, err := strconv.Atoi(c.Param(&amp;quot;id&amp;quot;))\n    if err != nil {\n        return c.String(http.StatusBadRequest, &amp;quot;invalid request&amp;quot;)\n    }\n    u, err := h.service.GetByID(ctx, userID)\n    if err == sql.ErrNoRows {\n        return c.String(http.StatusNotFound, &amp;quot;user not found&amp;quot;)\n    }\n    if err != nil {\n        return c.String(http.StatusInternalServerError, &amp;quot;unable to get user&amp;quot;)\n    }\n    return c.JSON(http.StatusOK, u)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Little update, tried to follow faabiosr comment :&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func TestHandlerGetUser(t *testing.T) {\n    e := echo.New()\n    var u domain.User\n    faker.FakeData(&amp;amp;u)\n\n    type test struct {\n        name         string\n        param        string\n        status       int\n        serviceError error\n        body         interface{}\n    }\n\n    table := []test{\n        {&amp;quot;should return user&amp;quot;, strconv.Itoa(u.ID), 200, nil, u},\n        {&amp;quot;should return wrong parameters&amp;quot;, u.Email, http.StatusBadRequest, nil, &amp;quot;invalid request&amp;quot;},\n        {&amp;quot;should return no user found&amp;quot;, strconv.Itoa(u.ID), http.StatusNotFound, sql.ErrNoRows, &amp;quot;user not found&amp;quot;},\n        {&amp;quot;should return internal server error&amp;quot;, strconv.Itoa(u.ID), http.StatusInternalServerError, errors.New(&amp;quot;fail&amp;quot;), &amp;quot;unable to get user&amp;quot;},\n    }\n\n    for _, test := range table {\n        t.Run(test.name, func(t *testing.T) {\n            service := new(mocks.Service)\n            handler := user.NewHandler(service)\n            service.On(&amp;quot;GetByID&amp;quot;, mock.Anything, u.ID).Return(u, test.serviceError).Once()\n\n            req := httptest.NewRequest(http.MethodGet, &amp;quot;/&amp;quot;, nil)\n            rec := httptest.NewRecorder()\n            c := e.NewContext(req, rec)\n            c.SetPath(&amp;quot;/api/users/:id&amp;quot;)\n            c.SetParamNames(&amp;quot;id&amp;quot;)\n            c.SetParamValues(test.param)\n\n            err := handler.GetUser(c)\n            assert.NoError(t, err)\n            assert.Equal(t, test.status, rec.Code)\n\n            recBody, _ := ioutil.ReadAll(rec.Result().Body)\n            var recBodyContent interface{}\n            var testBodyContent interface{}\n            testBody, _ := json.Marshal(test.body)\n            json.Unmarshal(recBody, &amp;amp;recBodyContent)\n            json.Unmarshal(testBody, &amp;amp;testBodyContent)\n            assert.EqualValues(t, testBodyContent, recBodyContent)\n        })\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "hp0qc0", "is_robot_indexable": true, "report_reasons": null, "author": "Poimu", "discussion_type": null, "num_comments": 6, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/hp0qc0/how_to_reduce_unit_test_function_size/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/hp0qc0/how_to_reduce_unit_test_function_size/", "subreddit_subscribers": 118670, "created_utc": 1594428010.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_hp0qc0", "before": null}}