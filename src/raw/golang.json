{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_wynon", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Collection of Technical Interview Problems Solved In Go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_frdm4u", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 121, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 121, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1585545810.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "frdm4u", "is_robot_indexable": true, "report_reasons": null, "author": "shomali11", "discussion_type": null, "num_comments": 16, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/frdm4u/collection_of_technical_interview_problems_solved/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/shomali11/go-interview", "subreddit_subscribers": 107315, "created_utc": 1585517010.0, "num_crossposts": 1, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_1486wg", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Mokku - A clipboard-based mocking framework for Go that gets out of your way", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_frq068", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1585600616.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "frq068", "is_robot_indexable": true, "report_reasons": null, "author": "kinbiko", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/frq068/mokku_a_clipboardbased_mocking_framework_for_go/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/kinbiko/mokku", "subreddit_subscribers": 107315, "created_utc": 1585571816.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_trlrz", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Retrieve Location of macOS Device from Go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_frn6qt", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 4, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 4, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1585586787.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "vladimir.varank.in", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "frn6qt", "is_robot_indexable": true, "report_reasons": null, "author": "varankinv", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/frn6qt/retrieve_location_of_macos_device_from_go/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://vladimir.varank.in/notes/2020/03/go-osx-core-location/", "subreddit_subscribers": 107315, "created_utc": 1585557987.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_32cqe2", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Molecule \u2013 Streaming, zero-allocation protobuf decoding in Go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fr6c8n", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 93, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 93, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1585519443.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fr6c8n", "is_robot_indexable": true, "report_reasons": null, "author": "hyperdashdev", "discussion_type": null, "num_comments": 9, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/fr6c8n/molecule_streaming_zeroallocation_protobuf/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/richardartoul/molecule", "subreddit_subscribers": 107315, "created_utc": 1585490643.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "I want to represent a state called slope, the state can be any of positive, negative or zero. As far as I came to understand, Go doesn't support unions [yet](https://github.com/golang/go/issues/19412). What is the popular pattern for emulating unions?\n\nIn Rust I would do something like \n\n```\nenum Slope {\n  positive, zero, negative\n}\n```", "author_fullname": "t2_12379h", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How does one express tagged unions in Go?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_frqg5h", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1585602389.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I want to represent a state called slope, the state can be any of positive, negative or zero. As far as I came to understand, Go doesn&amp;#39;t support unions &lt;a href=\"https://github.com/golang/go/issues/19412\"&gt;yet&lt;/a&gt;. What is the popular pattern for emulating unions?&lt;/p&gt;\n\n&lt;p&gt;In Rust I would do something like &lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;\nenum Slope {\n  positive, zero, negative\n}\n&lt;/code&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "frqg5h", "is_robot_indexable": true, "report_reasons": null, "author": "bruce3434", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/frqg5h/how_does_one_express_tagged_unions_in_go/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/frqg5h/how_does_one_express_tagged_unions_in_go/", "subreddit_subscribers": 107315, "created_utc": 1585573589.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hello, I'm writing a path tracer in Golang, which is basically a Monte Carlo program for rendering photorealistic 3D scenes. Using Monte Carlo method, it implements random sampling. When I render each pixel, it doesn't need information about other pixels or about other samples of itself. Here's my sampling strategy:\n\n* split samples evenly for each CPU core (eg. if I have 128 samples and 16 cores, then each core will render 8 samples\n* each sample works like this:\n   * for each row in a column:\n      * shoot a ray towards a scene for each pixel in a row\n\nEverything works well, I can see 100% CPU utilization on all cores, but when I compare time spent for single pixel sample I can see significantly better results if I sample without the first step above (so without goroutines). In one example scene I had average 20.677\u00b5s for single pixel sample with goroutines and 12.138\u00b5s without goroutines, so calculating single sample gets about 70% slower, which is a lot. Here's example code, I removed unnecessary parts and simplified it:\n\n    cpus := runtime.NumCPU()\n    runtime.GOMAXPROCS(cpus)\n    \n    buf := make([][]Color, cpus)\n    canvas := make([]Color, vsize*hsize)\n    \n    for i := 0; i &lt; cpus; i++ {\n    \tbuf[i] = make([]Color, vsize*hsize)\n    }\n    \n    ch := make(chan int, cpus)\n    \n    samplesCPU := samples / cpus\n    \n    for i := 0; i &lt; cpus; i++ {\n    \tgo func(i int) {\n    \t\tfor s := 0; s &lt; samplesCPU; s++ {\n    \t\t\tsource := rand.NewSource(time.Now().UnixNano())\n    \t\t\tgenerator := rand.New(source) // without using custom generator for each sample, it gets very slow, because of mutex lock\n    \t\t\tfor y := vsize - 1; y &gt;= 0; y-- {\n    \t\t\t\tfor x := 0; x &lt; hsize; x++ {\n    \t\t\t\t\t// calculate sample here\n    \n    \t\t\t\t\tbuf[i][y*hsize+x] = buf[i][y*hsize+x].Add(col) // add pixel value to temporary buffer, it'll get all averaged later\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tch &lt;- 1\n    \t}(i)\n    }\n    \n    for i := 0; i &lt; cpus; i++ {\n    \t&lt;-ch\n    }\n    close(ch)\n\nI noticed another weird thing: when I use goroutines, but set my program to render on one core, I can see in the Task Manager that my program doesn't use only one core on 100%, but it uses multiple cores on low %. What am I missing here?", "author_fullname": "t2_3psq3l0x", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "My program is slower when it comes to time spent on single operation when using goroutines", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_frqerw", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1585602230.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hello, I&amp;#39;m writing a path tracer in Golang, which is basically a Monte Carlo program for rendering photorealistic 3D scenes. Using Monte Carlo method, it implements random sampling. When I render each pixel, it doesn&amp;#39;t need information about other pixels or about other samples of itself. Here&amp;#39;s my sampling strategy:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;split samples evenly for each CPU core (eg. if I have 128 samples and 16 cores, then each core will render 8 samples&lt;/li&gt;\n&lt;li&gt;each sample works like this:\n\n&lt;ul&gt;\n&lt;li&gt;for each row in a column:\n\n&lt;ul&gt;\n&lt;li&gt;shoot a ray towards a scene for each pixel in a row&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Everything works well, I can see 100% CPU utilization on all cores, but when I compare time spent for single pixel sample I can see significantly better results if I sample without the first step above (so without goroutines). In one example scene I had average 20.677\u00b5s for single pixel sample with goroutines and 12.138\u00b5s without goroutines, so calculating single sample gets about 70% slower, which is a lot. Here&amp;#39;s example code, I removed unnecessary parts and simplified it:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;cpus := runtime.NumCPU()\nruntime.GOMAXPROCS(cpus)\n\nbuf := make([][]Color, cpus)\ncanvas := make([]Color, vsize*hsize)\n\nfor i := 0; i &amp;lt; cpus; i++ {\n    buf[i] = make([]Color, vsize*hsize)\n}\n\nch := make(chan int, cpus)\n\nsamplesCPU := samples / cpus\n\nfor i := 0; i &amp;lt; cpus; i++ {\n    go func(i int) {\n        for s := 0; s &amp;lt; samplesCPU; s++ {\n            source := rand.NewSource(time.Now().UnixNano())\n            generator := rand.New(source) // without using custom generator for each sample, it gets very slow, because of mutex lock\n            for y := vsize - 1; y &amp;gt;= 0; y-- {\n                for x := 0; x &amp;lt; hsize; x++ {\n                    // calculate sample here\n\n                    buf[i][y*hsize+x] = buf[i][y*hsize+x].Add(col) // add pixel value to temporary buffer, it&amp;#39;ll get all averaged later\n                }\n            }\n        }\n        ch &amp;lt;- 1\n    }(i)\n}\n\nfor i := 0; i &amp;lt; cpus; i++ {\n    &amp;lt;-ch\n}\nclose(ch)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I noticed another weird thing: when I use goroutines, but set my program to render on one core, I can see in the Task Manager that my program doesn&amp;#39;t use only one core on 100%, but it uses multiple cores on low %. What am I missing here?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "frqerw", "is_robot_indexable": true, "report_reasons": null, "author": "knur2172", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/frqerw/my_program_is_slower_when_it_comes_to_time_spent/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/frqerw/my_program_is_slower_when_it_comes_to_time_spent/", "subreddit_subscribers": 107315, "created_utc": 1585573430.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hey guys,  \nToday I have completed an [**#opensource**](https://www.linkedin.com/feed/hashtag/?keywords=opensource&amp;highlightedUpdateUrns=urn%3Ali%3Aactivity%3A6650351024202702848) project that I've built especially [**#devops**](https://www.linkedin.com/feed/hashtag/?keywords=devops&amp;highlightedUpdateUrns=urn%3Ali%3Aactivity%3A6650351024202702848) enthusiasts &amp; I call it [**#kubeact**](https://www.linkedin.com/feed/hashtag/?keywords=kubeact&amp;highlightedUpdateUrns=urn%3Ali%3Aactivity%3A6650351024202702848) .  \nIt is a package for [**#Kubernetes**](https://www.linkedin.com/feed/hashtag/?keywords=kubernetes&amp;highlightedUpdateUrns=urn%3Ali%3Aactivity%3A6650351024202702848) ([**#K8s**](https://www.linkedin.com/feed/hashtag/?keywords=k8s&amp;highlightedUpdateUrns=urn%3Ali%3Aactivity%3A6650351024202702848)) to deploy and host your own runners on the cluster to run jobs in your [**#githubactions**](https://www.linkedin.com/feed/hashtag/?keywords=githubactions&amp;highlightedUpdateUrns=urn%3Ali%3Aactivity%3A6650351024202702848) workflows. It makes it easy to automate all your software workflows, now with world-class CI/CD. Build, test, and deploy your code right from [**#GitHub**](https://www.linkedin.com/feed/hashtag/?keywords=github&amp;highlightedUpdateUrns=urn%3Ali%3Aactivity%3A6650351024202702848).  \nCheckout : [https://github.com/itsksaurabh/kubeact](https://github.com/itsksaurabh/kubeact)\n\n&amp;#x200B;\n\nFeel free to review and contribute \ud83c\udf7b\n\n[https:\\/\\/github.com\\/itsksaurabh\\/kubeact](https://preview.redd.it/pigrrip3ssp41.jpg?width=847&amp;format=pjpg&amp;auto=webp&amp;s=a810e3c237240168348d352b26502d057d01d7fc)", "author_fullname": "t2_4mci82xc", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "KubeAct - A Helm chart for hosting your own runner on Kubernetes to run jobs in your GitHub Actions workflows. \u2638\ufe0f \ud83d\ude80", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "media_metadata": {"pigrrip3ssp41": {"status": "valid", "e": "Image", "m": "image/jpg", "p": [{"y": 60, "x": 108, "u": "https://external-preview.redd.it/pigrrip3ssp41.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=442b81cb8a13c334af358eaeb5b91cf365c130f1"}, {"y": 120, "x": 216, "u": "https://external-preview.redd.it/pigrrip3ssp41.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=f9d5aeb8c10696723545f66731d30b318b772a45"}, {"y": 178, "x": 320, "u": "https://external-preview.redd.it/pigrrip3ssp41.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=0901b1489fcfe01c06726b8ee46be114353038d9"}, {"y": 356, "x": 640, "u": "https://external-preview.redd.it/pigrrip3ssp41.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=5dbf70b1411424807282a0ddb01387b9e2af7ef8"}], "s": {"y": 472, "x": 847, "u": "https://preview.redd.it/pigrrip3ssp41.jpg?width=847&amp;format=pjpg&amp;auto=webp&amp;s=a810e3c237240168348d352b26502d057d01d7fc"}, "id": "pigrrip3ssp41"}}, "name": "t3_frpag4", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": true, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1585597497.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hey guys,&lt;br/&gt;\nToday I have completed an &lt;a href=\"https://www.linkedin.com/feed/hashtag/?keywords=opensource&amp;amp;highlightedUpdateUrns=urn%3Ali%3Aactivity%3A6650351024202702848\"&gt;&lt;strong&gt;#opensource&lt;/strong&gt;&lt;/a&gt; project that I&amp;#39;ve built especially &lt;a href=\"https://www.linkedin.com/feed/hashtag/?keywords=devops&amp;amp;highlightedUpdateUrns=urn%3Ali%3Aactivity%3A6650351024202702848\"&gt;&lt;strong&gt;#devops&lt;/strong&gt;&lt;/a&gt; enthusiasts &amp;amp; I call it &lt;a href=\"https://www.linkedin.com/feed/hashtag/?keywords=kubeact&amp;amp;highlightedUpdateUrns=urn%3Ali%3Aactivity%3A6650351024202702848\"&gt;&lt;strong&gt;#kubeact&lt;/strong&gt;&lt;/a&gt; .&lt;br/&gt;\nIt is a package for &lt;a href=\"https://www.linkedin.com/feed/hashtag/?keywords=kubernetes&amp;amp;highlightedUpdateUrns=urn%3Ali%3Aactivity%3A6650351024202702848\"&gt;&lt;strong&gt;#Kubernetes&lt;/strong&gt;&lt;/a&gt; (&lt;a href=\"https://www.linkedin.com/feed/hashtag/?keywords=k8s&amp;amp;highlightedUpdateUrns=urn%3Ali%3Aactivity%3A6650351024202702848\"&gt;&lt;strong&gt;#K8s&lt;/strong&gt;&lt;/a&gt;) to deploy and host your own runners on the cluster to run jobs in your &lt;a href=\"https://www.linkedin.com/feed/hashtag/?keywords=githubactions&amp;amp;highlightedUpdateUrns=urn%3Ali%3Aactivity%3A6650351024202702848\"&gt;&lt;strong&gt;#githubactions&lt;/strong&gt;&lt;/a&gt; workflows. It makes it easy to automate all your software workflows, now with world-class CI/CD. Build, test, and deploy your code right from &lt;a href=\"https://www.linkedin.com/feed/hashtag/?keywords=github&amp;amp;highlightedUpdateUrns=urn%3Ali%3Aactivity%3A6650351024202702848\"&gt;&lt;strong&gt;#GitHub&lt;/strong&gt;&lt;/a&gt;.&lt;br/&gt;\nCheckout : &lt;a href=\"https://github.com/itsksaurabh/kubeact\"&gt;https://github.com/itsksaurabh/kubeact&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;Feel free to review and contribute \ud83c\udf7b&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://preview.redd.it/pigrrip3ssp41.jpg?width=847&amp;amp;format=pjpg&amp;amp;auto=webp&amp;amp;s=a810e3c237240168348d352b26502d057d01d7fc\"&gt;https://github.com/itsksaurabh/kubeact&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "frpag4", "is_robot_indexable": true, "report_reasons": null, "author": "itsksaurabh", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/frpag4/kubeact_a_helm_chart_for_hosting_your_own_runner/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/frpag4/kubeact_a_helm_chart_for_hosting_your_own_runner/", "subreddit_subscribers": 107315, "created_utc": 1585568697.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "I've recently found this blog https://blog.filippo.io/rustgo/ Have anyone tried to implement this? Does really works?", "author_fullname": "t2_49w9yhhw", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Call rust from golang", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_freknn", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 10, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 10, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1585549217.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;ve recently found this blog &lt;a href=\"https://blog.filippo.io/rustgo/\"&gt;https://blog.filippo.io/rustgo/&lt;/a&gt; Have anyone tried to implement this? Does really works?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "freknn", "is_robot_indexable": true, "report_reasons": null, "author": "hmcarnice", "discussion_type": null, "num_comments": 6, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/freknn/call_rust_from_golang/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/freknn/call_rust_from_golang/", "subreddit_subscribers": 107315, "created_utc": 1585520417.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hi,\n\nI need to access a member (\"imm_data\") of an anonymous union in a C structure:\n\n\tstruct ibv_send_wr {\n\t\t\t...\n\t        union {\n\t                __be32                  imm_data;\n\t                uint32_t                invalidate_rkey;\n\t        };\n\nHowever, when compiling this with GCCGO it cannot find the reference:\n\n\tvar sendWr C.struct_ibv_send_wr\n    if imm &gt; 0 {\n\t\t\t...\n            sendWr.imm_data = C.uint32_t(imm)\n    }\n\n\n```\nerror: reference to undefined field or method \u2018imm_data\u2019\n```\n\nFor background, this is from the Infiniband kernel driver and this member was previously not in a union - and that worked.\n\nI'm not a Go programmer, unfortunately.\n\nCan anyone help?\n\nMany thanks!", "author_fullname": "t2_ywk1f", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Access a member in an anonymous C structure from Go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_frnq02", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1585589784.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hi,&lt;/p&gt;\n\n&lt;p&gt;I need to access a member (&amp;quot;imm_data&amp;quot;) of an anonymous union in a C structure:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;struct ibv_send_wr {\n        ...\n        union {\n                __be32                  imm_data;\n                uint32_t                invalidate_rkey;\n        };\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, when compiling this with GCCGO it cannot find the reference:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;var sendWr C.struct_ibv_send_wr\nif imm &amp;gt; 0 {\n        ...\n        sendWr.imm_data = C.uint32_t(imm)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;\nerror: reference to undefined field or method \u2018imm_data\u2019\n&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;For background, this is from the Infiniband kernel driver and this member was previously not in a union - and that worked.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m not a Go programmer, unfortunately.&lt;/p&gt;\n\n&lt;p&gt;Can anyone help?&lt;/p&gt;\n\n&lt;p&gt;Many thanks!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "frnq02", "is_robot_indexable": true, "report_reasons": null, "author": "veryflatcat", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/frnq02/access_a_member_in_an_anonymous_c_structure_from/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/frnq02/access_a_member_in_an_anonymous_c_structure_from/", "subreddit_subscribers": 107315, "created_utc": 1585560984.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "This is my first language that has pointers, so forgive me if this is a silly question.\n\nI was looking at the `http` package yesterday and I saw this snippet of code: \n\n```\nclient := &amp;http.Client{\n   CheckRedirect: redirectPolicyFunc,\n}\n\nresp, err := client.Get(\"http://example.com\")\n// ...\n\nreq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n// ...\nreq.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`)\nresp, err := client.Do(req)\n// ...\n```\n\nOn the first line, why do they write `client := &amp;http.Client` instead of just `client := http.Client`? What practical differences does this mean?\n\n`client` now holds the reference to the `http.Client` struct instead of the struct itself. But when you call `client.Get`, it gets dereferenced anyway. Why not just use the `client` variable for the struct itself instead of the pointer to it?\n\nAlso, please tell me if any of my terminology is wrong!", "author_fullname": "t2_1ajtp69", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Question about pointers and references from a Golang learner", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_frne8v", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1585587987.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;This is my first language that has pointers, so forgive me if this is a silly question.&lt;/p&gt;\n\n&lt;p&gt;I was looking at the &lt;code&gt;http&lt;/code&gt; package yesterday and I saw this snippet of code: &lt;/p&gt;\n\n&lt;p&gt;```\nclient := &amp;amp;http.Client{\n   CheckRedirect: redirectPolicyFunc,\n}&lt;/p&gt;\n\n&lt;p&gt;resp, err := client.Get(&amp;quot;&lt;a href=\"http://example.com%22\"&gt;http://example.com&amp;quot;&lt;/a&gt;)\n// ...&lt;/p&gt;\n\n&lt;p&gt;req, err := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;&lt;a href=\"http://example.com\"&gt;http://example.com&lt;/a&gt;&amp;quot;, nil)\n// ...\nreq.Header.Add(&amp;quot;If-None-Match&amp;quot;, &lt;code&gt;W/&amp;quot;wyzzy&amp;quot;&lt;/code&gt;)\nresp, err := client.Do(req)\n// ...\n```&lt;/p&gt;\n\n&lt;p&gt;On the first line, why do they write &lt;code&gt;client := &amp;amp;http.Client&lt;/code&gt; instead of just &lt;code&gt;client := http.Client&lt;/code&gt;? What practical differences does this mean?&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;client&lt;/code&gt; now holds the reference to the &lt;code&gt;http.Client&lt;/code&gt; struct instead of the struct itself. But when you call &lt;code&gt;client.Get&lt;/code&gt;, it gets dereferenced anyway. Why not just use the &lt;code&gt;client&lt;/code&gt; variable for the struct itself instead of the pointer to it?&lt;/p&gt;\n\n&lt;p&gt;Also, please tell me if any of my terminology is wrong!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "frne8v", "is_robot_indexable": true, "report_reasons": null, "author": "samjmckenzie", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/frne8v/question_about_pointers_and_references_from_a/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/frne8v/question_about_pointers_and_references_from_a/", "subreddit_subscribers": 107315, "created_utc": 1585559187.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_frne8v", "before": null}}