{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "I have a simple goroutine that acts as a poller and executes a function every x minutes based on an interval passed in.\n\nI currently create my error channel in the factory method of the poller and then if there's an error pass the error into the channel and then return the error channel from the function if the goroutine is stopped.\n\n    func (p *Poller) Start() &lt;-chan error {\n    \tgo func() {\n    \t\tlogrus.Info(\"polling initialized. Status: Running\")\n    \t\tdefer close(p.Errs)\n    \t\tfor {\n    \t\t\tselect {\n    \t\t\tcase &lt;-p.interval.C:\n    \t\t\t\terr := p.HandlerFunc()\n    \t\t\t\tif err != nil {\n    \t\t\t\t\tp.Errs &lt;- err\n    \t\t\t\t\treturn\n    \t\t\t\t}\n    \t\t\tcase &lt;-p.done:\n    \t\t\t\tlogrus.Info(\"polling shutting down. Status: stopped.\")\n    \t\t\t\treturn\n    \t\t\t}\n    \t\t}\n    \t}()\n    \n    \treturn p.Errs\n    }\n\nI then just check for errors when I run the poller\n\n    errChan := poller.Start()\nfor err := range errChan {\n if err != nil {\n logrus.Fatalf(\"fatal error: %s\", err)\n   }\n}\n\nIs there a more 'go like' way to handle the error within a goroutine? I'm not 100% sure this is the correct approach. \n\nAny advice would be greatly appreciated!", "author_fullname": "t2_12624y", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Error handling within a goroutine", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fz27nl", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 8, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 8, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1586630047.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I have a simple goroutine that acts as a poller and executes a function every x minutes based on an interval passed in.&lt;/p&gt;\n\n&lt;p&gt;I currently create my error channel in the factory method of the poller and then if there&amp;#39;s an error pass the error into the channel and then return the error channel from the function if the goroutine is stopped.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (p *Poller) Start() &amp;lt;-chan error {\n    go func() {\n        logrus.Info(&amp;quot;polling initialized. Status: Running&amp;quot;)\n        defer close(p.Errs)\n        for {\n            select {\n            case &amp;lt;-p.interval.C:\n                err := p.HandlerFunc()\n                if err != nil {\n                    p.Errs &amp;lt;- err\n                    return\n                }\n            case &amp;lt;-p.done:\n                logrus.Info(&amp;quot;polling shutting down. Status: stopped.&amp;quot;)\n                return\n            }\n        }\n    }()\n\n    return p.Errs\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I then just check for errors when I run the poller&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;errChan := poller.Start()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;for err := range errChan {\n if err != nil {\n logrus.Fatalf(&amp;quot;fatal error: %s&amp;quot;, err)\n   }\n}&lt;/p&gt;\n\n&lt;p&gt;Is there a more &amp;#39;go like&amp;#39; way to handle the error within a goroutine? I&amp;#39;m not 100% sure this is the correct approach. &lt;/p&gt;\n\n&lt;p&gt;Any advice would be greatly appreciated!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fz27nl", "is_robot_indexable": true, "report_reasons": null, "author": "nippyeyes", "discussion_type": null, "num_comments": 7, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/fz27nl/error_handling_within_a_goroutine/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/fz27nl/error_handling_within_a_goroutine/", "subreddit_subscribers": 108571, "created_utc": 1586601247.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "[https://github.com/cuelang/cue/releases/tag/v0.1.0](https://github.com/cuelang/cue/releases/tag/v0.1.0)\n\nDid you know Cue is the younger sibling of Go? Lots of go sources in Cue and being built by a member of the Go team.  \n\n\nhttps://cuelang.org\n\n&amp;#x200B;", "author_fullname": "t2_fgf9d", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Cuelang v0.1.0 is out.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fykhox", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 79, "total_awards_received": 1, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 79, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1586569103.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;a href=\"https://github.com/cuelang/cue/releases/tag/v0.1.0\"&gt;https://github.com/cuelang/cue/releases/tag/v0.1.0&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Did you know Cue is the younger sibling of Go? Lots of go sources in Cue and being built by a member of the Go team.  &lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://cuelang.org\"&gt;https://cuelang.org&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [{"giver_coin_reward": 0, "subreddit_id": null, "is_new": false, "days_of_drip_extension": 0, "coin_price": 150, "id": "award_5fb42699-4911-42a2-884c-6fc8bdc36059", "penny_donate": 0, "coin_reward": 0, "icon_url": "https://i.redd.it/award_images/t5_22cerq/aoa99054n2s41_Cake.png", "days_of_premium": 0, "icon_height": 2048, "resized_icons": [{"url": "https://preview.redd.it/award_images/t5_22cerq/aoa99054n2s41_Cake.png?width=16&amp;height=16&amp;auto=webp&amp;s=8a73104628a144bb70a126193fad2b162adec6db", "width": 16, "height": 16}, {"url": "https://preview.redd.it/award_images/t5_22cerq/aoa99054n2s41_Cake.png?width=32&amp;height=32&amp;auto=webp&amp;s=c478cdc0e0786be2b0171177869fc9e4cab24c80", "width": 32, "height": 32}, {"url": "https://preview.redd.it/award_images/t5_22cerq/aoa99054n2s41_Cake.png?width=48&amp;height=48&amp;auto=webp&amp;s=aeb6b147b887352980fe57f76127e258b3d5c93c", "width": 48, "height": 48}, {"url": "https://preview.redd.it/award_images/t5_22cerq/aoa99054n2s41_Cake.png?width=64&amp;height=64&amp;auto=webp&amp;s=cd1b0ac0a65061d485ddd6bffb57950d79843835", "width": 64, "height": 64}, {"url": "https://preview.redd.it/award_images/t5_22cerq/aoa99054n2s41_Cake.png?width=128&amp;height=128&amp;auto=webp&amp;s=5c3a17245fec315bb2a4fd7d607df7ec58b26e8a", "width": 128, "height": 128}], "icon_width": 2048, "start_date": null, "is_enabled": true, "description": "Did someone say... cake?", "end_date": null, "subreddit_coin_reward": 0, "count": 1, "name": "Cake", "icon_format": "PNG", "award_sub_type": "APPRECIATION", "penny_price": 0, "award_type": "global"}], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fykhox", "is_robot_indexable": true, "report_reasons": null, "author": "verdverm", "discussion_type": null, "num_comments": 11, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/fykhox/cuelang_v010_is_out/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/fykhox/cuelang_v010_is_out/", "subreddit_subscribers": 108571, "created_utc": 1586540303.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "https://github.com/KarpelesLab/iso9660\n\nThis was forked from https://github.com/kdomanski/iso9660 and modified as to allow serving dynamic ISO images over http.\n\nChanges:\n\n* do not use a staging directory, but instead store state in memory and do not copy data from files until the time comes\n* Expose primary descriptor structure in writer.Primary for easy modification (volume name, date, etc)\n* write to io.Writer so output can be streamed (to a http.ResponseWriter for example)\n* support for El Torito bootable images (EFI not tested. I'll implement isohybrid bootable images eventually if there's some interest)\n* Removed bugs, probably added some others. Bug reports are welcome.", "author_fullname": "t2_45a19", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "iso9660 v0.1.2 - generate iso images on the fly and stream over http or write to file", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fz1b4i", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 4, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 4, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1586626783.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;a href=\"https://github.com/KarpelesLab/iso9660\"&gt;https://github.com/KarpelesLab/iso9660&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;This was forked from &lt;a href=\"https://github.com/kdomanski/iso9660\"&gt;https://github.com/kdomanski/iso9660&lt;/a&gt; and modified as to allow serving dynamic ISO images over http.&lt;/p&gt;\n\n&lt;p&gt;Changes:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;do not use a staging directory, but instead store state in memory and do not copy data from files until the time comes&lt;/li&gt;\n&lt;li&gt;Expose primary descriptor structure in writer.Primary for easy modification (volume name, date, etc)&lt;/li&gt;\n&lt;li&gt;write to io.Writer so output can be streamed (to a http.ResponseWriter for example)&lt;/li&gt;\n&lt;li&gt;support for El Torito bootable images (EFI not tested. I&amp;#39;ll implement isohybrid bootable images eventually if there&amp;#39;s some interest)&lt;/li&gt;\n&lt;li&gt;Removed bugs, probably added some others. Bug reports are welcome.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fz1b4i", "is_robot_indexable": true, "report_reasons": null, "author": "MagicalTux", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/fz1b4i/iso9660_v012_generate_iso_images_on_the_fly_and/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/fz1b4i/iso9660_v012_generate_iso_images_on_the_fly_and/", "subreddit_subscribers": 108571, "created_utc": 1586597983.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "I always have a similar structure to loading configurations and validating them on all my projects, I exported them inside a package and created `configuro`.\n\nIt provides the set of features you would want to implement 12-Factor compliant config and be container ready. **It has one defined strategy to load configurations** while only exposing a few options for simplicity.\n\nTell me what do you think.  \n[https://github.com/sherifabdlnaby/configuro](https://github.com/sherifabdlnaby/configuro)", "author_fullname": "t2_i9xrk", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Configuro - an opinionated configuration loading and validation framework focused towards Containerized and 12-Factor compliant applications.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fynphn", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 30, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 30, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1586578317.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I always have a similar structure to loading configurations and validating them on all my projects, I exported them inside a package and created &lt;code&gt;configuro&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;It provides the set of features you would want to implement 12-Factor compliant config and be container ready. &lt;strong&gt;It has one defined strategy to load configurations&lt;/strong&gt; while only exposing a few options for simplicity.&lt;/p&gt;\n\n&lt;p&gt;Tell me what do you think.&lt;br/&gt;\n&lt;a href=\"https://github.com/sherifabdlnaby/configuro\"&gt;https://github.com/sherifabdlnaby/configuro&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fynphn", "is_robot_indexable": true, "report_reasons": null, "author": "SherifAbdelNaby", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/fynphn/configuro_an_opinionated_configuration_loading/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/fynphn/configuro_an_opinionated_configuration_loading/", "subreddit_subscribers": 108571, "created_utc": 1586549517.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "So I want to write an API for a sort of worker pool which would look something like this, if I user tries to use my API in their go code\n\n    wp := NewWorkerPool()\n    tasks := []task{...}\n    // start the background task in goroutines\n    wp.StartWorkers()\n    // StartWorkers is non blocking, you can go about your business after starting it\n    // you can also stop all the workers before they finish\n    wp.StopWorkers()\n\nThe worker pool starts a bunch of unix processes like sleep or ls or some curl request, so the tasks are actually names of commands and arguments.\n\nI want the StartWorkers to be a non-blocking call itself. I also want the following features.\n\n    All the processes are started as background goroutines\n    In case of a crash or failure they are restarted\n    They can also be stopped midway before they complete\n\nNow I want my workers to communicate their state back to the worker pool so that it can take necessary actions based on that.\n\nThis is what I wrote pool.go\n\n\n    type Pool struct {\n      // chan for a successfull completion signal\n      completed chan struct{}\n      // chan for a crash signal\n      crashed chan *worker\n       // wait group to keep a number of running processes\n       procCounter *sync.WaitGroup\n       // a state of all child processes\n       children []*worker\n   }\n\n       func New(processes []*Process) *Pool {\n        var childProcesses []*worker\n          for _, proc := range processes {\n           childProcesses = append(childProcesses, newWorker(proc))\n        }\n\n      return &amp;Pool{\n        completed:   make(chan struct{}),\n        crashed:     make(chan *worker),\n        procCounter: &amp;sync.WaitGroup{},\n        children:    childProcesses,\n      }\n   }\n\n    func (p *Pool) StartWorkers() {\n      for _, child := range p.children {\n        p.procCounter.Add(1)\n        childWorker := child\n        childWorker.start(p.crashed, p.completed)\n      }\n\n    // listen for crashes/completions of all running processes\n      go func() {\n        for {\n            select {\n            case &lt;-p.completed:\n                p.procCounter.Done()\n            case worker := &lt;-p.crashed:\n             // in case we get a crashed signal we start the processes again\n                p.restartProcess(worker)\n            }\n        }\n      }()\n\n      // putting the wait call in a goroutine since I want `StopProcess` to be non-blocking at its call site\n      go func() {\n        p.procCounter.Wait()\n        close(p.completed)\n        close(p.crashed)\n       }()\n    }\n\n     // StopWorkers can be used to stop all the child processes.\n    func (p *Supervisor) StopWorker() {\n      for _, child := range p.children {\n        p.StopProcess(child)\n      }\n    }\n\n    // restart worker in case of a crash\n    func (p *Supervisor) restartProcess(proc *worker) {\n      proc.start(p.crashed, p.completed)\n    }\n\nThis is worker.go\n\n    type worker struct {\n       status  string\n      command *exec.Cmd\n    }\n\n    func newWorker(proc *Process) *worker {\n        cmd := exec.Command(proc.Executable, proc.Args...)\n        cmd.Env = proc.Env\n        return &amp;worker{\n            status:  \"ready\",\n            command: cmd,\n        }\n    }\n\n    func (w *worker) start(crashed chan *worker, completed chan struct{}) chan *worker {\n        w.status = \"running\"\n        err := w.command.Run()\n        if err != nil {\n            fmt.Println(err)\n            // signal a crash\n            w.status = \"crashed\"\n            crashed &lt;- w\n            return\n        }\n        // signal successful completion\n        completed &lt;- struct{}{}\n       return restart\n    }\n\n    func (w *worker) stop(crashed chan *worker, completed chan struct{}) {\n     // stop the process\n     w.status = \"stopped\"\n     err := w.command.Process.Kill()\n     if err != nil {\n        fmt.Println(\"couldn't kill process\")\n     }\n     completed &lt;- struct{}{}\n    }\n\nBut this code deadlocks on running it, someone also mentioned to me that it is an anti pattern to have multiple writers to the same channel.\n\nIs there a good way to do this? I want my worker pool to act as a monitor or a supervisor to start all the processes in the background and restart them if they crash or stop them if the user wants to kill them before they finish\n\nAnother thing I am struggling with is that I can't figure out a way to exit from this infinite for when all my processes have completed and none are running, not sure what case statement to use here\n\n    go func() {\n        for {\n            select {\n            case &lt;-p.completed:\n                p.procCounter.Done()\n            case worker := &lt;-p.crashed:\n             // in case we get a crashed signal we start the processes again\n                p.restartProcess(worker)\n            }\n        }\n        }()", "author_fullname": "t2_6s2uku", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How to properly communicate between goroutines to start, restart or stop them?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_fz3vvw", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1586607348.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1586635968.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;So I want to write an API for a sort of worker pool which would look something like this, if I user tries to use my API in their go code&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;wp := NewWorkerPool()\ntasks := []task{...}\n// start the background task in goroutines\nwp.StartWorkers()\n// StartWorkers is non blocking, you can go about your business after starting it\n// you can also stop all the workers before they finish\nwp.StopWorkers()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The worker pool starts a bunch of unix processes like sleep or ls or some curl request, so the tasks are actually names of commands and arguments.&lt;/p&gt;\n\n&lt;p&gt;I want the StartWorkers to be a non-blocking call itself. I also want the following features.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;All the processes are started as background goroutines\nIn case of a crash or failure they are restarted\nThey can also be stopped midway before they complete\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now I want my workers to communicate their state back to the worker pool so that it can take necessary actions based on that.&lt;/p&gt;\n\n&lt;p&gt;This is what I wrote pool.go&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Pool struct {\n  // chan for a successfull completion signal\n  completed chan struct{}\n  // chan for a crash signal\n  crashed chan *worker\n   // wait group to keep a number of running processes\n   procCounter *sync.WaitGroup\n   // a state of all child processes\n   children []*worker\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;}&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;   func New(processes []*Process) *Pool {\n    var childProcesses []*worker\n      for _, proc := range processes {\n       childProcesses = append(childProcesses, newWorker(proc))\n    }\n\n  return &amp;amp;Pool{\n    completed:   make(chan struct{}),\n    crashed:     make(chan *worker),\n    procCounter: &amp;amp;sync.WaitGroup{},\n    children:    childProcesses,\n  }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;}&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (p *Pool) StartWorkers() {\n  for _, child := range p.children {\n    p.procCounter.Add(1)\n    childWorker := child\n    childWorker.start(p.crashed, p.completed)\n  }\n\n// listen for crashes/completions of all running processes\n  go func() {\n    for {\n        select {\n        case &amp;lt;-p.completed:\n            p.procCounter.Done()\n        case worker := &amp;lt;-p.crashed:\n         // in case we get a crashed signal we start the processes again\n            p.restartProcess(worker)\n        }\n    }\n  }()\n\n  // putting the wait call in a goroutine since I want `StopProcess` to be non-blocking at its call site\n  go func() {\n    p.procCounter.Wait()\n    close(p.completed)\n    close(p.crashed)\n   }()\n}\n\n // StopWorkers can be used to stop all the child processes.\nfunc (p *Supervisor) StopWorker() {\n  for _, child := range p.children {\n    p.StopProcess(child)\n  }\n}\n\n// restart worker in case of a crash\nfunc (p *Supervisor) restartProcess(proc *worker) {\n  proc.start(p.crashed, p.completed)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is worker.go&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type worker struct {\n   status  string\n  command *exec.Cmd\n}\n\nfunc newWorker(proc *Process) *worker {\n    cmd := exec.Command(proc.Executable, proc.Args...)\n    cmd.Env = proc.Env\n    return &amp;amp;worker{\n        status:  &amp;quot;ready&amp;quot;,\n        command: cmd,\n    }\n}\n\nfunc (w *worker) start(crashed chan *worker, completed chan struct{}) chan *worker {\n    w.status = &amp;quot;running&amp;quot;\n    err := w.command.Run()\n    if err != nil {\n        fmt.Println(err)\n        // signal a crash\n        w.status = &amp;quot;crashed&amp;quot;\n        crashed &amp;lt;- w\n        return\n    }\n    // signal successful completion\n    completed &amp;lt;- struct{}{}\n   return restart\n}\n\nfunc (w *worker) stop(crashed chan *worker, completed chan struct{}) {\n // stop the process\n w.status = &amp;quot;stopped&amp;quot;\n err := w.command.Process.Kill()\n if err != nil {\n    fmt.Println(&amp;quot;couldn&amp;#39;t kill process&amp;quot;)\n }\n completed &amp;lt;- struct{}{}\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;But this code deadlocks on running it, someone also mentioned to me that it is an anti pattern to have multiple writers to the same channel.&lt;/p&gt;\n\n&lt;p&gt;Is there a good way to do this? I want my worker pool to act as a monitor or a supervisor to start all the processes in the background and restart them if they crash or stop them if the user wants to kill them before they finish&lt;/p&gt;\n\n&lt;p&gt;Another thing I am struggling with is that I can&amp;#39;t figure out a way to exit from this infinite for when all my processes have completed and none are running, not sure what case statement to use here&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;go func() {\n    for {\n        select {\n        case &amp;lt;-p.completed:\n            p.procCounter.Done()\n        case worker := &amp;lt;-p.crashed:\n         // in case we get a crashed signal we start the processes again\n            p.restartProcess(worker)\n        }\n    }\n    }()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fz3vvw", "is_robot_indexable": true, "report_reasons": null, "author": "fenster25", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/fz3vvw/how_to_properly_communicate_between_goroutines_to/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/fz3vvw/how_to_properly_communicate_between_goroutines_to/", "subreddit_subscribers": 108571, "created_utc": 1586607168.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Title probably doesn't make much sense, but I'll try to explains as best as I can. I am working on an experiment with a golang package for ssh based IT automation like Ansible, but no yaml ([https://github.com/krilor/gossh](https://github.com/krilor/gossh)). I'm hoping to get some input on the API.\n\nA core part of the problem I'm working on is the ability to do \"stuff\" on remote (or local) targets, either as the logged in user or as another user - aka sudo. A target interface would maybe have 30 methods. I've been thinking about three ways to go about the interface for the target.\n\nWhat do you think about these? Do you see any problems or benefits with either? Do you know any good examples where any of these patterns have been used (or articles discussing it)? Do I have other options? What would you do?\n\nI've outlined the patterns below, with just a subset of methods.\n\n**1 - Add user as a param to all methods**\n\n```go\ntype Target interface {\n  Create(user, path string) (io.WriteCloser, error)\n  Run(user, cmd string) Response, error\n  Mkdir(user, path string) error\n  ...\n}\n```\n\n**2 - Add duplicate methods with the user param to all methods**\n\nThe non-*As methods will just be calls to *As, with the current user specified.\n\n```go\ntype Target interface {\n  Create(path string) (io.WriteCloser, error)\n  CreateAs(user, path string) (io.WriteCloser, error)\n  Run(cmd string) Response, error\n  RunAs(user, cmd string) Response, error\n  Mkdir(path string) error\n  MkdirAs(user, path string) error\n  ...\n}\n```\n**3 - Add a separate method for getting a wrapped target with the new user.\n\nUsage would be like `f, err := t.As(\"anotheruser\").Create(\"/some/path\").\n\n```go\ntype Target interface {\n  As(user string) Target\n\n  Create(path string) (io.WriteCloser, error)\n  Run(cmd string) Response, error\n  Mkdir(path string) error\n  ...\n}\n```", "author_fullname": "t2_1qj6kl2t", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Package API recommendation for almost-duplicate methods.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fyzkhj", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1586620594.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Title probably doesn&amp;#39;t make much sense, but I&amp;#39;ll try to explains as best as I can. I am working on an experiment with a golang package for ssh based IT automation like Ansible, but no yaml (&lt;a href=\"https://github.com/krilor/gossh\"&gt;https://github.com/krilor/gossh&lt;/a&gt;). I&amp;#39;m hoping to get some input on the API.&lt;/p&gt;\n\n&lt;p&gt;A core part of the problem I&amp;#39;m working on is the ability to do &amp;quot;stuff&amp;quot; on remote (or local) targets, either as the logged in user or as another user - aka sudo. A target interface would maybe have 30 methods. I&amp;#39;ve been thinking about three ways to go about the interface for the target.&lt;/p&gt;\n\n&lt;p&gt;What do you think about these? Do you see any problems or benefits with either? Do you know any good examples where any of these patterns have been used (or articles discussing it)? Do I have other options? What would you do?&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;ve outlined the patterns below, with just a subset of methods.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;1 - Add user as a param to all methods&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;go\ntype Target interface {\n  Create(user, path string) (io.WriteCloser, error)\n  Run(user, cmd string) Response, error\n  Mkdir(user, path string) error\n  ...\n}\n&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;2 - Add duplicate methods with the user param to all methods&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;The non-*As methods will just be calls to *As, with the current user specified.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;go\ntype Target interface {\n  Create(path string) (io.WriteCloser, error)\n  CreateAs(user, path string) (io.WriteCloser, error)\n  Run(cmd string) Response, error\n  RunAs(user, cmd string) Response, error\n  Mkdir(path string) error\n  MkdirAs(user, path string) error\n  ...\n}\n&lt;/code&gt;\n**3 - Add a separate method for getting a wrapped target with the new user.&lt;/p&gt;\n\n&lt;p&gt;Usage would be like `f, err := t.As(&amp;quot;anotheruser&amp;quot;).Create(&amp;quot;/some/path&amp;quot;).&lt;/p&gt;\n\n&lt;p&gt;```go\ntype Target interface {\n  As(user string) Target&lt;/p&gt;\n\n&lt;p&gt;Create(path string) (io.WriteCloser, error)\n  Run(cmd string) Response, error\n  Mkdir(path string) error\n  ...\n}\n```&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fyzkhj", "is_robot_indexable": true, "report_reasons": null, "author": "krilor", "discussion_type": null, "num_comments": 6, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/fyzkhj/package_api_recommendation_for_almostduplicate/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/fyzkhj/package_api_recommendation_for_almostduplicate/", "subreddit_subscribers": 108571, "created_utc": 1586591794.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "[https://github.com/harrybrwn/apizza](https://github.com/harrybrwn/apizza)\n\nMy hobby project is finally at a place where I'm comfortable sharing it with the world. Tell me what you think.", "author_fullname": "t2_zi7g2", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "CLI for ordering Dominos pizza", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fy2qya", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 246, "total_awards_received": 1, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 246, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {"gid_1": 1}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1586502394.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;a href=\"https://github.com/harrybrwn/apizza\"&gt;https://github.com/harrybrwn/apizza&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;My hobby project is finally at a place where I&amp;#39;m comfortable sharing it with the world. Tell me what you think.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [{"giver_coin_reward": null, "subreddit_id": null, "is_new": false, "days_of_drip_extension": 0, "coin_price": 100, "id": "gid_1", "penny_donate": null, "coin_reward": 0, "icon_url": "https://www.redditstatic.com/gold/awards/icon/silver_512.png", "days_of_premium": 0, "icon_height": 512, "resized_icons": [{"url": "https://www.redditstatic.com/gold/awards/icon/silver_16.png", "width": 16, "height": 16}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_32.png", "width": 32, "height": 32}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_48.png", "width": 48, "height": 48}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_64.png", "width": 64, "height": 64}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_128.png", "width": 128, "height": 128}], "icon_width": 512, "start_date": null, "is_enabled": true, "description": "Shows the Silver Award... and that's it.", "end_date": null, "subreddit_coin_reward": 0, "count": 1, "name": "Silver", "icon_format": null, "award_sub_type": "GLOBAL", "penny_price": null, "award_type": "global"}], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fy2qya", "is_robot_indexable": true, "report_reasons": null, "author": "harrybrown98", "discussion_type": null, "num_comments": 40, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/fy2qya/cli_for_ordering_dominos_pizza/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/fy2qya/cli_for_ordering_dominos_pizza/", "subreddit_subscribers": 108571, "created_utc": 1586473594.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "The Go programming language is awesome for many reasons including GC, fast compile, readability, etc.  I've wanted to start using Go for everything which eventually means graphics. However, any amount of research will expose the lack of 100% Go libraries. All there is, are bindings for GLFW, OpenGL, SMFL, Qt, etc all using CGO. Even libraries that tout a \"100% Go\" experience still contain CGO deep inside to interface with the os. It is well known that writing CGO is a downgrade from Go code as expressed [here](https://dave.cheney.net/2016/01/18/cgo-is-not-go). I know CGO has it's purpose: it can save tons of time from not having to write ports or to quickly interface with c libraries. But I want to take the position of a \"pure\" Go coder and only use Go.\n\nMy question is: Can a purely 100% Go graphics API be written?\n\nWhat answers I'm looking for:\n\n* Yes/No\n* By What Means\n* Further readings\n\nWhat I'm NOT looking for:\n\n* If it's hard or not\n* Benefits of CGO \n* Why I shouldn't care about the use of CGO", "author_fullname": "t2_hswep", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Is CGO Inevitable?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fynqlk", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1586578410.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;The Go programming language is awesome for many reasons including GC, fast compile, readability, etc.  I&amp;#39;ve wanted to start using Go for everything which eventually means graphics. However, any amount of research will expose the lack of 100% Go libraries. All there is, are bindings for GLFW, OpenGL, SMFL, Qt, etc all using CGO. Even libraries that tout a &amp;quot;100% Go&amp;quot; experience still contain CGO deep inside to interface with the os. It is well known that writing CGO is a downgrade from Go code as expressed &lt;a href=\"https://dave.cheney.net/2016/01/18/cgo-is-not-go\"&gt;here&lt;/a&gt;. I know CGO has it&amp;#39;s purpose: it can save tons of time from not having to write ports or to quickly interface with c libraries. But I want to take the position of a &amp;quot;pure&amp;quot; Go coder and only use Go.&lt;/p&gt;\n\n&lt;p&gt;My question is: Can a purely 100% Go graphics API be written?&lt;/p&gt;\n\n&lt;p&gt;What answers I&amp;#39;m looking for:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Yes/No&lt;/li&gt;\n&lt;li&gt;By What Means&lt;/li&gt;\n&lt;li&gt;Further readings&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;What I&amp;#39;m NOT looking for:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;If it&amp;#39;s hard or not&lt;/li&gt;\n&lt;li&gt;Benefits of CGO &lt;/li&gt;\n&lt;li&gt;Why I shouldn&amp;#39;t care about the use of CGO&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fynqlk", "is_robot_indexable": true, "report_reasons": null, "author": "TotallyGamerJet", "discussion_type": null, "num_comments": 9, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/fynqlk/is_cgo_inevitable/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/fynqlk/is_cgo_inevitable/", "subreddit_subscribers": 108571, "created_utc": 1586549610.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "I'm building a GO CRUD API that I would like to protect as much as possible.  I'm already issuing JWTs and providing access to certain handlers based on that user's level of access.  The problem is that the API is exposed and anyone can sniff out the calls I'm making, reverse engineer how JWTs are created and create their own front end, or automated tool to perform unauthenticated/authenticated calls to my API.  I'd like to avoid third-party apps from using the API, even if they properly authenticate a user and gain a proper JWT.\n\nMy first thought is an API key for the web front ends and mobile apps (when that part comes). But even if we're sending the key via HTTPS with the other payload, that can still be sniffed with a MITM attack, so it's pointless. How can I appropriately verify that API calls are coming from a legitimate source before processing the request?", "author_fullname": "t2_4e0o5awf", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Protect CRUD API against third-party app creation", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fyf4sr", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 11, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 11, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1586551054.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m building a GO CRUD API that I would like to protect as much as possible.  I&amp;#39;m already issuing JWTs and providing access to certain handlers based on that user&amp;#39;s level of access.  The problem is that the API is exposed and anyone can sniff out the calls I&amp;#39;m making, reverse engineer how JWTs are created and create their own front end, or automated tool to perform unauthenticated/authenticated calls to my API.  I&amp;#39;d like to avoid third-party apps from using the API, even if they properly authenticate a user and gain a proper JWT.&lt;/p&gt;\n\n&lt;p&gt;My first thought is an API key for the web front ends and mobile apps (when that part comes). But even if we&amp;#39;re sending the key via HTTPS with the other payload, that can still be sniffed with a MITM attack, so it&amp;#39;s pointless. How can I appropriately verify that API calls are coming from a legitimate source before processing the request?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fyf4sr", "is_robot_indexable": true, "report_reasons": null, "author": "dcreate12", "discussion_type": null, "num_comments": 16, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/fyf4sr/protect_crud_api_against_thirdparty_app_creation/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/fyf4sr/protect_crud_api_against_thirdparty_app_creation/", "subreddit_subscribers": 108571, "created_utc": 1586522254.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "What's the best way to learn best practices for gRPC Go and in depth. Always find myself guessing on how to do things. I know the basics like generating proto, calling rpc methods, streaming and implementing servers but I need a little bit more of a detailed guide. Do I just read everything in the gRPC go repo?\n\n&amp;#x200B;\n\nIf you know an excellent repo that uses all the features of gRPC please link it.", "author_fullname": "t2_l2rtc", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "gRPC Go resources", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fyj6ai", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 7, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 7, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1586565151.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;What&amp;#39;s the best way to learn best practices for gRPC Go and in depth. Always find myself guessing on how to do things. I know the basics like generating proto, calling rpc methods, streaming and implementing servers but I need a little bit more of a detailed guide. Do I just read everything in the gRPC go repo?&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;If you know an excellent repo that uses all the features of gRPC please link it.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fyj6ai", "is_robot_indexable": true, "report_reasons": null, "author": "awptakesnoskill", "discussion_type": null, "num_comments": 4, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/fyj6ai/grpc_go_resources/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/fyj6ai/grpc_go_resources/", "subreddit_subscribers": 108571, "created_utc": 1586536351.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_fyj6ai", "before": null}}