# cpp
## [1][C++ Jobs - Q4 2020](https://www.reddit.com/r/cpp/comments/j3qems/c_jobs_q4_2020/)
- url: https://www.reddit.com/r/cpp/comments/j3qems/c_jobs_q4_2020/
---
Rules For Individuals
---------------------

* **Don't** create top-level comments - those are for employers.
* Feel free to reply to top-level comments with **on-topic** questions.
* I will create top-level comments for **meta** discussion and **individuals looking for work**.

Rules For Employers
---------------------

* You must be hiring **directly**. No third-party recruiters.
* **One** top-level comment per employer. If you have multiple job openings, that's great, but please consolidate their descriptions or mention them in replies to your own top-level comment.
* **Don't** use URL shorteners. [reddiquette](https://www.reddithelp.com/en/categories/reddit-101/reddit-basics/reddiquette) forbids them because they're opaque to the spam filter.
* Templates are awesome. Please **use** the following template. As the "formatting help" says, use \*\*two stars\*\* to **bold text**. Use empty lines to separate sections.
* **Proofread** your comment after posting it, and edit any formatting mistakes.

---

\*\*Company:\*\* [Company name; also, use the "formatting help" to make it a link to your company's website, or a specific careers page if you have one.]

&amp;nbsp;

\*\*Type:\*\* [Full time, part time, internship, contract, etc.]

&amp;nbsp;

\*\*Description:\*\* [What does your company do, and what are you hiring C++ devs for? How much experience are you looking for, and what seniority levels are you hiring for? The more details you provide, the better.]

&amp;nbsp;

\*\*Location:\*\* [Where's your office - or if you're hiring at multiple offices, list them. If your workplace language isn't English, please specify it.]

&amp;nbsp;

\*\*Remote:\*\* [Do you offer the option of working remotely (permanently, or for the duration of the pandemic)? If so, do you require employees to live in certain areas or time zones?]

&amp;nbsp;

\*\*Visa Sponsorship:\*\* [Does your company sponsor visas?]

&amp;nbsp;

\*\*Technologies:\*\* [Required: do you mainly use C++98/03, C++11, C++14, C++17, or C++20? Optional: do you use Linux/Mac/Windows, are there languages you use in addition to C++, are there technologies like OpenGL or libraries like Boost that you need/want/like experience with, etc.]

&amp;nbsp;

\*\*Contact:\*\* [How do you want to be contacted? Email, reddit PM, telepathy, gravitational waves?]

---

Previous Post
--------------

* [C++ Jobs - Q3 2020](https://www.reddit.com/r/cpp/comments/hjnaf2/c_jobs_q3_2020/)
## [2][How C++ Programming Language Became the Invisible Foundation For Everything, and What's Next](https://www.reddit.com/r/cpp/comments/jug7ni/how_c_programming_language_became_the_invisible/)
- url: https://www.techrepublic.com/article/c-programming-language-how-it-became-the-invisible-foundation-for-everything-and-whats-next/
---

## [3][Stop learning C++ or keep going?](https://www.reddit.com/r/cpp/comments/ju1ikd/stop_learning_c_or_keep_going/)
- url: https://www.reddit.com/r/cpp/comments/ju1ikd/stop_learning_c_or_keep_going/
---
I picked C++ as my first language because I want to get into a video game company. It was difficult at first, but it gets easier over time, but still, hard nonetheless.

But then, something happened that force me to stay in my hometown until I die probably.

So, the ways for me to earn money from programming now are: create my own software/app/game, freelancing, or remote job.

Everybody wants to have a successful software that they can sell it for a stockpile of $$, but I'm going to go with the realistic view here and aim for the freelancing and remote job.

My question is, is C++ is a great language for me if I'm going to be a freelance and remote job? Or should I focus on another language? I'm still going to learn C++ though. I fell in love with it. I just going to assign more of my time to the new language and make C++ become my second language.

Now, a little background of me. I'm 20 years old boy from a third world country living in a very very small city that I think about 50% still using a non-smartphone as their phone and there's absolutely no company that engaged in technology. Most people either work as a farmer, livestock breeder, and things like that.

Don't get me wrong, I love my hometown. It is so peaceful here. I always said that my hometown is a perfect city for retirement.

But, that's the thing. I'm not planning for retirement, I'm still trying to get some money.

Also, I will not attend college. Well, "can't" is the more proper word here.

So yeah, any advice would be appreciated. Thank you so much

EDIT: I forgot to tell you that it's been only 2 months since I learn C++. I could make a number guess, tic tac toe, and dungeon crawler with object-oriented programming.

Also, I'm not asking for a way to earn fast money. I don't mind just keep learning for a year, or two, or three, or four. I just need to know is C++ is a good language for me in the long run
## [4][Meeting C++ 2020 Trip Report](https://www.reddit.com/r/cpp/comments/juald6/meeting_c_2020_trip_report/)
- url: https://codereport.github.io/MeetingCpp2020TripReport/
---

## [5][Some Shocking Facts You Probably Didn't Want to Know about U++ Framework...](https://www.reddit.com/r/cpp/comments/juiudg/some_shocking_facts_you_probably_didnt_want_to/)
- url: https://www.reddit.com/r/cpp/comments/juiudg/some_shocking_facts_you_probably_didnt_want_to/
---
...but I will tell you anyway.

Maybe somebody might find this something I have wrote over the last month interesting:

[https://www.codeproject.com/Articles/5280535/Some-Shocking-Facts-You-Probably-Didnt-Want-to-Kno](https://www.codeproject.com/Articles/5280535/Some-Shocking-Facts-You-Probably-Didnt-Want-to-Kno)
## [6][Literal suffix for std::integral_constant](https://www.reddit.com/r/cpp/comments/ju3poj/literal_suffix_for_stdintegral_constant/)
- url: https://www.reddit.com/r/cpp/comments/ju3poj/literal_suffix_for_stdintegral_constant/
---
What do you think about a Standard proposal for a new literal suffix of a std::integral\_constant instance?

    constexpr auto x=123ic; // same as `constexpr std::integral_constant&lt;int, 123&gt; x`;
    // maybe:
    constexpr auto str="some character literal"ic;

[View Poll](https://www.reddit.com/poll/ju3poj)
## [7][To join, or not to join](https://www.reddit.com/r/cpp/comments/ju6zwe/to_join_or_not_to_join/)
- url: https://www.reddit.com/r/cpp/comments/ju6zwe/to_join_or_not_to_join/
---
[P1293](https://wg21.link/p1293) ostream_joiner paper will not be further pursued.  
https://github.com/cplusplus/papers/issues/64  
  
The paper proposes to add the ostream_joiner.  
Which would make the following possible  
`vector&lt;int&gt; v = {1, 4, 6};`  
`copy(v.begin(), v.end(), ostream_joiner(cout, ", "));`  
Which prints "1, 4, 6"  
Without trailing comma, as ostream_iterator would do.  
  
I still think this would be a nice addition to the language.  
What do you think? Should it be further pursued?  
  
LEWG had asked to look at how concepts/ranges would impact the design.  
Ideas how concepts/ranges could impact or improve the design?  
  
Or could a format addition be used to achieve a similar result?
## [8][With the new module system in C++20 will there be centralized repositories for modules?](https://www.reddit.com/r/cpp/comments/ju1h1e/with_the_new_module_system_in_c20_will_there_be/)
- url: https://www.reddit.com/r/cpp/comments/ju1h1e/with_the_new_module_system_in_c20_will_there_be/
---
Like nuget's, npm's or crates?

Examples:

* Rust Crates [https://crates.io/](https://crates.io/)
* Node NPM's [https://www.npmjs.com/](https://www.npmjs.com/) 
* .NET Nuget's [https://www.nuget.org/](https://www.nuget.org/)
* Java [https://mvnrepository.com/](https://mvnrepository.com/)
## [9][Herb Sutter Trip report: Autumn ISO C++ standards meeting](https://www.reddit.com/r/cpp/comments/jtt9cb/herb_sutter_trip_report_autumn_iso_c_standards/)
- url: https://herbsutter.com/2020/11/13/trip-report-autumn-iso-c-standards-meeting-virtual/
---

## [10][Your opinion on 'for ... else' constructs](https://www.reddit.com/r/cpp/comments/ju6cag/your_opinion_on_for_else_constructs/)
- url: https://www.reddit.com/r/cpp/comments/ju6cag/your_opinion_on_for_else_constructs/
---
In Python the following construct is valid and quite helpful:

    for x in whatever:
        if condition(x):
            break
    else:
        print("for loop did not exit early")

In C++ the equivalent would be

    bool break_taken = false;
    for (auto x : whatever)
    {
        if (condition(x)) 
        {
            break_taken = true;
            break;
        }
    }
    if (!break_taken)
    {
        std::cout &lt;&lt; "for loop did not exit early\n";
    }

Simply said, you can add an `else` branch to a for loop, which gets taken if the `for` loop did not exit early because of a `break` statement. In other words, you can use this on `for` loops which you expect to break out of at some point to catch if this case did not occur.

Sure, you can do this by introducing an additional bool variable, but I still think that this would be a nice native addition to the language. Actually, since I learned about this in Python, I miss it quite often in C++.

What is your opinion on this? Note that this is less a discussion about the `else` keyword, than about the usefullness of the feature as a whole.

Has there maybe already been a paper proposol which was discussed/rejected for standardization?

Edit: added C++ equivalent example  
Edit: added conclusion

**My Conclusion:**   
Alright, this gained quite a lot of attention for what I expected.I don't quite get why this has \~40% downvotes, as I think the constructive discussion benefits every reader, but on the other hand a few comments really did not add much to the discussion.

Anyway: While I tried to keep you unbiased in my original question, it seems that everyone agrees that `else` is just a horrible keyword choice in this place and I am 100% with you. However, regarding the general functionality, I am surprised that some of you claim that they do not see any use case (not to confuse with people who dislike `for else` but acknowledge the use case).

To me, modern C++ is a lot about writing expressive code. Surprisingly only two answers mentioned `std::none_of`|`any_of`|`find_if`, which I think are the currently best suited tools to implement the given functionality at maximum expressiveness while at the same time being the easiest to comprehend for unfamiliar programmers.

Thanks to everyone who participated, I loved getting your input on this!
## [11][It Is Time for Compiler Developers to Step In](https://www.reddit.com/r/cpp/comments/jts223/it_is_time_for_compiler_developers_to_step_in/)
- url: https://www.reddit.com/r/cpp/comments/jts223/it_is_time_for_compiler_developers_to_step_in/
---
Warning: this is not a strictly-technical post. More like a rant.

TL;DR: actual implementors of C++ should be the ones responding to C++ developers' needs and pushing C++ forward according to them, not some committee authority. Things to be standardized should be battle-tested first.

Firstly, I want to express a great admiration and respect for men and women behind C++ implementations and tools as well as towards those who participate in various working groups and do the hard work of keeping the language both modern and standardized, the language I, among the plethora of others, use daily or from time to time, to make a living or to enjoy a little hobby or a pet project, big or small. I do not find myself in a position to make demands on them.

What was a tipping point for me to write this post was recent discussion ([this](https://www.reddit.com/r/cpp/comments/jtdk74/deprecating_volatile_jf_bastien_cppcon_2019/), [this](https://www.reddit.com/r/cpp/comments/jswz3z/compound_assignment_to_volatile_must_be/) and [this](https://www.reddit.com/r/cpp/comments/dk542b/cppcon_2019_jf_bastien_deprecating_volatile/)) about [deprecation](https://wg21.link/p1152r0) of some uses of `volatile` in C++20. Numerous embedded developers say that this strives to solve a language-lawyer-world problem of "ambiguous semantics" at the cost of real world usage and public image of C++. Meanwhile, C++ standard fails to address important real-world issues due to obvious time limitations and complexities of designing single universal solution to *hard problems*. The most prominent latest example is C++20 modules. They are standardized, but there are both a split between implementations with respect to strong/weak ownership model and [feeling](https://www.reddit.com/r/cpp/comments/akihlv/c_modules_might_be_deadonarrival/) that C++20 modules just failed to deliver. Oh, and do you remember `std::error_code` or `std::regex`?  


I think that the general mindset of "1. we need X in the Standard 2. only Standard-compliant code is OK" is wrong. Look at `__restrict` \- all major compilers support some form of it, yet it is non-standard. The fact that it is non-standard has not harmed anyone! Would anyone be harmed if major compiler's team explicitly says "we do not agree with Standard here and there and will not comply with it" about some controversial part of the C++ Standard? In fact, we do program real hardware, not C++ Abstract Machine. That's why `std::vector` \- like class can be implemented in C++ as understood by every compiler in the world despite all the [UB](https://wg21.link/p0593).

However, optimizing compilers can do all sorts of weird stuff and we want them to do this weird stuff to make our code fast. But we also want our code to be expressive. Would it matter that `std::start_lifetime_as` has not made it into C++20 Standard if every major compiler supported it? No. Would it allow us to write code which is more clear to both humans and optimizers? Yes.

Now is the time C++ must be up to the challenges because of increasing competition. Do not let authorities prevent you from using language extensions and non-standard features, we need them for  the language to evolve and find its way forward. It is better to standardize things when there is a clear path proven by a group of pioneers to be successful, than when we don't have *anything* but find ourselves in need of having *something*. It is better to have things in compilers than not have them just because of working group meetings schedule.
