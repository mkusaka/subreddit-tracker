{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_io5ad", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Nine-year-old bug in the Go standard library enables DoS", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i59jmo", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.91, "author_flair_background_color": null, "subreddit_type": "public", "ups": 57, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 57, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1596814480.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://github.com/ethereum/public-attacknets/issues/12", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i59jmo", "is_robot_indexable": true, "report_reasons": null, "author": "1Gijs", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i59jmo/nineyearold_bug_in_the_go_standard_library/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/ethereum/public-attacknets/issues/12", "subreddit_subscribers": 121470, "created_utc": 1596785680.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_3zxot", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "CLI tool for viewing/writing to and from Kafka, RabbitMQ and more", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i54dnl", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.95, "author_flair_background_color": null, "subreddit_type": "public", "ups": 63, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 63, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1596791317.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://github.com/batchcorp/plumber", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i54dnl", "is_robot_indexable": true, "report_reasons": null, "author": "dsies", "discussion_type": null, "num_comments": 10, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i54dnl/cli_tool_for_viewingwriting_to_and_from_kafka/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/batchcorp/plumber", "subreddit_subscribers": 121470, "created_utc": 1596762517.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_y78q6", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "ReadUvarint unlimited input (CVE-2020-16845) - Go 1.14.7 and Go 1.13.15 security update", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i4wyfk", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.92, "author_flair_background_color": null, "subreddit_type": "public", "ups": 33, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 33, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1596766450.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "groups.google.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://groups.google.com/u/1/g/golang-announce/c/NyPIaucMgXo/m/GdsyQP6QAAAJ?pli=1", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i4wyfk", "is_robot_indexable": true, "report_reasons": null, "author": "protolambda", "discussion_type": null, "num_comments": 12, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i4wyfk/readuvarint_unlimited_input_cve202016845_go_1147/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://groups.google.com/u/1/g/golang-announce/c/NyPIaucMgXo/m/GdsyQP6QAAAJ?pli=1", "subreddit_subscribers": 121470, "created_utc": 1596737650.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hello guys, long time lurker on this sub but never posted before. \n\nI created **json-server**, a CLI tool to create a dummy REST API from a provided json file with zero coding in seconds. For each provided resource 6 full functional endpoints are created (GET x2, POST, PUT, PATCH, DELETE), that you can use right away. \n\nInspired by the javascript package [json-server](https://github.com/typicode/json-server) that's where the name comes from. \n\nThe next step is to create the first release, which will include binary files for Windows, Linux and macOS. Any comments/suggestions are really welcomed. You can find more info at README file.\n\n[https://github.com/chanioxaris/json-server](https://github.com/chanioxaris/json-server)", "author_fullname": "t2_7hvbyvth", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Create a dummy REST API from a json file with zero coding in seconds", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i4t3rd", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.88, "author_flair_background_color": null, "subreddit_type": "public", "ups": 54, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 54, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1596754038.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hello guys, long time lurker on this sub but never posted before. &lt;/p&gt;\n\n&lt;p&gt;I created &lt;strong&gt;json-server&lt;/strong&gt;, a CLI tool to create a dummy REST API from a provided json file with zero coding in seconds. For each provided resource 6 full functional endpoints are created (GET x2, POST, PUT, PATCH, DELETE), that you can use right away. &lt;/p&gt;\n\n&lt;p&gt;Inspired by the javascript package &lt;a href=\"https://github.com/typicode/json-server\"&gt;json-server&lt;/a&gt; that&amp;#39;s where the name comes from. &lt;/p&gt;\n\n&lt;p&gt;The next step is to create the first release, which will include binary files for Windows, Linux and macOS. Any comments/suggestions are really welcomed. You can find more info at README file.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://github.com/chanioxaris/json-server\"&gt;https://github.com/chanioxaris/json-server&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i4t3rd", "is_robot_indexable": true, "report_reasons": null, "author": "chanioxaris", "discussion_type": null, "num_comments": 13, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i4t3rd/create_a_dummy_rest_api_from_a_json_file_with/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/i4t3rd/create_a_dummy_rest_api_from_a_json_file_with/", "subreddit_subscribers": 121470, "created_utc": 1596725238.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_14tjcc", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "gocv recognise ellipse", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i5bmts", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.33, "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": true, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1596826088.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "i.redd.it", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://i.redd.it/lipmzj5m8kf51.jpg", "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i5bmts", "is_robot_indexable": true, "report_reasons": null, "author": "JohnnyTheSmith", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i5bmts/gocv_recognise_ellipse/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://i.redd.it/lipmzj5m8kf51.jpg", "subreddit_subscribers": 121470, "created_utc": 1596797288.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "I have been playing around with `unsafe.Sizeof` and `binary.Size` but neither are working for this use case. I have a struct as follows, and I am looking to find out the memory impact of it as the program continues. The issue is that structX can vary in size so `binary.Size` doesnt like it.\n\n    type struct sample {\n        data [] structX\n    }\n\nI have tried using pprof but the memory usage used varies too much, weird I know. Running a benchmark once gives 1GB usage, running it again gives 500MB, its too inconsistent. I tried using memStats but there are so many go routines running that I cant pin down the memory used by this one struct. The struct is allocated on the heap and has a lifespan of most of the running of the program. Any recommendations?", "author_fullname": "t2_sel7j", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How to programmatically get the size of a struct, incl its data?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i5bjie", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.5, "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1596825587.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I have been playing around with &lt;code&gt;unsafe.Sizeof&lt;/code&gt; and &lt;code&gt;binary.Size&lt;/code&gt; but neither are working for this use case. I have a struct as follows, and I am looking to find out the memory impact of it as the program continues. The issue is that structX can vary in size so &lt;code&gt;binary.Size&lt;/code&gt; doesnt like it.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type struct sample {\n    data [] structX\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I have tried using pprof but the memory usage used varies too much, weird I know. Running a benchmark once gives 1GB usage, running it again gives 500MB, its too inconsistent. I tried using memStats but there are so many go routines running that I cant pin down the memory used by this one struct. The struct is allocated on the heap and has a lifespan of most of the running of the program. Any recommendations?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i5bjie", "is_robot_indexable": true, "report_reasons": null, "author": "GAAfanatic", "discussion_type": null, "num_comments": 6, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i5bjie/how_to_programmatically_get_the_size_of_a_struct/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/i5bjie/how_to_programmatically_get_the_size_of_a_struct/", "subreddit_subscribers": 121470, "created_utc": 1596796787.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "I want to proxy the keystrokes from one keyboard to another keyboard, how can I do this with Linux? Any suggestion?", "author_fullname": "t2_26q3bbaq", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How to proxy the keystrokes from one keyboard to another?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": true, "name": "t3_i5ck1a", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.25, "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1596830635.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I want to proxy the keystrokes from one keyboard to another keyboard, how can I do this with Linux? Any suggestion?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i5ck1a", "is_robot_indexable": true, "report_reasons": null, "author": "fenugurod", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i5ck1a/how_to_proxy_the_keystrokes_from_one_keyboard_to/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/i5ck1a/how_to_proxy_the_keystrokes_from_one_keyboard_to/", "subreddit_subscribers": 121470, "created_utc": 1596801835.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_15zp4f", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "AWS Lambda in GoLang Guide", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i59mlm", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.67, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1596814916.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "softkraft.co", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://www.softkraft.co/aws-lambda-in-golang/", "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i59mlm", "is_robot_indexable": true, "report_reasons": null, "author": "tomaszbak", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i59mlm/aws_lambda_in_golang_guide/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.softkraft.co/aws-lambda-in-golang/", "subreddit_subscribers": 121470, "created_utc": 1596786116.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_4kcgc0y9", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Go: Introduction to the Escape Analysis", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i4w3zd", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.74, "author_flair_background_color": null, "subreddit_type": "public", "ups": 10, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 10, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1596763777.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "medium.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://medium.com/a-journey-with-go/go-introduction-to-the-escape-analysis-f7610174e890", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i4w3zd", "is_robot_indexable": true, "report_reasons": null, "author": "a_journey_with_go", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i4w3zd/go_introduction_to_the_escape_analysis/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://medium.com/a-journey-with-go/go-introduction-to-the-escape-analysis-f7610174e890", "subreddit_subscribers": 121470, "created_utc": 1596734977.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hi everyone. How do you handle the error in web application?. In my case. I often have to pass errors from the `repository` layer to the `handler` layer. This error is an error about operate database. It should not display to users. So I must return a 500 in handler if error not equal nil.\n```go\n/repositories/user_repository.go. send error to the service layer.\ntx := r.conn.Begin()\nif err := tx.Error; err != nil {\n\treturn userCreated, err\n}\nif err := tx.Create(&amp;user).Scan(&amp;userCreated).Error; err != nil {\n\ttx.Rollback()\n\treturn userCreated, err\n}\ntx.Commit()\nreturn userCreated, nil\n\n/services/user_service.go receive the error \n_, err := u.userRepository.CreateUser(user)\nif err != nil {\n\treturn err\n}\nreturn nil\n\n/handles/user_handler.go\nif err != nil {\n\tginresp.InternalError(c, \"Create failed\", nil, err)\n}\n```\nIf I panic it in service layer. then the recovery middlewares will handle it. Does this way is best?", "author_fullname": "t2_6qigg0jg", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "What is the best error handle in web applicaiton.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_i57ubx", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.5, "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1596805713.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hi everyone. How do you handle the error in web application?. In my case. I often have to pass errors from the &lt;code&gt;repository&lt;/code&gt; layer to the &lt;code&gt;handler&lt;/code&gt; layer. This error is an error about operate database. It should not display to users. So I must return a 500 in handler if error not equal nil.\n```go\n/repositories/user_repository.go. send error to the service layer.\ntx := r.conn.Begin()\nif err := tx.Error; err != nil {\n    return userCreated, err\n}\nif err := tx.Create(&amp;amp;user).Scan(&amp;amp;userCreated).Error; err != nil {\n    tx.Rollback()\n    return userCreated, err\n}\ntx.Commit()\nreturn userCreated, nil&lt;/p&gt;\n\n&lt;p&gt;/services/user_service.go receive the error \n_, err := u.userRepository.CreateUser(user)\nif err != nil {\n    return err\n}\nreturn nil&lt;/p&gt;\n\n&lt;p&gt;/handles/user_handler.go\nif err != nil {\n    ginresp.InternalError(c, &amp;quot;Create failed&amp;quot;, nil, err)\n}\n```\nIf I panic it in service layer. then the recovery middlewares will handle it. Does this way is best?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "i57ubx", "is_robot_indexable": true, "report_reasons": null, "author": "glephunter", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/i57ubx/what_is_the_best_error_handle_in_web_applicaiton/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/i57ubx/what_is_the_best_error_handle_in_web_applicaiton/", "subreddit_subscribers": 121470, "created_utc": 1596776913.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_i57ubx", "before": null}}