{"kind": "Listing", "data": {"modhash": "", "dist": 11, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "Rules For Individuals\n---------------------\n\n* **Don't** create top-level comments - those are for employers.\n* Feel free to reply to top-level comments with **on-topic** questions.\n* I will create one top-level comment for **meta** discussion.\n* I will create another top-level comment for **individuals looking for work** and **community groups looking for sponsors**.\n\nRules For Employers\n---------------------\n\n* You must be hiring **directly**. No third-party recruiters.\n* **One** top-level comment per employer. If you have multiple job openings, that's great, but please consolidate their descriptions or mention them in replies to your own top-level comment.\n* **Don't** use URL shorteners. [reddiquette](https://www.reddithelp.com/en/categories/reddit-101/reddit-basics/reddiquette) forbids them because they're opaque to the spam filter.\n* Templates are awesome. Please **use** the following template. As the \"formatting help\" says, use \\*\\*two stars\\*\\* to **bold text**. Use empty lines to separate sections.\n* **Proofread** your comment after posting it, and edit any formatting mistakes.\n\n---\n\n\\*\\*Company:\\*\\* [Company name; also, use the \"formatting help\" to make it a link to your company's website, or a specific careers page if you have one.]\n\n&amp;nbsp;\n\n\\*\\*Type:\\*\\* [Full time, part time, internship, contract, etc.]\n\n&amp;nbsp;\n\n\\*\\*Description:\\*\\* [What does your company do, and what are you hiring C++ devs for? How much experience are you looking for, and what seniority levels are you hiring for? The more details you provide, the better.]\n\n&amp;nbsp;\n\n\\*\\*Location:\\*\\* [Where's your office - or if you're hiring at multiple offices, list them. If your workplace language isn't English, please specify it.]\n\n&amp;nbsp;\n\n\\*\\*Remote:\\*\\* [Do you offer the option of working remotely? If so, do you require employees to live in certain areas or time zones?]\n\n&amp;nbsp;\n\n\\*\\*Visa Sponsorship:\\*\\* [Does your company sponsor visas?]\n\n&amp;nbsp;\n\n\\*\\*Technologies:\\*\\* [Required: do you mainly use C++98/03, C++11, C++14, C++17, or the C++20 working draft? Optional: do you use Linux/Mac/Windows, are there languages you use in addition to C++, are there technologies like OpenGL or libraries like Boost that you need/want/like experience with, etc.]\n\n&amp;nbsp;\n\n\\*\\*Contact:\\*\\* [How do you want to be contacted? Email, reddit PM, telepathy, gravitational waves?]\n\n---\n\nPrevious Post\n--------------\n\n* [C++ Jobs - Q4 2019](https://www.reddit.com/r/cpp/comments/dbqgbw/c_jobs_q4_2019/)", "author_fullname": "t2_21c1y", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "C++ Jobs - Q1 2020", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_eiila4", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": "", "subreddit_type": "public", "ups": 207, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 207, "approved_by": null, "author_premium": true, "thumbnail": "", "edited": 1579038018.0, "author_flair_css_class": "", "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1577915953.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;h2&gt;Rules For Individuals&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Don&amp;#39;t&lt;/strong&gt; create top-level comments - those are for employers.&lt;/li&gt;\n&lt;li&gt;Feel free to reply to top-level comments with &lt;strong&gt;on-topic&lt;/strong&gt; questions.&lt;/li&gt;\n&lt;li&gt;I will create one top-level comment for &lt;strong&gt;meta&lt;/strong&gt; discussion.&lt;/li&gt;\n&lt;li&gt;I will create another top-level comment for &lt;strong&gt;individuals looking for work&lt;/strong&gt; and &lt;strong&gt;community groups looking for sponsors&lt;/strong&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h2&gt;Rules For Employers&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;You must be hiring &lt;strong&gt;directly&lt;/strong&gt;. No third-party recruiters.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;One&lt;/strong&gt; top-level comment per employer. If you have multiple job openings, that&amp;#39;s great, but please consolidate their descriptions or mention them in replies to your own top-level comment.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Don&amp;#39;t&lt;/strong&gt; use URL shorteners. &lt;a href=\"https://www.reddithelp.com/en/categories/reddit-101/reddit-basics/reddiquette\"&gt;reddiquette&lt;/a&gt; forbids them because they&amp;#39;re opaque to the spam filter.&lt;/li&gt;\n&lt;li&gt;Templates are awesome. Please &lt;strong&gt;use&lt;/strong&gt; the following template. As the &amp;quot;formatting help&amp;quot; says, use **two stars** to &lt;strong&gt;bold text&lt;/strong&gt;. Use empty lines to separate sections.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Proofread&lt;/strong&gt; your comment after posting it, and edit any formatting mistakes.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;**Company:** [Company name; also, use the &amp;quot;formatting help&amp;quot; to make it a link to your company&amp;#39;s website, or a specific careers page if you have one.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Type:** [Full time, part time, internship, contract, etc.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Description:** [What does your company do, and what are you hiring C++ devs for? How much experience are you looking for, and what seniority levels are you hiring for? The more details you provide, the better.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Location:** [Where&amp;#39;s your office - or if you&amp;#39;re hiring at multiple offices, list them. If your workplace language isn&amp;#39;t English, please specify it.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Remote:** [Do you offer the option of working remotely? If so, do you require employees to live in certain areas or time zones?]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Visa Sponsorship:** [Does your company sponsor visas?]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Technologies:** [Required: do you mainly use C++98/03, C++11, C++14, C++17, or the C++20 working draft? Optional: do you use Linux/Mac/Windows, are there languages you use in addition to C++, are there technologies like OpenGL or libraries like Boost that you need/want/like experience with, etc.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Contact:** [How do you want to be contacted? Email, reddit PM, telepathy, gravitational waves?]&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h2&gt;Previous Post&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://www.reddit.com/r/cpp/comments/dbqgbw/c_jobs_q4_2019/\"&gt;C++ Jobs - Q4 2019&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": "new", "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": "MSVC STL Dev", "visited": false, "removed_by": null, "num_reports": null, "distinguished": "moderator", "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "eiila4", "is_robot_indexable": true, "report_reasons": null, "author": "STL", "discussion_type": null, "num_comments": 84, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": "dark", "permalink": "/r/cpp/comments/eiila4/c_jobs_q1_2020/", "parent_whitelist_status": "all_ads", "stickied": true, "url": "https://www.reddit.com/r/cpp/comments/eiila4/c_jobs_q1_2020/", "subreddit_subscribers": 124241, "created_utc": 1577887153.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "Here are some sites that have decent free C++ Quizzes:\n\n* http://cppquiz.org/\n* http://www.mycppquiz.com/\n* http://www.interqiew.com/tests?type=cpp\n* http://www.interqiew.com/ask?ta=tqdp02&amp;qn=1\n* https://developers.google.com/edu/c++/quiz\n* http://www.pvv.org/~oma/PubQuiz_ACCU_Apr2012.pdf\n* http://www.pvv.org/~oma/PubQuiz_ACCU_Apr2013.pdf\n* http://www.pvv.org/~oma/PubQuiz_ACCU_Apr2014.pdf\n* http://www.pvv.org/~oma/PubQuiz_ACCU_Apr2016.pdf\n\nIf there are any others worth mentioning please post them here", "author_fullname": "t2_146jpp", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "C++ Quizzes", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fcqruv", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 54, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 54, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1583247078.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Here are some sites that have decent free C++ Quizzes:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"http://cppquiz.org/\"&gt;http://cppquiz.org/&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"http://www.mycppquiz.com/\"&gt;http://www.mycppquiz.com/&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"http://www.interqiew.com/tests?type=cpp\"&gt;http://www.interqiew.com/tests?type=cpp&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"http://www.interqiew.com/ask?ta=tqdp02&amp;amp;qn=1\"&gt;http://www.interqiew.com/ask?ta=tqdp02&amp;amp;qn=1&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://developers.google.com/edu/c++/quiz\"&gt;https://developers.google.com/edu/c++/quiz&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"http://www.pvv.org/%7Eoma/PubQuiz_ACCU_Apr2012.pdf\"&gt;http://www.pvv.org/~oma/PubQuiz_ACCU_Apr2012.pdf&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"http://www.pvv.org/%7Eoma/PubQuiz_ACCU_Apr2013.pdf\"&gt;http://www.pvv.org/~oma/PubQuiz_ACCU_Apr2013.pdf&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"http://www.pvv.org/%7Eoma/PubQuiz_ACCU_Apr2014.pdf\"&gt;http://www.pvv.org/~oma/PubQuiz_ACCU_Apr2014.pdf&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"http://www.pvv.org/%7Eoma/PubQuiz_ACCU_Apr2016.pdf\"&gt;http://www.pvv.org/~oma/PubQuiz_ACCU_Apr2016.pdf&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;If there are any others worth mentioning please post them here&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fcqruv", "is_robot_indexable": true, "report_reasons": null, "author": "Remwein", "discussion_type": null, "num_comments": 14, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/fcqruv/c_quizzes/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/fcqruv/c_quizzes/", "subreddit_subscribers": 124241, "created_utc": 1583218278.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "I like structured bindings from c++17, I have some ideas for improving them for c++23 that I'd love to get preliminary feedback on before potentially getting involved in a paper.\n\nI've seen a few referenced here and there, so I thought I'd unify them all in one post. Some of these ideas I've seen in [stack overflow](https://stackoverflow.com/questions/45541334/can-the-structured-bindings-syntax-be-used-in-polymorphic-lambdas) or inspired by the [pattern matching paper](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1371r1.pdf). If other people have proposed these same ideas in active papers, I'd love to know.\n\nLet's get started\n\n# Structured bindings as an argument\n\nWouldn't it be nice if we could declare a structured binding as a parameter in a function definition?\n\nThis is a pattern that comes up in range code or code that uses lambdas with tuple/pair args.\n\n    std::unordered_map&lt;string, int&gt; myMap = /* ... */;\n    auto transformed = myMap\n        | ranges::views::transform([] (const auto&amp; keyValuePair) {\n             const auto&amp; [key, value] = keyValuePair;\n            // return something from key and value;\n          })\n        | ranges::to&lt;std::vector&gt;;\n\nI would love to get rid of the `const auto&amp; [k, v] = keyValuePair;` and just write:\n\n    std::unordered_map&lt;string, int&gt; myMap = /* ... */;\n    auto transformed = myMap\n        | ranges::views::transform([] (const auto&amp; [key, value]) {\n            // return something from key and value\n          })\n        | ranges::to&lt;std::vector&gt;;\n\nTo me has a various obvious meaning, and I think it's not an ambiguous parse AFAIK.\n\nThis would also apply to normal functions, not just lambdas. So let's say we had a structured bindings compatible type:\n\n    struct Point {\n       int x;\n       int y;\n    };\n\nAnd the declaration of the function taking that type \n\n    void function(Point p);\n\nIn the definition it would be nice to write:\n\n    void function(Point [x, y]) {\n       // do something with x and y\n    }\ninstead of\n\n    void function(Point p) {\n       auto [x, y] = p;\n       // do something with x and y\n    }\n\nThis works as long as `Point` or similar is structured bindings decomposable. The structured binding decomposition would not have to appear in the function declaration, just the definition since this is basically an implementation detail.\n\nAnd of course, with template/concept all the following would be valid (assuming valid type substitution):\n\n    template &lt;typename T&gt;\n    void function(T [x, y]) {}\n    void function(auto [x, y]) {}\n    void function(Concept auto [x, y]) {}\n\nEDIT: I have learned that this was proposed in the following [paper](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0931r0.pdf)\n\n# Variadic bindings\nInspired from [here](https://www.reddit.com/r/cpp/comments/8abgg8/variadic_structured_binding/), but it'd be nice to be able to write expressions like the following:\n\n    auto [first, second, ...rest] = unpackable;\n\nWhere `first` refs the first element, and `rest` packs the remaining and is usable just like a parameter pack:\n\n    callSomethingVariadic(rest...);\n\nYou could also just omit the name `rest` if you didn't care:\n\n    auto [first, second, ...] = unpackable;\n\nThis of course could be combined with bindings as parameters above:\n\n    void function(SomeType [first, second, ...rest]) {}\n\n# Named bindings\nCurrently structured bindings are positional, wouldn't it be cool if we could unpack fields by their name?\n\n    struct Datum {\n       string name;\n       int id;\n       bool isCool;\n    } datum;\n    \n    auto [.isCool] = datum;\n    // equivalent to\n    auto isCool = datum.isCool;\n\nThis is intended to be very similar to what is possible in [Javascript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment), and is similar to proposals in the pattern matching paper.\nI use `.&lt;identifier&gt;` syntax to be consistent with designator initialization syntax. So that following would be consistent:\n\n    auto [.name, .id, .isCool] = Datum{.name = \"bob\", .id = 2, .isCool = true};\n\n But ordinality restrictions should be lifted on decomposition, since initialization order does not really apply to structured bindings based on what they really are.\n\n    auto [.id, isCool, .name] = datum;\n\nThis would combine well with \"structured bindings as a parameter\" so that you could accept a whole struct as a param (to be future proof) define exactly which args your function needs in its current impl:\n\n    void doSomething(const Datum&amp; [.id, .name]) {\n       // do something with name and id\n    }\n\nOr write code that concisely genericly expresses expectation of a certain field being present:\n\n    void doSomethingGeneric(const auto&amp; [.foo]) {\n       // use foo field of passed in object\n    }\n\n## Named unpack with rename\nNamed unpack with rename could be supported though I'm not 100% sold on it, e.g.:\n\n    auto [.isCool, newName = .name] = datum;\n\nInstead of:\n\n    auto isCool = datum.name;\n    auto newName = datum.name;\n\nThis feature would only be for renames. I would want arbitrary expressions to be disallowed here due to order of evaluation concerns and maintaining structured binding fields as aliases rather than independent variables. So at this point I think the following should be illegal:\n\n    auto [newId = .id + 1] = datum; // illegal\n\nDefinitely initialization dependent on prior fields should be illegal:\n\n    auto [\n      newId = .id,\n      newName = .name + std::to_string(newId)\n    ] = datum; // illegal\n\nOne problem here is that `[newName = .name]` syntax totally implies that maybe an arbitrary expression can be substituted (as in lambdas). So perhaps we need a different syntax here. Javascript uses a colon for this:\n\n    const {originalName: newName} = obj\n\nBut I don't think colon carries the same semantic meaning in c++, so the following would look a little strange in c++\n\n    auto [.name: newName] = datum;\n\nAnother option could be fat or skinny arrow as in patter matching:\n\n    auto [.name -&gt; newName] = datum;\n    auto [.name =&gt; newName] = datum;\n\nWhich by themselves look fine but do not correspond with any other patterns. With this analysis I'm most partial to\n    \n    auto [newName = .name] = datum;\n\nwhich is why I presented it first. But this problem gets even hairier when we talk about nesting...\n\n## Combination with ordinals\nIn general this would be mostly disallowed in combination with ordinal bindings:\n\n    auto [.isCool, id] = datum; // disallowed\n\nUse one or the other, not both. One exception could be if the named bindings follow all the ordinal ones:\n\n    auto [newName, ..., .id] = datum\n\nmeaning, `datum.name` binds to first positional as `newName`, ignore all other positionals and bind `id` as `datum.id`. I don't see a use for this and its very presence suggests structuring a data type so that it has both an ordinal and non-ordinal (named) structure. So my perspective is we should probably just disallow this.\n\n## Variadic named capture?\nWhat about the following:\n\n    auto [.id, .isCool, ...rest] = datum;\n\nOn some level you understand what `rest` represents, a data structure that has all the fields of datum except for `.id` and `.isCool` (so just name). I don't really think this is a particularly useful object and we get a lot of hard questions as to what type the rest object actually has and how you're allowed to use it.\n\n## named capture (but with a function)\nSo far named capture is pretty limited to simple structs (that which can be constructed by designated initializer). What if we had something more powerful:\n\n    std::vector&lt;int&gt; vec; // some integer range\n    auto [.begin, .end] = vec;\n    // equivalent to:\n    auto begin = vec.begin();\n    auto end = vec.end();\n\nIf we expressed member capture as the rule that:\n\n    auto [.identifier] = val;\n\nis equivalent to:\n\n    auto identifier = std::invoke(&amp;decltype(val)::identifier, val);\n\nWe get both forms automatically! This is a pretty radical idea though and breaks a lot of the rules associated with structured bindings, but I'm throwing it out there anyway...\n\n# Nested Bindings\n\nThis has beeen requested by a few but I wanted to reiterate that it works here and fits (kind of) well with the above. Nested bindings allow you to do the following:\n\n    struct Datum {\n       int first;\n\n       struct Inner {\n          double intensity;\n          char code;\n       } config;\n\n       std::string color;\n    } datum;\n\n    auto [first, [intensity, code], color] = datum;\n\nOf course all of the above mesh with this.\nAs an argument:\n\n    auto function(Datum [first, [intensity, code], color] datum) {}\n\nVariadics with named capture:\n\n    auto [first, [.intensity], ...] = datum;\n\nFully nested named:\n\n    auto [[.intensity] = .config] = datum;\n\nWe can see that the rename syntax doesn't work great with nesting. Consider the following type:\n\n    struct Outer {\n      struct Middle {\n        struct Inner {\n          int x;\n          int y;\n        };\n\n        Innter inner;\n      };\n\n      Middle middle;\n    } val;\n\nWe have several options to decompose this and get `int x, int y` in the end:\n\n    auto [[[x, y]]] = val; // pure postional nested\n    auto [[[.y, .x]]] = val; // positional nested -&gt; named\n    auto [[[.x, .y] = .inner] = .mid] = val; // fully renamed\n    auto [.x, .y] = val.middle.inner; // non-nested\n\nThe lesson here is that this:\n\n    auto [[[.x, .y] = .inner] = .mid] = val;\n\nIs a pretty terrible solution. No one can read that and immediately understand. It reads and writes in the completely wrong direction: you have to start with \"[[[\" which means you basically have to know your target variable depth before even writing.\n    \nLet's recall how javascript does this:\n\n    const {middle: {inner: {x, y}}} = val;\n\nIf I'm honest, I still find this highly unreadable, maybe because in javascript the syntax makes me think I'm declaring a dictionary long before it makes me realize I'm referencing the `x` and `y` fields of `val`.\n\nIf we c++ this with arrows:\n\n    auto [.middle =&gt; [.inner =&gt; [.x, .y]]] = val;\n\nTo me it's still not intuitive what the heck this does from an outsider perspective, but at least it's easier to write than:\n\n    auto [[[.x, .y] = .inner] = .mid] = val;\n\nIf we look at \"=&gt;\" from a pattern matching perspective, then some intuition arises. We can describe the following:\n\n    auto [.middle =&gt; [.inner =&gt; [.x, .y]]] = val;\n\nAs \"match `val` against having field `.middle`, take result and match against having field `.inner` then take result and match against fields `.x and .y` capturing them.\"\n\n# Conclusion/Summary\n\nSo I don't know what to make of this. The \"rename\" syntax as well as how it would apply with nesting is probably the hardest piece to wrangle here and has questionable value, but in my perspective the others would be pretty useful and intuitive. Reminders:\n  \n  Structured Binding as a param:\n\n     [](auto [k, v]) {}\n     // same as [](auto p) {auto [k, v] = p;}\n\n  Variadic Bindings:\n\n     auto [a, b, ...] = s;\n     // no simple equivalent. for tuples:\n     // auto&amp; a = std::get&lt;0&gt;(s);\n     // auto&amp; b = std::get&lt;1&gt;(s);\n\n  Structured binding by field name\n\n     auto [.x] = s;\n     // same as auto x = s.x\n\n  Nested structured bindings (positional syntax):\n\n     auto [a, [x, y]] = s;\n     // same as: auto [a, tmp] = s; auto [x, y] = tmp;\n\n  Combination:\n     [] (auto [[.x, .y], ...]) {}\n     // same as: [] (auto s) {\n     // auto [tmp, ...] = s;\n     // auto x = tmp.x;\n     // auto y = tmp.y;}\n\nI think having them would allow us to allow for some fresh and interesting programming paradigms. I'd love to hear your thoughts on some of these components as well as references to any papers that are currently proposing some of these ideas! I would love if c++23 brought with it a super powered update to structured bindings, since c++20 did very little to improve them.", "author_fullname": "t2_fc1am", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "[c++23 and beyond] Structured Binding extension ideas", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fcmm2s", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 61, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 61, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1583214346.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1583226588.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I like structured bindings from c++17, I have some ideas for improving them for c++23 that I&amp;#39;d love to get preliminary feedback on before potentially getting involved in a paper.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;ve seen a few referenced here and there, so I thought I&amp;#39;d unify them all in one post. Some of these ideas I&amp;#39;ve seen in &lt;a href=\"https://stackoverflow.com/questions/45541334/can-the-structured-bindings-syntax-be-used-in-polymorphic-lambdas\"&gt;stack overflow&lt;/a&gt; or inspired by the &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1371r1.pdf\"&gt;pattern matching paper&lt;/a&gt;. If other people have proposed these same ideas in active papers, I&amp;#39;d love to know.&lt;/p&gt;\n\n&lt;p&gt;Let&amp;#39;s get started&lt;/p&gt;\n\n&lt;h1&gt;Structured bindings as an argument&lt;/h1&gt;\n\n&lt;p&gt;Wouldn&amp;#39;t it be nice if we could declare a structured binding as a parameter in a function definition?&lt;/p&gt;\n\n&lt;p&gt;This is a pattern that comes up in range code or code that uses lambdas with tuple/pair args.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;std::unordered_map&amp;lt;string, int&amp;gt; myMap = /* ... */;\nauto transformed = myMap\n    | ranges::views::transform([] (const auto&amp;amp; keyValuePair) {\n         const auto&amp;amp; [key, value] = keyValuePair;\n        // return something from key and value;\n      })\n    | ranges::to&amp;lt;std::vector&amp;gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I would love to get rid of the &lt;code&gt;const auto&amp;amp; [k, v] = keyValuePair;&lt;/code&gt; and just write:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;std::unordered_map&amp;lt;string, int&amp;gt; myMap = /* ... */;\nauto transformed = myMap\n    | ranges::views::transform([] (const auto&amp;amp; [key, value]) {\n        // return something from key and value\n      })\n    | ranges::to&amp;lt;std::vector&amp;gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;To me has a various obvious meaning, and I think it&amp;#39;s not an ambiguous parse AFAIK.&lt;/p&gt;\n\n&lt;p&gt;This would also apply to normal functions, not just lambdas. So let&amp;#39;s say we had a structured bindings compatible type:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;struct Point {\n   int x;\n   int y;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And the declaration of the function taking that type &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;void function(Point p);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the definition it would be nice to write:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;void function(Point [x, y]) {\n   // do something with x and y\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;instead of&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;void function(Point p) {\n   auto [x, y] = p;\n   // do something with x and y\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This works as long as &lt;code&gt;Point&lt;/code&gt; or similar is structured bindings decomposable. The structured binding decomposition would not have to appear in the function declaration, just the definition since this is basically an implementation detail.&lt;/p&gt;\n\n&lt;p&gt;And of course, with template/concept all the following would be valid (assuming valid type substitution):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt;\nvoid function(T [x, y]) {}\nvoid function(auto [x, y]) {}\nvoid function(Concept auto [x, y]) {}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;EDIT: I have learned that this was proposed in the following &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0931r0.pdf\"&gt;paper&lt;/a&gt;&lt;/p&gt;\n\n&lt;h1&gt;Variadic bindings&lt;/h1&gt;\n\n&lt;p&gt;Inspired from &lt;a href=\"https://www.reddit.com/r/cpp/comments/8abgg8/variadic_structured_binding/\"&gt;here&lt;/a&gt;, but it&amp;#39;d be nice to be able to write expressions like the following:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [first, second, ...rest] = unpackable;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Where &lt;code&gt;first&lt;/code&gt; refs the first element, and &lt;code&gt;rest&lt;/code&gt; packs the remaining and is usable just like a parameter pack:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;callSomethingVariadic(rest...);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You could also just omit the name &lt;code&gt;rest&lt;/code&gt; if you didn&amp;#39;t care:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [first, second, ...] = unpackable;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This of course could be combined with bindings as parameters above:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;void function(SomeType [first, second, ...rest]) {}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;Named bindings&lt;/h1&gt;\n\n&lt;p&gt;Currently structured bindings are positional, wouldn&amp;#39;t it be cool if we could unpack fields by their name?&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;struct Datum {\n   string name;\n   int id;\n   bool isCool;\n} datum;\n\nauto [.isCool] = datum;\n// equivalent to\nauto isCool = datum.isCool;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is intended to be very similar to what is possible in &lt;a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\"&gt;Javascript&lt;/a&gt;, and is similar to proposals in the pattern matching paper.\nI use &lt;code&gt;.&amp;lt;identifier&amp;gt;&lt;/code&gt; syntax to be consistent with designator initialization syntax. So that following would be consistent:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [.name, .id, .isCool] = Datum{.name = &amp;quot;bob&amp;quot;, .id = 2, .isCool = true};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;But ordinality restrictions should be lifted on decomposition, since initialization order does not really apply to structured bindings based on what they really are.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [.id, isCool, .name] = datum;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This would combine well with &amp;quot;structured bindings as a parameter&amp;quot; so that you could accept a whole struct as a param (to be future proof) define exactly which args your function needs in its current impl:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;void doSomething(const Datum&amp;amp; [.id, .name]) {\n   // do something with name and id\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or write code that concisely genericly expresses expectation of a certain field being present:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;void doSomethingGeneric(const auto&amp;amp; [.foo]) {\n   // use foo field of passed in object\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;Named unpack with rename&lt;/h2&gt;\n\n&lt;p&gt;Named unpack with rename could be supported though I&amp;#39;m not 100% sold on it, e.g.:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [.isCool, newName = .name] = datum;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Instead of:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto isCool = datum.name;\nauto newName = datum.name;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This feature would only be for renames. I would want arbitrary expressions to be disallowed here due to order of evaluation concerns and maintaining structured binding fields as aliases rather than independent variables. So at this point I think the following should be illegal:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [newId = .id + 1] = datum; // illegal\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Definitely initialization dependent on prior fields should be illegal:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [\n  newId = .id,\n  newName = .name + std::to_string(newId)\n] = datum; // illegal\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;One problem here is that &lt;code&gt;[newName = .name]&lt;/code&gt; syntax totally implies that maybe an arbitrary expression can be substituted (as in lambdas). So perhaps we need a different syntax here. Javascript uses a colon for this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const {originalName: newName} = obj\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;But I don&amp;#39;t think colon carries the same semantic meaning in c++, so the following would look a little strange in c++&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [.name: newName] = datum;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Another option could be fat or skinny arrow as in patter matching:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [.name -&amp;gt; newName] = datum;\nauto [.name =&amp;gt; newName] = datum;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Which by themselves look fine but do not correspond with any other patterns. With this analysis I&amp;#39;m most partial to&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [newName = .name] = datum;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which is why I presented it first. But this problem gets even hairier when we talk about nesting...&lt;/p&gt;\n\n&lt;h2&gt;Combination with ordinals&lt;/h2&gt;\n\n&lt;p&gt;In general this would be mostly disallowed in combination with ordinal bindings:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [.isCool, id] = datum; // disallowed\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Use one or the other, not both. One exception could be if the named bindings follow all the ordinal ones:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [newName, ..., .id] = datum\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;meaning, &lt;code&gt;datum.name&lt;/code&gt; binds to first positional as &lt;code&gt;newName&lt;/code&gt;, ignore all other positionals and bind &lt;code&gt;id&lt;/code&gt; as &lt;code&gt;datum.id&lt;/code&gt;. I don&amp;#39;t see a use for this and its very presence suggests structuring a data type so that it has both an ordinal and non-ordinal (named) structure. So my perspective is we should probably just disallow this.&lt;/p&gt;\n\n&lt;h2&gt;Variadic named capture?&lt;/h2&gt;\n\n&lt;p&gt;What about the following:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [.id, .isCool, ...rest] = datum;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;On some level you understand what &lt;code&gt;rest&lt;/code&gt; represents, a data structure that has all the fields of datum except for &lt;code&gt;.id&lt;/code&gt; and &lt;code&gt;.isCool&lt;/code&gt; (so just name). I don&amp;#39;t really think this is a particularly useful object and we get a lot of hard questions as to what type the rest object actually has and how you&amp;#39;re allowed to use it.&lt;/p&gt;\n\n&lt;h2&gt;named capture (but with a function)&lt;/h2&gt;\n\n&lt;p&gt;So far named capture is pretty limited to simple structs (that which can be constructed by designated initializer). What if we had something more powerful:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; vec; // some integer range\nauto [.begin, .end] = vec;\n// equivalent to:\nauto begin = vec.begin();\nauto end = vec.end();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If we expressed member capture as the rule that:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [.identifier] = val;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;is equivalent to:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto identifier = std::invoke(&amp;amp;decltype(val)::identifier, val);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;We get both forms automatically! This is a pretty radical idea though and breaks a lot of the rules associated with structured bindings, but I&amp;#39;m throwing it out there anyway...&lt;/p&gt;\n\n&lt;h1&gt;Nested Bindings&lt;/h1&gt;\n\n&lt;p&gt;This has beeen requested by a few but I wanted to reiterate that it works here and fits (kind of) well with the above. Nested bindings allow you to do the following:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;struct Datum {\n   int first;\n\n   struct Inner {\n      double intensity;\n      char code;\n   } config;\n\n   std::string color;\n} datum;\n\nauto [first, [intensity, code], color] = datum;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Of course all of the above mesh with this.\nAs an argument:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto function(Datum [first, [intensity, code], color] datum) {}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Variadics with named capture:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [first, [.intensity], ...] = datum;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Fully nested named:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [[.intensity] = .config] = datum;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;We can see that the rename syntax doesn&amp;#39;t work great with nesting. Consider the following type:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;struct Outer {\n  struct Middle {\n    struct Inner {\n      int x;\n      int y;\n    };\n\n    Innter inner;\n  };\n\n  Middle middle;\n} val;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;We have several options to decompose this and get &lt;code&gt;int x, int y&lt;/code&gt; in the end:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [[[x, y]]] = val; // pure postional nested\nauto [[[.y, .x]]] = val; // positional nested -&amp;gt; named\nauto [[[.x, .y] = .inner] = .mid] = val; // fully renamed\nauto [.x, .y] = val.middle.inner; // non-nested\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The lesson here is that this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [[[.x, .y] = .inner] = .mid] = val;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Is a pretty terrible solution. No one can read that and immediately understand. It reads and writes in the completely wrong direction: you have to start with &amp;quot;[[[&amp;quot; which means you basically have to know your target variable depth before even writing.&lt;/p&gt;\n\n&lt;p&gt;Let&amp;#39;s recall how javascript does this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const {middle: {inner: {x, y}}} = val;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If I&amp;#39;m honest, I still find this highly unreadable, maybe because in javascript the syntax makes me think I&amp;#39;m declaring a dictionary long before it makes me realize I&amp;#39;m referencing the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; fields of &lt;code&gt;val&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;If we c++ this with arrows:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [.middle =&amp;gt; [.inner =&amp;gt; [.x, .y]]] = val;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;To me it&amp;#39;s still not intuitive what the heck this does from an outsider perspective, but at least it&amp;#39;s easier to write than:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [[[.x, .y] = .inner] = .mid] = val;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If we look at &amp;quot;=&amp;gt;&amp;quot; from a pattern matching perspective, then some intuition arises. We can describe the following:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;auto [.middle =&amp;gt; [.inner =&amp;gt; [.x, .y]]] = val;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As &amp;quot;match &lt;code&gt;val&lt;/code&gt; against having field &lt;code&gt;.middle&lt;/code&gt;, take result and match against having field &lt;code&gt;.inner&lt;/code&gt; then take result and match against fields &lt;code&gt;.x and .y&lt;/code&gt; capturing them.&amp;quot;&lt;/p&gt;\n\n&lt;h1&gt;Conclusion/Summary&lt;/h1&gt;\n\n&lt;p&gt;So I don&amp;#39;t know what to make of this. The &amp;quot;rename&amp;quot; syntax as well as how it would apply with nesting is probably the hardest piece to wrangle here and has questionable value, but in my perspective the others would be pretty useful and intuitive. Reminders:&lt;/p&gt;\n\n&lt;p&gt;Structured Binding as a param:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt; [](auto [k, v]) {}\n // same as [](auto p) {auto [k, v] = p;}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Variadic Bindings:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt; auto [a, b, ...] = s;\n // no simple equivalent. for tuples:\n // auto&amp;amp; a = std::get&amp;lt;0&amp;gt;(s);\n // auto&amp;amp; b = std::get&amp;lt;1&amp;gt;(s);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Structured binding by field name&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt; auto [.x] = s;\n // same as auto x = s.x\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Nested structured bindings (positional syntax):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt; auto [a, [x, y]] = s;\n // same as: auto [a, tmp] = s; auto [x, y] = tmp;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Combination:\n     [] (auto [[.x, .y], ...]) {}\n     // same as: [] (auto s) {\n     // auto [tmp, ...] = s;\n     // auto x = tmp.x;\n     // auto y = tmp.y;}&lt;/p&gt;\n\n&lt;p&gt;I think having them would allow us to allow for some fresh and interesting programming paradigms. I&amp;#39;d love to hear your thoughts on some of these components as well as references to any papers that are currently proposing some of these ideas! I would love if c++23 brought with it a super powered update to structured bindings, since c++20 did very little to improve them.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fcmm2s", "is_robot_indexable": true, "report_reasons": null, "author": "thumtac", "discussion_type": null, "num_comments": 7, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/fcmm2s/c23_and_beyond_structured_binding_extension_ideas/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/fcmm2s/c23_and_beyond_structured_binding_extension_ideas/", "subreddit_subscribers": 124241, "created_utc": 1583197788.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "", "author_fullname": "t2_1qu3auy1", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Binlog - A high performance C++ log library to produce structured binary logs", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fcruym", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 13, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 13, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1583254337.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fcruym", "is_robot_indexable": true, "report_reasons": null, "author": "erenon_", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/fcruym/binlog_a_high_performance_c_log_library_to/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/Morgan-Stanley/binlog", "subreddit_subscribers": 124241, "created_utc": 1583225537.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "", "author_fullname": "t2_rigkl", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Quill - An asynchronous low latency logging library (C++14)", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fcbflb", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 110, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 110, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1583181440.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fcbflb", "is_robot_indexable": true, "report_reasons": null, "author": "HOSHUAJANNAH", "discussion_type": null, "num_comments": 24, "send_replies": false, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/fcbflb/quill_an_asynchronous_low_latency_logging_library/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/odygrd/quill", "subreddit_subscribers": 124241, "created_utc": 1583152640.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "    \tusing Op = std::function&lt;double(double, double)&gt; ;\n    \tOp fns = [](double x, double y) {return x + y ;} ;\n    \tOp fnm = [](double x, double y) {return abs(x) + abs(y) ;} ;\n    \tOp fnv = [](double x, double y) {return hypot(x, y) ;} ;\n            ... etc\n\nIs there a more concise way to define these small lambas? Also, the definition Op std::function&lt;double(double, double)&gt; tells us already what the signatures following are. There are dependencies to update if the definition of Op is changed.\n\nOf course, we can use a macro to do the following instead:-\n\n            using Op = std::function&lt;double(double, double)&gt;\n            defop(fns, x + y) ; defop(fnm, abs(x) + abs(y)) ; defop(fnv, hypot(x, y)) ;\n\nWhich is concise, with fewer dependencies, possibly fewer still if we could extract the signature from Op. Just wondering if there is a tidier C++ way (without relying on macros)?", "author_fullname": "t2_45bmf83u", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Verbose syntax for small function/lambdas", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fcrgqs", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1583251568.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;pre&gt;&lt;code&gt;    using Op = std::function&amp;lt;double(double, double)&amp;gt; ;\n    Op fns = [](double x, double y) {return x + y ;} ;\n    Op fnm = [](double x, double y) {return abs(x) + abs(y) ;} ;\n    Op fnv = [](double x, double y) {return hypot(x, y) ;} ;\n        ... etc\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Is there a more concise way to define these small lambas? Also, the definition Op std::function&amp;lt;double(double, double)&amp;gt; tells us already what the signatures following are. There are dependencies to update if the definition of Op is changed.&lt;/p&gt;\n\n&lt;p&gt;Of course, we can use a macro to do the following instead:-&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;        using Op = std::function&amp;lt;double(double, double)&amp;gt;\n        defop(fns, x + y) ; defop(fnm, abs(x) + abs(y)) ; defop(fnv, hypot(x, y)) ;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Which is concise, with fewer dependencies, possibly fewer still if we could extract the signature from Op. Just wondering if there is a tidier C++ way (without relying on macros)?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fcrgqs", "is_robot_indexable": true, "report_reasons": null, "author": "csmetrics", "discussion_type": null, "num_comments": 17, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/fcrgqs/verbose_syntax_for_small_functionlambdas/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/fcrgqs/verbose_syntax_for_small_functionlambdas/", "subreddit_subscribers": 124241, "created_utc": 1583222768.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "", "author_fullname": "t2_aofyw", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "In-class Member Initialisation: From C++11 to C++20", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fc9iiz", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 41, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 41, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1583169345.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "bfilipek.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fc9iiz", "is_robot_indexable": true, "report_reasons": null, "author": "joebaf", "discussion_type": null, "num_comments": 4, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/fc9iiz/inclass_member_initialisation_from_c11_to_c20/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.bfilipek.com/2015/02/non-static-data-members-initialization.html", "subreddit_subscribers": 124241, "created_utc": 1583140545.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "", "author_fullname": "t2_45ucxdwz", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "WG21 in Prague - (Partial) Trip Report", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fcfbhj", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 6, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 6, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "crosspost_parent_list": [{"approved_at_utc": null, "subreddit": "u_InbalL", "selftext": "This trip report is not exhaustive but limited to my experience, and is just a taste from some of the topics I find most interesting. :)\n\nStarting with the logistics: The WG21 meeting took place in Prague this year.\n\n[Part of Prague's Castel](https://preview.redd.it/v6yrce00ajh41.jpg?width=1600&amp;format=pjpg&amp;auto=webp&amp;s=5ec4c2c099ad7a3ababf552303226a2ca47f50d6)\n\nThe venue was very convenient, and all the logistics were handled perfectly. (Thanks to Hana Dus\u00edkov\u00e1, And Avast who sponsored)\n\n[The Conference Center](https://preview.redd.it/6oz1mz4prjh41.jpg?width=1594&amp;format=pjpg&amp;auto=webp&amp;s=263939738c8666c53ac4a6d203312c2f9af216fc)\n\nStarting with the bottom line:\n\nThe meetings were intensive and fascinating. few of the decisions made regarding the entire WG:\n\nI. [**P0592R4**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0592r4.html): To boldly suggest an overall plan for C++23 - Has been accepted.\n\nII. A decision was made that from now on, with every paper proposed, there will be a description of the UB appears in it. (documenting core undefined or unspecified behavior)\n\nIII. Modules are now in the language.\n\nIV. Concepts are now in the language ([**P1851R0**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1851r0.html): Guidelines For snake\\_case Concept Naming was suggested)\n\nV. Contracts were removed from C++20 and will be discussed for C++23.\n\nVI. [**P1999R0**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1999r0.html):  Process proposal: double-check evolutionary material via a Tentatively Ready status - was accepted.\n\nI was mainly in EWG (language evolution), LEWG (library evolution), and SG14. Few ideas I find interesting were discussed:\n\n(LEWG+EWG)\n\nI. The most controversial topics were [**P1863R1**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1863r1.pdf)**:** ABI - Now or Never - the desition of whether or not to break the ABI at C++23.\n\n1. [**P1881R1**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1881r1.html)**:** Epochs: a backward-compatible language evolution mechanism - The Epochs feature will currently be held back, might be discussed in the future.\n2. The discussion of the claim that we should consider ABI break did not reach a consensus.\n3. The need to consider ABI break for every release was agreed on.\n4. The strong notion was not to promise backward compatible ABI for all versions in the future.\n\n&amp;#x200B;\n\n(LEWG)\n\nI. Executors took its next step with [**P0443R12**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r12.html)**:** A Unified Executors Proposal for C++\n\nII.  Accepted: [**P1847R2**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1847r2.pdf): Make declaration order layout mandated\n\nIII. [**P1949R1**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1949r1.html)**:** C++ Identifier Syntax using Unicode Standard Annex 31 - removed form C++20.\n\nIV. [**P2003R0**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2003r0.html)**:** Fixing Internal and External Linkage Entities in Header Units - was discussed, the direction is positive.\n\nV.  [**P1678R2**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1678r2.pdf): Callbacks and Composition - is an interesting paper, and will be discussed in the future.\n\n&amp;#x200B;\n\n(EWG)\n\nI.  [**P1468R3**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1468r3.html): Fixed-layout floating-point type aliases\n\nII.  [**P1371R2:**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1371r2.pdf) Pattern matching - was reviewed and changes where discussed.\n\nIII.  [**P1040R5:**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1040r5.html) std::embed and #depend\n\nIV. [**P1967R1**:](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1967r1.pdf) \\#embed - a simple, scannable preprocessor-based resource acquisition method\n\n&amp;#x200B;\n\n(SG14)\n\nI. The freestanding library has gained additional features, including: [**P2013R0**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2013r0.html)**:** Freestanding Language: Optional::operator new\n\nII. Herb's proposal: [**P0709R1**](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r1.pdf): Zero-overhead deterministic exceptions: Throwing values - took the next step, with the presentation of: [low\\_cost\\_deterministic\\_C\\_exceptions\\_for\\_embedded\\_systems](https://www.research.ed.ac.uk/portal/files/78829292/low_cost_deterministic_C_exceptions_for_embedded_systems.pdf)\n\n&amp;#x200B;\n\n[Prague Square at night](https://preview.redd.it/lp22kzoecjh41.jpg?width=1600&amp;format=pjpg&amp;auto=webp&amp;s=aa1e805717242f3717d44ea1e860408325665db6)\n\nIn conclusion, I had a great time and I look forward to the next meeting.\n\nI hope you've enjoyed the summary. There were, of course much more topics discussed that I haven't mentioned here.For a more complete report, please view the one published by [u/blelbach](https://www.reddit.com/user/blelbach/):  \n [https://www.reddit.com/r/cpp\\_test/comments/f46sx2/202002\\_iso\\_c\\_committee\\_trip\\_report\\_c20\\_is\\_done/](https://www.reddit.com/r/cpp_test/comments/f46sx2/202002_iso_c_committee_trip_report_c20_is_done/)", "author_fullname": "t2_45ucxdwz", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "WG21 in Prague - (Partial) Trip Report", "link_flair_richtext": [], "subreddit_name_prefixed": "u/InbalL", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "hide_score": false, "media_metadata": {"lp22kzoecjh41": {"status": "valid", "e": "Image", "m": "image/jpg", "p": [{"y": 81, "x": 108, "u": "https://external-preview.redd.it/lp22kzoecjh41.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=053c93f6609d0917f17fd4fb77ed5b26ca0b98b8"}, {"y": 162, "x": 216, "u": "https://external-preview.redd.it/lp22kzoecjh41.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=69184813cd78a41d9ef0232fb641a857989e9f20"}, {"y": 240, "x": 320, "u": "https://external-preview.redd.it/lp22kzoecjh41.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=d69de47547531ada3dc5077592d8074db2a35f25"}, {"y": 480, "x": 640, "u": "https://external-preview.redd.it/lp22kzoecjh41.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=dc85cf5e8ecc23e64107be73bf5fa17715bba01c"}, {"y": 720, "x": 960, "u": "https://external-preview.redd.it/lp22kzoecjh41.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=74603116ea2b8f5a8c19f2c562e3237e675cfa7e"}, {"y": 810, "x": 1080, "u": "https://external-preview.redd.it/lp22kzoecjh41.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=f583391c6e15820e50851945fad450ecab66c223"}], "s": {"y": 1200, "x": 1600, "u": "https://preview.redd.it/lp22kzoecjh41.jpg?width=1600&amp;format=pjpg&amp;auto=webp&amp;s=aa1e805717242f3717d44ea1e860408325665db6"}, "id": "lp22kzoecjh41"}, "6oz1mz4prjh41": {"status": "valid", "e": "Image", "m": "image/jpg", "p": [{"y": 67, "x": 108, "u": "https://external-preview.redd.it/6oz1mz4prjh41.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=e4607de6493ab7acaa81c48ad490e928a2ceb825"}, {"y": 135, "x": 216, "u": "https://external-preview.redd.it/6oz1mz4prjh41.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=d169ee405932d6f05f2a46eb16aa7965fce5bde9"}, {"y": 200, "x": 320, "u": "https://external-preview.redd.it/6oz1mz4prjh41.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=65a7b9171224f804296e637650340838b32b48a6"}, {"y": 401, "x": 640, "u": "https://external-preview.redd.it/6oz1mz4prjh41.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=069e4bb229cc099f8b4b9019588ac7cd8b2a8e62"}, {"y": 602, "x": 960, "u": "https://external-preview.redd.it/6oz1mz4prjh41.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=41cff349c9926d7b86c8923f36643b5f73983c6d"}, {"y": 678, "x": 1080, "u": "https://external-preview.redd.it/6oz1mz4prjh41.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=6539a81872463545d972b5e93cdc33606de3a873"}], "s": {"y": 1001, "x": 1594, "u": "https://preview.redd.it/6oz1mz4prjh41.jpg?width=1594&amp;format=pjpg&amp;auto=webp&amp;s=263939738c8666c53ac4a6d203312c2f9af216fc"}, "id": "6oz1mz4prjh41"}, "v6yrce00ajh41": {"status": "valid", "e": "Image", "m": "image/jpg", "p": [{"y": 42, "x": 108, "u": "https://external-preview.redd.it/v6yrce00ajh41.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=ccfb6a81369068e5b09bc29640032b730464dda4"}, {"y": 84, "x": 216, "u": "https://external-preview.redd.it/v6yrce00ajh41.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=e7f8d831f8eac4fdf544fce5be0b16e934808d69"}, {"y": 124, "x": 320, "u": "https://external-preview.redd.it/v6yrce00ajh41.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=487f2ca210652a65ac01b489ddfc41e7e9eb08dd"}, {"y": 249, "x": 640, "u": "https://external-preview.redd.it/v6yrce00ajh41.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=1abee2028bac53a6bfa5099371aa0edb79e252c3"}, {"y": 374, "x": 960, "u": "https://external-preview.redd.it/v6yrce00ajh41.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=81123fd021c56ccf44725a377ef3bdcf18ed57bb"}, {"y": 421, "x": 1080, "u": "https://external-preview.redd.it/v6yrce00ajh41.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=9b8549322c1829e12e6b695465d2330175842589"}], "s": {"y": 624, "x": 1600, "u": "https://preview.redd.it/v6yrce00ajh41.jpg?width=1600&amp;format=pjpg&amp;auto=webp&amp;s=5ec4c2c099ad7a3ababf552303226a2ca47f50d6"}, "id": "v6yrce00ajh41"}}, "name": "t3_f5ftop", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "user", "ups": 6, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 6, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1581976098.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1582002920.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.InbalL", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;This trip report is not exhaustive but limited to my experience, and is just a taste from some of the topics I find most interesting. :)&lt;/p&gt;\n\n&lt;p&gt;Starting with the logistics: The WG21 meeting took place in Prague this year.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://preview.redd.it/v6yrce00ajh41.jpg?width=1600&amp;amp;format=pjpg&amp;amp;auto=webp&amp;amp;s=5ec4c2c099ad7a3ababf552303226a2ca47f50d6\"&gt;Part of Prague&amp;#39;s Castel&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;The venue was very convenient, and all the logistics were handled perfectly. (Thanks to Hana Dus\u00edkov\u00e1, And Avast who sponsored)&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://preview.redd.it/6oz1mz4prjh41.jpg?width=1594&amp;amp;format=pjpg&amp;amp;auto=webp&amp;amp;s=263939738c8666c53ac4a6d203312c2f9af216fc\"&gt;The Conference Center&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Starting with the bottom line:&lt;/p&gt;\n\n&lt;p&gt;The meetings were intensive and fascinating. few of the decisions made regarding the entire WG:&lt;/p&gt;\n\n&lt;p&gt;I. &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0592r4.html\"&gt;&lt;strong&gt;P0592R4&lt;/strong&gt;&lt;/a&gt;: To boldly suggest an overall plan for C++23 - Has been accepted.&lt;/p&gt;\n\n&lt;p&gt;II. A decision was made that from now on, with every paper proposed, there will be a description of the UB appears in it. (documenting core undefined or unspecified behavior)&lt;/p&gt;\n\n&lt;p&gt;III. Modules are now in the language.&lt;/p&gt;\n\n&lt;p&gt;IV. Concepts are now in the language (&lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1851r0.html\"&gt;&lt;strong&gt;P1851R0&lt;/strong&gt;&lt;/a&gt;: Guidelines For snake_case Concept Naming was suggested)&lt;/p&gt;\n\n&lt;p&gt;V. Contracts were removed from C++20 and will be discussed for C++23.&lt;/p&gt;\n\n&lt;p&gt;VI. &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1999r0.html\"&gt;&lt;strong&gt;P1999R0&lt;/strong&gt;&lt;/a&gt;:  Process proposal: double-check evolutionary material via a Tentatively Ready status - was accepted.&lt;/p&gt;\n\n&lt;p&gt;I was mainly in EWG (language evolution), LEWG (library evolution), and SG14. Few ideas I find interesting were discussed:&lt;/p&gt;\n\n&lt;p&gt;(LEWG+EWG)&lt;/p&gt;\n\n&lt;p&gt;I. The most controversial topics were &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1863r1.pdf\"&gt;&lt;strong&gt;P1863R1&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; ABI - Now or Never - the desition of whether or not to break the ABI at C++23.&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1881r1.html\"&gt;&lt;strong&gt;P1881R1&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; Epochs: a backward-compatible language evolution mechanism - The Epochs feature will currently be held back, might be discussed in the future.&lt;/li&gt;\n&lt;li&gt;The discussion of the claim that we should consider ABI break did not reach a consensus.&lt;/li&gt;\n&lt;li&gt;The need to consider ABI break for every release was agreed on.&lt;/li&gt;\n&lt;li&gt;The strong notion was not to promise backward compatible ABI for all versions in the future.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;(LEWG)&lt;/p&gt;\n\n&lt;p&gt;I. Executors took its next step with &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r12.html\"&gt;&lt;strong&gt;P0443R12&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; A Unified Executors Proposal for C++&lt;/p&gt;\n\n&lt;p&gt;II.  Accepted: &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1847r2.pdf\"&gt;&lt;strong&gt;P1847R2&lt;/strong&gt;&lt;/a&gt;: Make declaration order layout mandated&lt;/p&gt;\n\n&lt;p&gt;III. &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1949r1.html\"&gt;&lt;strong&gt;P1949R1&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; C++ Identifier Syntax using Unicode Standard Annex 31 - removed form C++20.&lt;/p&gt;\n\n&lt;p&gt;IV. &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2003r0.html\"&gt;&lt;strong&gt;P2003R0&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; Fixing Internal and External Linkage Entities in Header Units - was discussed, the direction is positive.&lt;/p&gt;\n\n&lt;p&gt;V.  &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1678r2.pdf\"&gt;&lt;strong&gt;P1678R2&lt;/strong&gt;&lt;/a&gt;: Callbacks and Composition - is an interesting paper, and will be discussed in the future.&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;(EWG)&lt;/p&gt;\n\n&lt;p&gt;I.  &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1468r3.html\"&gt;&lt;strong&gt;P1468R3&lt;/strong&gt;&lt;/a&gt;: Fixed-layout floating-point type aliases&lt;/p&gt;\n\n&lt;p&gt;II.  &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1371r2.pdf\"&gt;&lt;strong&gt;P1371R2:&lt;/strong&gt;&lt;/a&gt; Pattern matching - was reviewed and changes where discussed.&lt;/p&gt;\n\n&lt;p&gt;III.  &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1040r5.html\"&gt;&lt;strong&gt;P1040R5:&lt;/strong&gt;&lt;/a&gt; std::embed and #depend&lt;/p&gt;\n\n&lt;p&gt;IV. &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1967r1.pdf\"&gt;&lt;strong&gt;P1967R1&lt;/strong&gt;:&lt;/a&gt; #embed - a simple, scannable preprocessor-based resource acquisition method&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;(SG14)&lt;/p&gt;\n\n&lt;p&gt;I. The freestanding library has gained additional features, including: &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2013r0.html\"&gt;&lt;strong&gt;P2013R0&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; Freestanding Language: Optional::operator new&lt;/p&gt;\n\n&lt;p&gt;II. Herb&amp;#39;s proposal: &lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r1.pdf\"&gt;&lt;strong&gt;P0709R1&lt;/strong&gt;&lt;/a&gt;: Zero-overhead deterministic exceptions: Throwing values - took the next step, with the presentation of: &lt;a href=\"https://www.research.ed.ac.uk/portal/files/78829292/low_cost_deterministic_C_exceptions_for_embedded_systems.pdf\"&gt;low_cost_deterministic_C_exceptions_for_embedded_systems&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://preview.redd.it/lp22kzoecjh41.jpg?width=1600&amp;amp;format=pjpg&amp;amp;auto=webp&amp;amp;s=aa1e805717242f3717d44ea1e860408325665db6\"&gt;Prague Square at night&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;In conclusion, I had a great time and I look forward to the next meeting.&lt;/p&gt;\n\n&lt;p&gt;I hope you&amp;#39;ve enjoyed the summary. There were, of course much more topics discussed that I haven&amp;#39;t mentioned here.For a more complete report, please view the one published by &lt;a href=\"https://www.reddit.com/user/blelbach/\"&gt;u/blelbach&lt;/a&gt;:&lt;br/&gt;\n &lt;a href=\"https://www.reddit.com/r/cpp_test/comments/f46sx2/202002_iso_c_committee_trip_report_c20_is_done/\"&gt;https://www.reddit.com/r/cpp_test/comments/f46sx2/202002_iso_c_committee_trip_report_c20_is_done/&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": "qa", "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_21uw2l", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f5ftop", "is_robot_indexable": true, "report_reasons": null, "author": "InbalL", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/u_InbalL/comments/f5ftop/wg21_in_prague_partial_trip_report/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/u_InbalL/comments/f5ftop/wg21_in_prague_partial_trip_report/", "subreddit_subscribers": 0, "created_utc": 1581974120.0, "num_crossposts": 1, "media": null, "is_video": false}], "created": 1583198077.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.InbalL", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fcfbhj", "is_robot_indexable": true, "report_reasons": null, "author": "InbalL", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "crosspost_parent": "t3_f5ftop", "author_flair_text_color": null, "permalink": "/r/cpp/comments/fcfbhj/wg21_in_prague_partial_trip_report/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "/user/InbalL/comments/f5ftop/wg21_in_prague_partial_trip_report/", "subreddit_subscribers": 124241, "created_utc": 1583169277.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "Related reading:\n\n[What is ABI, and What Should WG21 Do About It?](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2028r0.pdf)\n\n[The Day The Standard Library Died](https://cor3ntin.github.io/posts/abi/)\n\n# Q: What does the C++ committee need to do to fix large swaths of ABI problems?\n\n## A: Absolutely nothing\n\nOn current implementations, `std::unique_ptr`'s calling convention causes some inefficiencies compared to raw pointers.  The standard doesn't dictate the calling convention of `std::unique_ptr`, so implementers could change that if they chose to.\n\nOn current implementations, `std::hash` will return the same result for the same input, even across program invocations.  This makes it vulnerable to cache poisoning attacks.  Nothing in the standard requires that different instances of a program produce the same output.  An implementation could choose to have a global variable with a per-program-instance seed in it, and have `std::hash` mix that in.\n\nOn current implementations, `std::regex` is extremely slow.  Allegedly, this could be improved substantially without changing the API of `std::regex`, though most implementations don't change `std::regex` due to ABI concerns.  An implementation could change if it wanted to though.  However, very few people have waded into the guts of `std::regex` and provided a faster implementation, ABI breaking or otherwise.  Declaring an ABI break won't make such an implementation appear.\n\nNone of these issues are things that the C++ committee claims to have any control over.  They are dictated by vendors and by the customers of the vendors.  A new vendor could come along and have a better implementation.  For customers that prioritize QoI over ABI stability, they could switch and recompile everything.\n\nEven better, the most common standard library implementations are all open source now.  You could fork the standard library, tweak the mangling, and be your own vendor.  You can then be in control of your own ~~destiny~~ ABI, and without taking the large up-front cost of reinventing the parts of the standard library that you are satisfied with.  libc++ has a [LIBCXX\\_ABI\\_UNSTABLE](https://github.com/llvm/llvm-project/blob/master/libcxx/CMakeLists.txt#L125) configuration flag, so that you always get the latest and greatest optimizations.  libstdc++ has a `--enable-symvers=gnu-versioned-namespace` configuration flag that is ABI unstable, and it goes a long way towards allowing multiple libstdc++ instances coexist simultaneously.  Currently the libc++ and libstdc++ unstable ABI branches don't have many new optimizations because there aren't many contributions and few people use it.  I will choose to be optimistic, and assume that they are unused because people were not aware of them.\n\nIf your only concern is ABI, and not API, then vendors and developers can fix this on their own without negatively affecting code portability or conformance.  If the QoI gains from an ABI break are worth a few days / weeks to you, then that option is available *today*.\n\n# Q: What aspects of ABI makes things difficult for the C++ committee.\n\n## A: API and semantic changes that would require changes to the ABI are difficult for the C++ committee to deal with.\n\nThere are a lot of things that you can do to a type or function to make it ABI incompatible with the old type.  The C++ committee is reluctant to make these kinds of changes, as they have a substantially higher cost.  Changing the layout of a type, adding virtual methods to an existing class, and changing template parameters are the most common operations that run afoul of ABI.\n\n# Q: Are ABI changes difficult for toolchain vendors to deal with?\n\n## A1: For major vendors, they difficulty varies depending on the magnitude of the break.\n\nSince GCC 5 dealt with the std::string ABI break, [GCC has broken the language ABI 6 other times](https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html), and most people didn't even notice.  There were several library ABI breaks (notably return type changes for std::complex and associative container erase) that went smoothly as well.  Quite a few people noticed the GCC 5 `std::string` ABI changes though.\n\nIn some cases, there are compiler heroics that can be done to mitigate an library ABI change.  You will get varying responses as to whether this is a worthwhile thing to do, depending on the vendor and the change.\n\nIf the language ABI changes in a large way, then it can cause substantially more pain.  GCC had a major language ABI change in GCC 3.4, and that rippled out into the library.  Dealing with libstdc++.so.5 and libstdc++.so.6 was a major hassle for many people, myself included.\n\n## A2: For smaller vendors, the difficulty of an ABI break depends on their customer base.\n\nThese days, it's easier than ever to be your own toolchain vendor.  That makes you a vendor with excellent insight into how difficult an ABI change would be.\n\n# Q: Why don't you just rebuild after an ABI change?\n\n## A1: Are you rebuilding the standard library too?\n\nMany people will recommend not passing standard library types around, and not throwing exceptions across shared library boundaries.  They often forget that at least one very commonly used shared library does exactly that... your C++ standard library.\n\nOn many platforms, there is usually a system C++ standard library.  If you want to use that, then you need to deal with standard library types and exceptions going across shared library boundaries.  If OS version N+1 breaks ABI in the system C++ standard library, the program you shipped and tested with for OS version N will not work on the upgraded OS until you rebuild.\n\n## A2: Sometimes, rebuilding isn't enough\n\nSuppose your company distributes pre-built programs to customers, and this program supports plugins (e.g. Wireshark dissector plugins).  If the plugin ABI changes, in the pre-built program, then all of the plugins need to rebuild.  The customer that upgrades the program is unlikely to be the one that does the rebuilding, but they will be responsible for upgrading all the plugins as well.  The customer cannot effectively upgrade until the entire ecosystem has responded to the ABI break.  At best, that takes a lot of time.  More likely, some parts of the ecosystem have become unresponsive, and won't ever upgrade.\n\nThis also requires upgrading large swaths of a system at once.  In certain industries, it is very difficult to convince a customer to upgrade anything at all, and upgrading an entire system would be right out.\n\nImagine breaking ABI on a system library on a phone.  Just getting all of the apps that your company owns upgraded and deployed at the same time as the system library would be a herculean effort, much less getting all the third party apps to upgrade as well.\n\nThere are things you can do to mitigate these problems, at least for library and C++ language breaks on Windows, but it's hard to mitigate this if you are relying on a system C++ standard library.  Also, these mitigations usually involve writing more error prone code that is less expressive and less efficient than if you just passed around C++ standard library types.\n\n## A3: Sometimes you can't rebuild everything.\n\nSometimes, business models revolve around selling pre-built binaries to other people.  It is difficult to coordinate ABI changes across these businesses.\n\nSometimes, there is a pre-built binary, and the company that provided that binary is no longer able to provide updates, possibly because the company no longer exists.\n\nSometimes, there is a pre-built binary that is a shared dependency among many companies (e.g. OpenSSL).  Breaking ABI on an upgrade of such a binary will cause substantial issues.\n\n# Q: What tools do we have for managing ABI changes?\n\n## A: Several, but they all have substantial trade-offs.\n\nThe most direct tool is to just make a new thing and leave the old one alone.  Don't like `std::unordered_map`? Then make `std::open_addressed_hash_map`.  This technique allows new and old worlds to intermix, but the translations between new and old must be done explicitly.  You don't get to just rebuild your program and get the benefits of the new type.  Naming the new things becomes increasingly difficult, at least if you decide to not do the \"lazy\" thing and just name the new class `std::unordered_map2` or `std2::unordered_map`.  Personally, I'm fine with slapping a version number on most of these classes, as it gives a strong clue to users that we may need to revise this thing again in the future, and it would mean we might get an incrementally better hash map without needing to wait for hashing research to cease.\n\n`inline` namespaces are another tool that can be used, but they solve far fewer ABI problems than many think.  Upgrading a type like `std::string` or `std::unordered_map` via `inline` namespaces generally wouldn't work, as user types holding the upgraded types would also change, breaking those ABIs.  `inline` namespaces can probably help add / change parameters to functions, and may even extend to updating empty callable objects, but neither of those are issues that have caused many problems in the C++ committee in the past.\n\nAdding a layer of indirection, similar to COM, does a lot to address stability *and* extensibility, at a large cost to performance.  However, one area that the C++ committee hasn't explored much in the past is to look at the places where we already have a layer of indirection, and using COM-like techniques to allow us to add methods in the future.  Right now, I don't have a good understanding of the performance trade-offs between the different plug-in / indirect call techniques that we could use for things like `std::pmr::memory_resource` and `std::error_category`.\n\n# Q: What can I do if I don't want to pay the costs for ABI stability?\n\n## A: Be your own toolchain vendor, using the existing open-source libraries and tools.\n\nIf you are able to rebuild all your source, then you can point all your builds at a custom standard library, and turn on (or even make your own) ABI breaking changes.  You now have a competitive advantage, and you didn't even need to amend an international treaty (the C++ standard) to make it happen!  If your changes were only ABI breaking and not API breaking, then you haven't even given up on code portability.\n\nNote that libc++ didn't need to get libstdc++'s permission in order to coexist on Linux.  You can have multiple standard libraries at the same time, though there are some technical challenges created when you do that.\n\n# Q: What can I do if I want to change the standard in a way that is ABI breaking?\n\n## A1: Consider doing things in a non-breaking way.\n\n## A2: Talk to compiler vendors and the ABI Review Group (ARG) to see if there is a way to mitigate the ABI break.\n\n## A3: Demonstrate that your change is so valuable that the benefit outweighs the cost, or that the cost isn't necessarily that high.\n\n# Assorted points to make before people in the comments get them wrong\n\n* I'm neither advocating to freeze ABI, nor am I advocating to break ABI.  In fact, I think those questions are too broad to even be useful.\n* Fixing `std::unordered_map`'s performance woes would require an API break, as well as an ABI break.\n* I have my doubts that `std::vector` could be made substantially faster with only an ABI break.  I can believe it if it is also coupled with an API break in the form of different exception safety guarantees.  Others are free to prove me wrong though.\n* Making `&lt;cstring&gt;` `constexpr` will probably be fine.  The ABI issues were raised and addressed for `constexpr` `&lt;cmath&gt;`, and that paper is waiting in LWG.\n* Filters on recursive\\_directory\\_iterators had additional concerns beyond ABI, and there wasn't consensus to pursue, even if we chose a different name.\n* Making destructors implicitly `virtual` in polymorphic classes would be a massive cross-language ABI break, and not just a C++ ABI break, thanks to COM.  You'd be breaking the entire Windows ecosystem.  At a minimum, you'd need a way to opt out of `virtual` destructors.\n* Are you sure that you are arguing against ABI stability?  Maybe you are arguing against backwards compatibility in general.", "author_fullname": "t2_med0j", "saved": false, "mod_reason_title": null, "gilded": 1, "clicked": false, "title": "ABI Breaks: Not just about rebuilding", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fc2qqv", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 177, "total_awards_received": 3, "media_embed": {}, "author_flair_template_id": "7bf857c8-4dcc-11e6-b84d-0e5fbba92363", "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 177, "approved_by": null, "author_premium": true, "thumbnail": "", "edited": 1583105585.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {"gid_2": 1}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1583134163.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Related reading:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2028r0.pdf\"&gt;What is ABI, and What Should WG21 Do About It?&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://cor3ntin.github.io/posts/abi/\"&gt;The Day The Standard Library Died&lt;/a&gt;&lt;/p&gt;\n\n&lt;h1&gt;Q: What does the C++ committee need to do to fix large swaths of ABI problems?&lt;/h1&gt;\n\n&lt;h2&gt;A: Absolutely nothing&lt;/h2&gt;\n\n&lt;p&gt;On current implementations, &lt;code&gt;std::unique_ptr&lt;/code&gt;&amp;#39;s calling convention causes some inefficiencies compared to raw pointers.  The standard doesn&amp;#39;t dictate the calling convention of &lt;code&gt;std::unique_ptr&lt;/code&gt;, so implementers could change that if they chose to.&lt;/p&gt;\n\n&lt;p&gt;On current implementations, &lt;code&gt;std::hash&lt;/code&gt; will return the same result for the same input, even across program invocations.  This makes it vulnerable to cache poisoning attacks.  Nothing in the standard requires that different instances of a program produce the same output.  An implementation could choose to have a global variable with a per-program-instance seed in it, and have &lt;code&gt;std::hash&lt;/code&gt; mix that in.&lt;/p&gt;\n\n&lt;p&gt;On current implementations, &lt;code&gt;std::regex&lt;/code&gt; is extremely slow.  Allegedly, this could be improved substantially without changing the API of &lt;code&gt;std::regex&lt;/code&gt;, though most implementations don&amp;#39;t change &lt;code&gt;std::regex&lt;/code&gt; due to ABI concerns.  An implementation could change if it wanted to though.  However, very few people have waded into the guts of &lt;code&gt;std::regex&lt;/code&gt; and provided a faster implementation, ABI breaking or otherwise.  Declaring an ABI break won&amp;#39;t make such an implementation appear.&lt;/p&gt;\n\n&lt;p&gt;None of these issues are things that the C++ committee claims to have any control over.  They are dictated by vendors and by the customers of the vendors.  A new vendor could come along and have a better implementation.  For customers that prioritize QoI over ABI stability, they could switch and recompile everything.&lt;/p&gt;\n\n&lt;p&gt;Even better, the most common standard library implementations are all open source now.  You could fork the standard library, tweak the mangling, and be your own vendor.  You can then be in control of your own &lt;del&gt;destiny&lt;/del&gt; ABI, and without taking the large up-front cost of reinventing the parts of the standard library that you are satisfied with.  libc++ has a &lt;a href=\"https://github.com/llvm/llvm-project/blob/master/libcxx/CMakeLists.txt#L125\"&gt;LIBCXX_ABI_UNSTABLE&lt;/a&gt; configuration flag, so that you always get the latest and greatest optimizations.  libstdc++ has a &lt;code&gt;--enable-symvers=gnu-versioned-namespace&lt;/code&gt; configuration flag that is ABI unstable, and it goes a long way towards allowing multiple libstdc++ instances coexist simultaneously.  Currently the libc++ and libstdc++ unstable ABI branches don&amp;#39;t have many new optimizations because there aren&amp;#39;t many contributions and few people use it.  I will choose to be optimistic, and assume that they are unused because people were not aware of them.&lt;/p&gt;\n\n&lt;p&gt;If your only concern is ABI, and not API, then vendors and developers can fix this on their own without negatively affecting code portability or conformance.  If the QoI gains from an ABI break are worth a few days / weeks to you, then that option is available &lt;em&gt;today&lt;/em&gt;.&lt;/p&gt;\n\n&lt;h1&gt;Q: What aspects of ABI makes things difficult for the C++ committee.&lt;/h1&gt;\n\n&lt;h2&gt;A: API and semantic changes that would require changes to the ABI are difficult for the C++ committee to deal with.&lt;/h2&gt;\n\n&lt;p&gt;There are a lot of things that you can do to a type or function to make it ABI incompatible with the old type.  The C++ committee is reluctant to make these kinds of changes, as they have a substantially higher cost.  Changing the layout of a type, adding virtual methods to an existing class, and changing template parameters are the most common operations that run afoul of ABI.&lt;/p&gt;\n\n&lt;h1&gt;Q: Are ABI changes difficult for toolchain vendors to deal with?&lt;/h1&gt;\n\n&lt;h2&gt;A1: For major vendors, they difficulty varies depending on the magnitude of the break.&lt;/h2&gt;\n\n&lt;p&gt;Since GCC 5 dealt with the std::string ABI break, &lt;a href=\"https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html\"&gt;GCC has broken the language ABI 6 other times&lt;/a&gt;, and most people didn&amp;#39;t even notice.  There were several library ABI breaks (notably return type changes for std::complex and associative container erase) that went smoothly as well.  Quite a few people noticed the GCC 5 &lt;code&gt;std::string&lt;/code&gt; ABI changes though.&lt;/p&gt;\n\n&lt;p&gt;In some cases, there are compiler heroics that can be done to mitigate an library ABI change.  You will get varying responses as to whether this is a worthwhile thing to do, depending on the vendor and the change.&lt;/p&gt;\n\n&lt;p&gt;If the language ABI changes in a large way, then it can cause substantially more pain.  GCC had a major language ABI change in GCC 3.4, and that rippled out into the library.  Dealing with libstdc++.so.5 and libstdc++.so.6 was a major hassle for many people, myself included.&lt;/p&gt;\n\n&lt;h2&gt;A2: For smaller vendors, the difficulty of an ABI break depends on their customer base.&lt;/h2&gt;\n\n&lt;p&gt;These days, it&amp;#39;s easier than ever to be your own toolchain vendor.  That makes you a vendor with excellent insight into how difficult an ABI change would be.&lt;/p&gt;\n\n&lt;h1&gt;Q: Why don&amp;#39;t you just rebuild after an ABI change?&lt;/h1&gt;\n\n&lt;h2&gt;A1: Are you rebuilding the standard library too?&lt;/h2&gt;\n\n&lt;p&gt;Many people will recommend not passing standard library types around, and not throwing exceptions across shared library boundaries.  They often forget that at least one very commonly used shared library does exactly that... your C++ standard library.&lt;/p&gt;\n\n&lt;p&gt;On many platforms, there is usually a system C++ standard library.  If you want to use that, then you need to deal with standard library types and exceptions going across shared library boundaries.  If OS version N+1 breaks ABI in the system C++ standard library, the program you shipped and tested with for OS version N will not work on the upgraded OS until you rebuild.&lt;/p&gt;\n\n&lt;h2&gt;A2: Sometimes, rebuilding isn&amp;#39;t enough&lt;/h2&gt;\n\n&lt;p&gt;Suppose your company distributes pre-built programs to customers, and this program supports plugins (e.g. Wireshark dissector plugins).  If the plugin ABI changes, in the pre-built program, then all of the plugins need to rebuild.  The customer that upgrades the program is unlikely to be the one that does the rebuilding, but they will be responsible for upgrading all the plugins as well.  The customer cannot effectively upgrade until the entire ecosystem has responded to the ABI break.  At best, that takes a lot of time.  More likely, some parts of the ecosystem have become unresponsive, and won&amp;#39;t ever upgrade.&lt;/p&gt;\n\n&lt;p&gt;This also requires upgrading large swaths of a system at once.  In certain industries, it is very difficult to convince a customer to upgrade anything at all, and upgrading an entire system would be right out.&lt;/p&gt;\n\n&lt;p&gt;Imagine breaking ABI on a system library on a phone.  Just getting all of the apps that your company owns upgraded and deployed at the same time as the system library would be a herculean effort, much less getting all the third party apps to upgrade as well.&lt;/p&gt;\n\n&lt;p&gt;There are things you can do to mitigate these problems, at least for library and C++ language breaks on Windows, but it&amp;#39;s hard to mitigate this if you are relying on a system C++ standard library.  Also, these mitigations usually involve writing more error prone code that is less expressive and less efficient than if you just passed around C++ standard library types.&lt;/p&gt;\n\n&lt;h2&gt;A3: Sometimes you can&amp;#39;t rebuild everything.&lt;/h2&gt;\n\n&lt;p&gt;Sometimes, business models revolve around selling pre-built binaries to other people.  It is difficult to coordinate ABI changes across these businesses.&lt;/p&gt;\n\n&lt;p&gt;Sometimes, there is a pre-built binary, and the company that provided that binary is no longer able to provide updates, possibly because the company no longer exists.&lt;/p&gt;\n\n&lt;p&gt;Sometimes, there is a pre-built binary that is a shared dependency among many companies (e.g. OpenSSL).  Breaking ABI on an upgrade of such a binary will cause substantial issues.&lt;/p&gt;\n\n&lt;h1&gt;Q: What tools do we have for managing ABI changes?&lt;/h1&gt;\n\n&lt;h2&gt;A: Several, but they all have substantial trade-offs.&lt;/h2&gt;\n\n&lt;p&gt;The most direct tool is to just make a new thing and leave the old one alone.  Don&amp;#39;t like &lt;code&gt;std::unordered_map&lt;/code&gt;? Then make &lt;code&gt;std::open_addressed_hash_map&lt;/code&gt;.  This technique allows new and old worlds to intermix, but the translations between new and old must be done explicitly.  You don&amp;#39;t get to just rebuild your program and get the benefits of the new type.  Naming the new things becomes increasingly difficult, at least if you decide to not do the &amp;quot;lazy&amp;quot; thing and just name the new class &lt;code&gt;std::unordered_map2&lt;/code&gt; or &lt;code&gt;std2::unordered_map&lt;/code&gt;.  Personally, I&amp;#39;m fine with slapping a version number on most of these classes, as it gives a strong clue to users that we may need to revise this thing again in the future, and it would mean we might get an incrementally better hash map without needing to wait for hashing research to cease.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;inline&lt;/code&gt; namespaces are another tool that can be used, but they solve far fewer ABI problems than many think.  Upgrading a type like &lt;code&gt;std::string&lt;/code&gt; or &lt;code&gt;std::unordered_map&lt;/code&gt; via &lt;code&gt;inline&lt;/code&gt; namespaces generally wouldn&amp;#39;t work, as user types holding the upgraded types would also change, breaking those ABIs.  &lt;code&gt;inline&lt;/code&gt; namespaces can probably help add / change parameters to functions, and may even extend to updating empty callable objects, but neither of those are issues that have caused many problems in the C++ committee in the past.&lt;/p&gt;\n\n&lt;p&gt;Adding a layer of indirection, similar to COM, does a lot to address stability &lt;em&gt;and&lt;/em&gt; extensibility, at a large cost to performance.  However, one area that the C++ committee hasn&amp;#39;t explored much in the past is to look at the places where we already have a layer of indirection, and using COM-like techniques to allow us to add methods in the future.  Right now, I don&amp;#39;t have a good understanding of the performance trade-offs between the different plug-in / indirect call techniques that we could use for things like &lt;code&gt;std::pmr::memory_resource&lt;/code&gt; and &lt;code&gt;std::error_category&lt;/code&gt;.&lt;/p&gt;\n\n&lt;h1&gt;Q: What can I do if I don&amp;#39;t want to pay the costs for ABI stability?&lt;/h1&gt;\n\n&lt;h2&gt;A: Be your own toolchain vendor, using the existing open-source libraries and tools.&lt;/h2&gt;\n\n&lt;p&gt;If you are able to rebuild all your source, then you can point all your builds at a custom standard library, and turn on (or even make your own) ABI breaking changes.  You now have a competitive advantage, and you didn&amp;#39;t even need to amend an international treaty (the C++ standard) to make it happen!  If your changes were only ABI breaking and not API breaking, then you haven&amp;#39;t even given up on code portability.&lt;/p&gt;\n\n&lt;p&gt;Note that libc++ didn&amp;#39;t need to get libstdc++&amp;#39;s permission in order to coexist on Linux.  You can have multiple standard libraries at the same time, though there are some technical challenges created when you do that.&lt;/p&gt;\n\n&lt;h1&gt;Q: What can I do if I want to change the standard in a way that is ABI breaking?&lt;/h1&gt;\n\n&lt;h2&gt;A1: Consider doing things in a non-breaking way.&lt;/h2&gt;\n\n&lt;h2&gt;A2: Talk to compiler vendors and the ABI Review Group (ARG) to see if there is a way to mitigate the ABI break.&lt;/h2&gt;\n\n&lt;h2&gt;A3: Demonstrate that your change is so valuable that the benefit outweighs the cost, or that the cost isn&amp;#39;t necessarily that high.&lt;/h2&gt;\n\n&lt;h1&gt;Assorted points to make before people in the comments get them wrong&lt;/h1&gt;\n\n&lt;ul&gt;\n&lt;li&gt;I&amp;#39;m neither advocating to freeze ABI, nor am I advocating to break ABI.  In fact, I think those questions are too broad to even be useful.&lt;/li&gt;\n&lt;li&gt;Fixing &lt;code&gt;std::unordered_map&lt;/code&gt;&amp;#39;s performance woes would require an API break, as well as an ABI break.&lt;/li&gt;\n&lt;li&gt;I have my doubts that &lt;code&gt;std::vector&lt;/code&gt; could be made substantially faster with only an ABI break.  I can believe it if it is also coupled with an API break in the form of different exception safety guarantees.  Others are free to prove me wrong though.&lt;/li&gt;\n&lt;li&gt;Making &lt;code&gt;&amp;lt;cstring&amp;gt;&lt;/code&gt; &lt;code&gt;constexpr&lt;/code&gt; will probably be fine.  The ABI issues were raised and addressed for &lt;code&gt;constexpr&lt;/code&gt; &lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt;, and that paper is waiting in LWG.&lt;/li&gt;\n&lt;li&gt;Filters on recursive_directory_iterators had additional concerns beyond ABI, and there wasn&amp;#39;t consensus to pursue, even if we chose a different name.&lt;/li&gt;\n&lt;li&gt;Making destructors implicitly &lt;code&gt;virtual&lt;/code&gt; in polymorphic classes would be a massive cross-language ABI break, and not just a C++ ABI break, thanks to COM.  You&amp;#39;d be breaking the entire Windows ecosystem.  At a minimum, you&amp;#39;d need a way to opt out of &lt;code&gt;virtual&lt;/code&gt; destructors.&lt;/li&gt;\n&lt;li&gt;Are you sure that you are arguing against ABI stability?  Maybe you are arguing against backwards compatibility in general.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [{"count": 1, "is_enabled": true, "subreddit_id": null, "description": "You officially endorse and add your voice to the crowd. Gives %{coin_symbol}100 Coins to both the author and the community.", "end_date": null, "coin_reward": 100, "icon_url": "https://i.redd.it/award_images/t5_22cerq/6vgr8y21i9741_PlusOne.png", "days_of_premium": 0, "coin_price": 250, "is_new": false, "icon_format": null, "award_sub_type": "APPRECIATION", "resized_icons": [{"url": "https://preview.redd.it/award_images/t5_22cerq/6vgr8y21i9741_PlusOne.png?width=16&amp;height=16&amp;auto=webp&amp;s=4c8f077e9e98a5179688cfd1e93d999c1f19e51e", "width": 16, "height": 16}, {"url": "https://preview.redd.it/award_images/t5_22cerq/6vgr8y21i9741_PlusOne.png?width=32&amp;height=32&amp;auto=webp&amp;s=4d42bed81cdf5d406e3795ac1575819e2333336a", "width": 32, "height": 32}, {"url": "https://preview.redd.it/award_images/t5_22cerq/6vgr8y21i9741_PlusOne.png?width=48&amp;height=48&amp;auto=webp&amp;s=4c914164e7afdb4ea2bf1f9072720b10fcb682ed", "width": 48, "height": 48}, {"url": "https://preview.redd.it/award_images/t5_22cerq/6vgr8y21i9741_PlusOne.png?width=64&amp;height=64&amp;auto=webp&amp;s=42a5318aafd9c08cc86d7f07124b3f14e6a30ea1", "width": 64, "height": 64}, {"url": "https://preview.redd.it/award_images/t5_22cerq/6vgr8y21i9741_PlusOne.png?width=128&amp;height=128&amp;auto=webp&amp;s=23c65aa6f927b74ab67fb230d638dd717a8d729e", "width": 128, "height": 128}], "icon_height": 2048, "award_type": "global", "start_date": null, "days_of_drip_extension": 0, "id": "award_f7562045-905d-413e-9ed2-0a16d4bfe349", "icon_width": 2048, "subreddit_coin_reward": 100, "name": "Plus One"}, {"count": 1, "is_enabled": true, "subreddit_id": null, "description": "Gives the author a week of Reddit Premium, %{coin_symbol}100 Coins to do with as they please, and shows a Gold Award.", "end_date": null, "coin_reward": 100, "icon_url": "https://www.redditstatic.com/gold/awards/icon/gold_512.png", "days_of_premium": 7, "coin_price": 500, "is_new": false, "icon_format": null, "award_sub_type": "GLOBAL", "resized_icons": [{"url": "https://www.redditstatic.com/gold/awards/icon/gold_16.png", "width": 16, "height": 16}, {"url": "https://www.redditstatic.com/gold/awards/icon/gold_32.png", "width": 32, "height": 32}, {"url": "https://www.redditstatic.com/gold/awards/icon/gold_48.png", "width": 48, "height": 48}, {"url": "https://www.redditstatic.com/gold/awards/icon/gold_64.png", "width": 64, "height": 64}, {"url": "https://www.redditstatic.com/gold/awards/icon/gold_128.png", "width": 128, "height": 128}], "icon_height": 512, "award_type": "global", "start_date": null, "days_of_drip_extension": 0, "id": "gid_2", "icon_width": 512, "subreddit_coin_reward": 0, "name": "Gold"}, {"count": 1, "is_enabled": true, "subreddit_id": null, "description": "Thank you stranger. Shows the award.", "end_date": null, "coin_reward": 0, "icon_url": "https://i.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png", "days_of_premium": 0, "coin_price": 150, "is_new": false, "icon_format": null, "award_sub_type": "GLOBAL", "resized_icons": [{"url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=16&amp;height=16&amp;auto=webp&amp;s=a5662dfbdb402bf67866c050aa76c31c147c2f45", "width": 16, "height": 16}, {"url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=32&amp;height=32&amp;auto=webp&amp;s=a6882eb3f380e8e88009789f4d0072e17b8c59f1", "width": 32, "height": 32}, {"url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=48&amp;height=48&amp;auto=webp&amp;s=e50064b090879e8a0b55e433f6ee61d5cb5fbe1d", "width": 48, "height": 48}, {"url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=64&amp;height=64&amp;auto=webp&amp;s=8e5bb2e76683cb6b161830bcdd9642049d6adc11", "width": 64, "height": 64}, {"url": "https://preview.redd.it/award_images/t5_22cerq/klvxk1wggfd41_Helpful.png?width=128&amp;height=128&amp;auto=webp&amp;s=eda4a9246f95f42ee6940cc0ec65306fd20de878", "width": 128, "height": 128}], "icon_height": 2048, "award_type": "global", "start_date": null, "days_of_drip_extension": 0, "id": "award_f44611f1-b89e-46dc-97fe-892280b13b82", "icon_width": 2048, "subreddit_coin_reward": 0, "name": "Helpful"}], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": "freestanding", "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fc2qqv", "is_robot_indexable": true, "report_reasons": null, "author": "ben_craig", "discussion_type": null, "num_comments": 156, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": "dark", "permalink": "/r/cpp/comments/fc2qqv/abi_breaks_not_just_about_rebuilding/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/fc2qqv/abi_breaks_not_just_about_rebuilding/", "subreddit_subscribers": 124241, "created_utc": 1583105363.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "Hello [r/cpp readers](https://www.reddit.com/r/cpp),\n\nThis is a short presentation of a newly Open Sourced C++ framework: [Kigs framework](https://kigs-framework.org/), [GitHub project](https://github.com/assoria/kigs).\n\nKigs framework is a lightweight, fast, scalable framework that [we](https://assoria.com/) have ported to several different platforms, and we used as a base to build all our projects from Nintendo DSi games to industrial robots simulator (have a look [here](https://kigs-framework.org/Projects)). \n\nKigs framework gives access to high-level architecture and functionalities ( serialization, reflection, signals/slots, data-driven applications...) while maintaining low-level control (optimizations, platform-specific customization, easy C/C++ extern libraries usage ...).\n\n## Why Use the Kigs Framework?\n\n* You look for a free, MIT licensed framework, offering high-level functionalities such as serialization, instance factory, signals/slots management, scenegraph/rendering, Lua scripting... using C++.\n* You want to learn game/application development using C++ and Lua scripting.\n* You want to experiment with new ideas without starting from scratch.\n* You are curious to see how we implemented this or that feature and perhaps want to help improve the framework.\n\nWe would be happy if others take over our framework, improve it and adapt it to their desires and their needs.\n\n## What is available today?\n\nWindows (x86, x64, UWP OpenGL or D3D ) and HTML5 (Emscripten, [here](https://kigs-framework.org/Samples) are the built samples) platforms are already released. Android platform should be released soon, and we would be happy to get some help to clean up and release iOS platform, or to add new platforms (Linux and MacOS ?).  \n\nWe also released a series of introductory articles on [CodeProject](https://www.codeproject.com/Articles/5253209/Kigs-Framework-Introduction-1-8).\n\nI hope you will find this interesting,\n\n    thanks,\n\n          St\u00e9phane", "author_fullname": "t2_5ttv1s5f", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Kigs framework - A free, Open Source, Multi-Purpose and Cross-platform framework", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fccii8", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 9, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 9, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1583186691.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hello &lt;a href=\"https://www.reddit.com/r/cpp\"&gt;r/cpp readers&lt;/a&gt;,&lt;/p&gt;\n\n&lt;p&gt;This is a short presentation of a newly Open Sourced C++ framework: &lt;a href=\"https://kigs-framework.org/\"&gt;Kigs framework&lt;/a&gt;, &lt;a href=\"https://github.com/assoria/kigs\"&gt;GitHub project&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;Kigs framework is a lightweight, fast, scalable framework that &lt;a href=\"https://assoria.com/\"&gt;we&lt;/a&gt; have ported to several different platforms, and we used as a base to build all our projects from Nintendo DSi games to industrial robots simulator (have a look &lt;a href=\"https://kigs-framework.org/Projects\"&gt;here&lt;/a&gt;). &lt;/p&gt;\n\n&lt;p&gt;Kigs framework gives access to high-level architecture and functionalities ( serialization, reflection, signals/slots, data-driven applications...) while maintaining low-level control (optimizations, platform-specific customization, easy C/C++ extern libraries usage ...).&lt;/p&gt;\n\n&lt;h2&gt;Why Use the Kigs Framework?&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;You look for a free, MIT licensed framework, offering high-level functionalities such as serialization, instance factory, signals/slots management, scenegraph/rendering, Lua scripting... using C++.&lt;/li&gt;\n&lt;li&gt;You want to learn game/application development using C++ and Lua scripting.&lt;/li&gt;\n&lt;li&gt;You want to experiment with new ideas without starting from scratch.&lt;/li&gt;\n&lt;li&gt;You are curious to see how we implemented this or that feature and perhaps want to help improve the framework.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;We would be happy if others take over our framework, improve it and adapt it to their desires and their needs.&lt;/p&gt;\n\n&lt;h2&gt;What is available today?&lt;/h2&gt;\n\n&lt;p&gt;Windows (x86, x64, UWP OpenGL or D3D ) and HTML5 (Emscripten, &lt;a href=\"https://kigs-framework.org/Samples\"&gt;here&lt;/a&gt; are the built samples) platforms are already released. Android platform should be released soon, and we would be happy to get some help to clean up and release iOS platform, or to add new platforms (Linux and MacOS ?).  &lt;/p&gt;\n\n&lt;p&gt;We also released a series of introductory articles on &lt;a href=\"https://www.codeproject.com/Articles/5253209/Kigs-Framework-Introduction-1-8\"&gt;CodeProject&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;I hope you will find this interesting,&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;thanks,\n\n      St\u00e9phane\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fccii8", "is_robot_indexable": true, "report_reasons": null, "author": "stephane-capo", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/fccii8/kigs_framework_a_free_open_source_multipurpose/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/fccii8/kigs_framework_a_free_open_source_multipurpose/", "subreddit_subscribers": 124241, "created_utc": 1583157891.0, "num_crossposts": 1, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "", "author_fullname": "t2_27xl", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "For those who want a simpler single-header asynchronous logger at the cost of slightly more latency (c++17)", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_fcfd5i", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1583198267.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "gist.github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "fcfd5i", "is_robot_indexable": true, "report_reasons": null, "author": "jrandom", "discussion_type": null, "num_comments": 14, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/fcfd5i/for_those_who_want_a_simpler_singleheader/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://gist.github.com/jrandom/5fab0cda11105e0e62c1f33c7a372b5e", "subreddit_subscribers": 124241, "created_utc": 1583169467.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_fcfd5i", "before": null}}