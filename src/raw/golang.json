{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_lik50", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "rqlite 5.0.0 released - the lightweight distributed DB built on SQLite, now with new Raft code", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_ekn0xk", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 66, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 66, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "steward_reports": [], "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1578305052.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "philipotoole.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ekn0xk", "is_robot_indexable": true, "report_reasons": null, "author": "hudddb3", "discussion_type": null, "num_comments": 11, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/ekn0xk/rqlite_500_released_the_lightweight_distributed/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "http://www.philipotoole.com/rqlite-5-0-0-released/", "subreddit_subscribers": 98705, "created_utc": 1578276252.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hi,\n\nI was searching on the google to find any resource that will help me to build a real time collaborative text editor. Such as, ot.js for node JS.\n\nUnfortunately I didn't find anything like this. I want to integrate my own custom text editor front end with golang backend.\n\n&amp;#x200B;\n\nDo you have any suggestions?", "author_fullname": "t2_121fe6", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How to build a real-time collaborative text editor using go?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_ekt6tp", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "steward_reports": [], "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1578340627.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hi,&lt;/p&gt;\n\n&lt;p&gt;I was searching on the google to find any resource that will help me to build a real time collaborative text editor. Such as, ot.js for node JS.&lt;/p&gt;\n\n&lt;p&gt;Unfortunately I didn&amp;#39;t find anything like this. I want to integrate my own custom text editor front end with golang backend.&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;Do you have any suggestions?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ekt6tp", "is_robot_indexable": true, "report_reasons": null, "author": "CrappyFap69", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/ekt6tp/how_to_build_a_realtime_collaborative_text_editor/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/ekt6tp/how_to_build_a_realtime_collaborative_text_editor/", "subreddit_subscribers": 98705, "created_utc": 1578311827.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_81yj9s9", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Micro - a modern and intuitive terminal-based text editor", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_ekfwu9", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 80, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 80, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "steward_reports": [], "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1578273728.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "micro-editor.github.io", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ekfwu9", "is_robot_indexable": true, "report_reasons": null, "author": "donutloop", "discussion_type": null, "num_comments": 14, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/ekfwu9/micro_a_modern_and_intuitive_terminalbased_text/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://micro-editor.github.io/", "subreddit_subscribers": 98705, "created_utc": 1578244928.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_81yj9s9", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Chime A Go editor for macOS", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_ekdbiy", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 100, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 100, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "steward_reports": [], "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1578261492.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "chimehq.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ekdbiy", "is_robot_indexable": true, "report_reasons": null, "author": "donutloop", "discussion_type": null, "num_comments": 62, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/ekdbiy/chime_a_go_editor_for_macos/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.chimehq.com/", "subreddit_subscribers": 98705, "created_utc": 1578232692.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_83gyh51", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Go Things I Love: Channels and Goroutines", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_eku5xl", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "steward_reports": [], "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1578346217.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "justindfuller.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "eku5xl", "is_robot_indexable": true, "report_reasons": null, "author": "jabajabajabaj", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/eku5xl/go_things_i_love_channels_and_goroutines/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.justindfuller.com/2020/01/go-things-i-love-channels-and-goroutines/?utm_source=reddit&amp;utm_medium=referral&amp;utm_campaign=go_things_i_love", "subreddit_subscribers": 98705, "created_utc": 1578317417.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Someone knows a nice tutorial of Microservices in go?", "author_fullname": "t2_1gpfo2xw", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Tutorial Microservices in Go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_ekj87w", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 17, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 17, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "steward_reports": [], "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1578287885.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Someone knows a nice tutorial of Microservices in go?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ekj87w", "is_robot_indexable": true, "report_reasons": null, "author": "WasteSomewhere", "discussion_type": null, "num_comments": 4, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/ekj87w/tutorial_microservices_in_go/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/ekj87w/tutorial_microservices_in_go/", "subreddit_subscribers": 98705, "created_utc": 1578259085.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_5dn0yhf", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Introducing ZincECS. An entity component system package.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_ektb7c", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "steward_reports": [], "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1578341318.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ektb7c", "is_robot_indexable": true, "report_reasons": null, "author": "T2RKUS", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/ektb7c/introducing_zincecs_an_entity_component_system/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/SirMetathyst/zinc", "subreddit_subscribers": 98705, "created_utc": 1578312518.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_1nrm26ep", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Text To Speech in Golang with AWS Polly in 15 minutes", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_ekt61y", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "steward_reports": [], "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1578340493.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "medium.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ekt61y", "is_robot_indexable": true, "report_reasons": null, "author": "mehdisbys", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/ekt61y/text_to_speech_in_golang_with_aws_polly_in_15/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://medium.com/@mssr/text-to-speech-in-golang-with-aws-polly-in-15-minutes-b5f30eb34c1f", "subreddit_subscribers": 98705, "created_utc": 1578311693.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Posted recently about using channels to wait for an async response from a message bus. I verified that it DOES work.. but I am still not sure it works as I think.\n\nFirst, the basics of what I am trying to do (as short as I can). Microservices architecture, message bus between services, MQTT protocol with JSON payloads. I have rest APIs that are mostly going to be async based, but in some cases, sync. One such case would be a login flow. This may be an unorthodox way to do this, btw, and I am open to suggestions if there is a better way.. but basically I have a \"user\" service, which maintains... users (naturally). Each user has an email/password (for login), a role, name, and other various bits of info. On login, the consumer makes an API request.. /login  with email/password has request body. The API handler is a separate microservice.. so it does NOT have access to the user tables. Thus, it needs to send a message to the user service to try to find the user that is logging in. Now, message buses are async, right (unless there is some sync way of doing this?) so the /login API service sends a message to the use service.. and also has a func handler subscribed to a topic that the user service can send back on if it finds the user (or not). Simple enough.. login API sends msg, user service gets it, does some work, sends msg back, login API gets msg, and does something with it.\n\nThe problem is that I have this login API sync request.. waiting... while the API sends async message to the use service, and then has to wait on the user service to find the user (or not) and send message back. The real problem is.. having the login handler code \"wait\" while it waits for the response from the user service. I solved this by creating a channel (on every single request I do this.. which is one of my concerns), then waits on the channel to return some data. The subscribed func when it receives a message from the user service, then writes the user data (assuming found user) to the channel, and the currently waiting channel gets the data and returns the user result to the consumer. \n\nI actually have this working.. it's pretty neat. \n\nThe concerns. First, creating a channel on each and every request.. is that a bad thing? I am not knowledgeable enough with Go and runtime to know if that ends up being a potential memory hog, cpu hog, both, some sort of unforeseen runtime issue that can cause the API service to crash, etc.\n\nSecond, probably the harder issue, is I \\*think\\* each request is wrapped in a Go func by the standard library (I am using Chi for API/routing/middleware, but it is based on the standard http.\\*). I think this is the case. Haven't been able to confirm this, but I assume in order to handle tons of requests simultaneously, it must be doing something like this. That's great.. makes sense. However, what I am unsure of, if this is the case.. is if the channel I create tied to the specific go routine/thread that is handling a specific request, such that when my subscribe func gets  a response from the user service and writes to the channel.. if it is writing to the SAME channel as was created for that specific request?\n\nIf it is.. that is fantastic (assuming creating a channel for every request is ALSO ok). However, there remains another issue.. ensuring the response from the user service matches the request lookup (e.g. email/password) before writing the user data to the channel. For this I would need some way, per request/instance/thread to \"keep track\" of the request email/password... or something like a UUID tied to the creation of the channel and the email/password... to ensure that the correct found user is returned thru the correct channel. Here I am a bit stumped. I am creating the channel in the request handler, but another func that listens for messages from the message bus, writes to the channel. To make this work so far, I am declaring a channel outside of the functions, which seems wrong (I am still trying to learn/understand scope within golang as well). I am worried that this one variable ends up being shared across threads/go routines/requests, and thus is more like a singleton.\n\nAnother thought I had was to create an anonymous func IN the req handler to tie it to the channel/email/password data, so that it has access to those values to compare to the values of the user it responds to in a message from the user service. But I also very much dislike this route because if there are 1000 requests running at a time, that would mean every single request would have to potentially process up to 1000 messages until it finds the matching returned/found user matching the request user.\n\nDamn.. this is a pain in the ass. I think the idea of it is awesome. But I am unsure of if it is even possible, or if it is, if it is a potentially bottleneck in terms of memory or performance.\n\nAnyway, would love any help from someone that understands the whole API thread/go routine stuff with creating channels, matching them up correctly (if they dont automatically), etc.\n\nThank you.", "author_fullname": "t2_46g6b49x", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Still stuck on apis and channels and threads...", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_ekq7nk", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "steward_reports": [], "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1578321575.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Posted recently about using channels to wait for an async response from a message bus. I verified that it DOES work.. but I am still not sure it works as I think.&lt;/p&gt;\n\n&lt;p&gt;First, the basics of what I am trying to do (as short as I can). Microservices architecture, message bus between services, MQTT protocol with JSON payloads. I have rest APIs that are mostly going to be async based, but in some cases, sync. One such case would be a login flow. This may be an unorthodox way to do this, btw, and I am open to suggestions if there is a better way.. but basically I have a &amp;quot;user&amp;quot; service, which maintains... users (naturally). Each user has an email/password (for login), a role, name, and other various bits of info. On login, the consumer makes an API request.. /login  with email/password has request body. The API handler is a separate microservice.. so it does NOT have access to the user tables. Thus, it needs to send a message to the user service to try to find the user that is logging in. Now, message buses are async, right (unless there is some sync way of doing this?) so the /login API service sends a message to the use service.. and also has a func handler subscribed to a topic that the user service can send back on if it finds the user (or not). Simple enough.. login API sends msg, user service gets it, does some work, sends msg back, login API gets msg, and does something with it.&lt;/p&gt;\n\n&lt;p&gt;The problem is that I have this login API sync request.. waiting... while the API sends async message to the use service, and then has to wait on the user service to find the user (or not) and send message back. The real problem is.. having the login handler code &amp;quot;wait&amp;quot; while it waits for the response from the user service. I solved this by creating a channel (on every single request I do this.. which is one of my concerns), then waits on the channel to return some data. The subscribed func when it receives a message from the user service, then writes the user data (assuming found user) to the channel, and the currently waiting channel gets the data and returns the user result to the consumer. &lt;/p&gt;\n\n&lt;p&gt;I actually have this working.. it&amp;#39;s pretty neat. &lt;/p&gt;\n\n&lt;p&gt;The concerns. First, creating a channel on each and every request.. is that a bad thing? I am not knowledgeable enough with Go and runtime to know if that ends up being a potential memory hog, cpu hog, both, some sort of unforeseen runtime issue that can cause the API service to crash, etc.&lt;/p&gt;\n\n&lt;p&gt;Second, probably the harder issue, is I *think* each request is wrapped in a Go func by the standard library (I am using Chi for API/routing/middleware, but it is based on the standard http.*). I think this is the case. Haven&amp;#39;t been able to confirm this, but I assume in order to handle tons of requests simultaneously, it must be doing something like this. That&amp;#39;s great.. makes sense. However, what I am unsure of, if this is the case.. is if the channel I create tied to the specific go routine/thread that is handling a specific request, such that when my subscribe func gets  a response from the user service and writes to the channel.. if it is writing to the SAME channel as was created for that specific request?&lt;/p&gt;\n\n&lt;p&gt;If it is.. that is fantastic (assuming creating a channel for every request is ALSO ok). However, there remains another issue.. ensuring the response from the user service matches the request lookup (e.g. email/password) before writing the user data to the channel. For this I would need some way, per request/instance/thread to &amp;quot;keep track&amp;quot; of the request email/password... or something like a UUID tied to the creation of the channel and the email/password... to ensure that the correct found user is returned thru the correct channel. Here I am a bit stumped. I am creating the channel in the request handler, but another func that listens for messages from the message bus, writes to the channel. To make this work so far, I am declaring a channel outside of the functions, which seems wrong (I am still trying to learn/understand scope within golang as well). I am worried that this one variable ends up being shared across threads/go routines/requests, and thus is more like a singleton.&lt;/p&gt;\n\n&lt;p&gt;Another thought I had was to create an anonymous func IN the req handler to tie it to the channel/email/password data, so that it has access to those values to compare to the values of the user it responds to in a message from the user service. But I also very much dislike this route because if there are 1000 requests running at a time, that would mean every single request would have to potentially process up to 1000 messages until it finds the matching returned/found user matching the request user.&lt;/p&gt;\n\n&lt;p&gt;Damn.. this is a pain in the ass. I think the idea of it is awesome. But I am unsure of if it is even possible, or if it is, if it is a potentially bottleneck in terms of memory or performance.&lt;/p&gt;\n\n&lt;p&gt;Anyway, would love any help from someone that understands the whole API thread/go routine stuff with creating channels, matching them up correctly (if they dont automatically), etc.&lt;/p&gt;\n\n&lt;p&gt;Thank you.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ekq7nk", "is_robot_indexable": true, "report_reasons": null, "author": "thrwawy18237812", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/ekq7nk/still_stuck_on_apis_and_channels_and_threads/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/ekq7nk/still_stuck_on_apis_and_channels_and_threads/", "subreddit_subscribers": 98705, "created_utc": 1578292775.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_iaerw", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How to mock OAuth 2.0 in Go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_ekpket", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "steward_reports": [], "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1578317856.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "blog.seriesci.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ekpket", "is_robot_indexable": true, "report_reasons": null, "author": "zemirco", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/ekpket/how_to_mock_oauth_20_in_go/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://blog.seriesci.com/how-to-mock-oauth-in-go/", "subreddit_subscribers": 98705, "created_utc": 1578289056.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_ekpket", "before": null}}