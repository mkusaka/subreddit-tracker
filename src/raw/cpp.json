{"kind": "Listing", "data": {"modhash": "", "dist": 11, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "Rules For Individuals\n---------------------\n\n* **Don't** create top-level comments - those are for employers.\n* Feel free to reply to top-level comments with **on-topic** questions.\n* I will create one top-level comment for **meta** discussion.\n* I will create another top-level comment for **individuals looking for work** and **community groups looking for sponsors**.\n\nRules For Employers\n---------------------\n\n* You must be hiring **directly**. No third-party recruiters.\n* **One** top-level comment per employer. If you have multiple job openings, that's great, but please consolidate their descriptions or mention them in replies to your own top-level comment.\n* **Don't** use URL shorteners. [reddiquette](https://www.reddithelp.com/en/categories/reddit-101/reddit-basics/reddiquette) forbids them because they're opaque to the spam filter.\n* Templates are awesome. Please **use** the following template. As the \"formatting help\" says, use \\*\\*two stars\\*\\* to **bold text**. Use empty lines to separate sections.\n* **Proofread** your comment after posting it, and edit any formatting mistakes.\n\n---\n\n\\*\\*Company:\\*\\* [Company name; also, use the \"formatting help\" to make it a link to your company's website, or a specific careers page if you have one.]\n\n&amp;nbsp;\n\n\\*\\*Type:\\*\\* [Full time, part time, internship, contract, etc.]\n\n&amp;nbsp;\n\n\\*\\*Description:\\*\\* [What does your company do, and what are you hiring C++ devs for? How much experience are you looking for, and what seniority levels are you hiring for? The more details you provide, the better.]\n\n&amp;nbsp;\n\n\\*\\*Location:\\*\\* [Where's your office - or if you're hiring at multiple offices, list them. If your workplace language isn't English, please specify it.]\n\n&amp;nbsp;\n\n\\*\\*Remote:\\*\\* [Do you offer the option of working remotely? If so, do you require employees to live in certain areas or time zones?]\n\n&amp;nbsp;\n\n\\*\\*Visa Sponsorship:\\*\\* [Does your company sponsor visas?]\n\n&amp;nbsp;\n\n\\*\\*Technologies:\\*\\* [Required: do you mainly use C++98/03, C++11, C++14, C++17, or the C++20 working draft? Optional: do you use Linux/Mac/Windows, are there languages you use in addition to C++, are there technologies like OpenGL or libraries like Boost that you need/want/like experience with, etc.]\n\n&amp;nbsp;\n\n\\*\\*Contact:\\*\\* [How do you want to be contacted? Email, reddit PM, telepathy, gravitational waves?]\n\n---\n\nPrevious Post\n--------------\n\n* [C++ Jobs - Q4 2019](https://www.reddit.com/r/cpp/comments/dbqgbw/c_jobs_q4_2019/)", "author_fullname": "t2_21c1y", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "C++ Jobs - Q1 2020", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_eiila4", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": "", "subreddit_type": "public", "ups": 169, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 169, "approved_by": null, "author_premium": true, "thumbnail": "", "edited": 1579038018.0, "author_flair_css_class": "", "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1577915953.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;h2&gt;Rules For Individuals&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Don&amp;#39;t&lt;/strong&gt; create top-level comments - those are for employers.&lt;/li&gt;\n&lt;li&gt;Feel free to reply to top-level comments with &lt;strong&gt;on-topic&lt;/strong&gt; questions.&lt;/li&gt;\n&lt;li&gt;I will create one top-level comment for &lt;strong&gt;meta&lt;/strong&gt; discussion.&lt;/li&gt;\n&lt;li&gt;I will create another top-level comment for &lt;strong&gt;individuals looking for work&lt;/strong&gt; and &lt;strong&gt;community groups looking for sponsors&lt;/strong&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h2&gt;Rules For Employers&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;You must be hiring &lt;strong&gt;directly&lt;/strong&gt;. No third-party recruiters.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;One&lt;/strong&gt; top-level comment per employer. If you have multiple job openings, that&amp;#39;s great, but please consolidate their descriptions or mention them in replies to your own top-level comment.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Don&amp;#39;t&lt;/strong&gt; use URL shorteners. &lt;a href=\"https://www.reddithelp.com/en/categories/reddit-101/reddit-basics/reddiquette\"&gt;reddiquette&lt;/a&gt; forbids them because they&amp;#39;re opaque to the spam filter.&lt;/li&gt;\n&lt;li&gt;Templates are awesome. Please &lt;strong&gt;use&lt;/strong&gt; the following template. As the &amp;quot;formatting help&amp;quot; says, use **two stars** to &lt;strong&gt;bold text&lt;/strong&gt;. Use empty lines to separate sections.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Proofread&lt;/strong&gt; your comment after posting it, and edit any formatting mistakes.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;**Company:** [Company name; also, use the &amp;quot;formatting help&amp;quot; to make it a link to your company&amp;#39;s website, or a specific careers page if you have one.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Type:** [Full time, part time, internship, contract, etc.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Description:** [What does your company do, and what are you hiring C++ devs for? How much experience are you looking for, and what seniority levels are you hiring for? The more details you provide, the better.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Location:** [Where&amp;#39;s your office - or if you&amp;#39;re hiring at multiple offices, list them. If your workplace language isn&amp;#39;t English, please specify it.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Remote:** [Do you offer the option of working remotely? If so, do you require employees to live in certain areas or time zones?]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Visa Sponsorship:** [Does your company sponsor visas?]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Technologies:** [Required: do you mainly use C++98/03, C++11, C++14, C++17, or the C++20 working draft? Optional: do you use Linux/Mac/Windows, are there languages you use in addition to C++, are there technologies like OpenGL or libraries like Boost that you need/want/like experience with, etc.]&lt;/p&gt;\n\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\n\n&lt;p&gt;**Contact:** [How do you want to be contacted? Email, reddit PM, telepathy, gravitational waves?]&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;h2&gt;Previous Post&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://www.reddit.com/r/cpp/comments/dbqgbw/c_jobs_q4_2019/\"&gt;C++ Jobs - Q4 2019&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": "new", "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": "MSVC STL Dev", "visited": false, "removed_by": null, "num_reports": null, "distinguished": "moderator", "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "eiila4", "is_robot_indexable": true, "report_reasons": null, "author": "STL", "discussion_type": null, "num_comments": 57, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": "dark", "permalink": "/r/cpp/comments/eiila4/c_jobs_q1_2020/", "parent_whitelist_status": "all_ads", "stickied": true, "url": "https://www.reddit.com/r/cpp/comments/eiila4/c_jobs_q1_2020/", "subreddit_subscribers": 118107, "created_utc": 1577887153.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "Because I write program heavy dependent on interfaces, I was wondering, how much virtual method  call is slower than regular method call.\n\nSo I wrote program to check that.\n\nConclusion: Difference of call time between virtual methods and regular method is negligible in my opinion.\n\nWhy?\n\nIs\n\n    mov\tecx, DWORD PTR [esp+4]\n    mov\teax, DWORD PTR [ecx]\n\ncombined by processor in one command/opcode?\n\nIs time of receiving address of function in\n\n    jmp\t__ZN1X6MethodEv\n\nthe same (or almost) as in\n\n    jmp\t[DWORD PTR [eax+8]]\n\n?\n\nOr all this costs are so marginal that make them negligible?\n\nI think it is the last one.\n\n\\##########################################################################\n\nMeasurement:\n\nTo prevent some optimizations, method calls are wrapped in to callers.\n\nGlossary:\n\nmethod - member function\n\nProcessor: AMD FX-8320 (8-Core 3.50GHz)\n\n\\##########################################################################\n\nnumber of calls of each Call{...} function: 100 000 000\n\n    1\n    CallIdle:           0.163166s\n    CallMethod:         0.220805s\n    CallVirtualMethod:  0.213770s\n    2\n    CallIdle:           0.162361s\n    CallMethod:         0.216204s\n    CallVirtualMethod:  0.216748s\n    3\n    CallIdle:           0.164374s\n    CallMethod:         0.215015s\n    CallVirtualMethod:  0.215973s\n    4\n    CallIdle:           0.163159s\n    CallMethod:         0.216749s\n    CallVirtualMethod:  0.219072s\n    5\n    CallIdle:           0.162431s\n    CallMethod:         0.215293s\n    CallVirtualMethod:  0.215578s\n\nCompiler:\n\nGCC 8.1.0 (MinGW\\_64)\n\nCommand\n\ng++ -std=c++17 -Wall -Werror -pedantic -O3 -o prog.exe C.cpp main.cpp X.cpp\n\nCommand ASM:\n\ng++ -std=c++17 -Wall -Werror -pedantic -O3 -S -masm=intel C.cpp main.cpp X.cpp\n\nC.cpp\n\n    #include \"C.h\"\n    \n    void CallIdle(X* x) {\n        \n    }\n    void CallMethod(X* x) {\n        x-&gt;Method();\n    }\n    void CallVirtualMethod(X* x) {\n        x-&gt;VirtualMethod();\n    }\n\nC.s (single call of method)\n\n    __Z8CallIdleP1X:\n    LFB7:\n        ret\n    LFE7:\n    __Z10CallMethodP1X:\n    LFB8:\n        mov\tecx, DWORD PTR [esp+4]\n        jmp\t__ZN1X6MethodEv\n    LFE8:\n    __Z17CallVirtualMethodP1X:\n    LFB9:\n        mov\tecx, DWORD PTR [esp+4]\n        mov\teax, DWORD PTR [ecx]\n        jmp\t[DWORD PTR [eax+8]]     ; receiving address of virtual method from virtual table\n    LFE9:\n\n\\##########################################################################\n\nAdded second call of method inside Call{...} function to force using 'call' instead of 'jump'.\n\nnumber of calls of each Call{...} function: 100 000 000\n\n    1\n    CallIdle:           0.163293s\n    CallMethod:         0.351328s\n    CallVirtualMethod:  0.351897s\n    2\n    CallIdle:           0.166338s\n    CallMethod:         0.355633s\n    CallVirtualMethod:  0.352889s\n    3\n    CallIdle:           0.161744s\n    CallMethod:         0.355947s\n    CallVirtualMethod:  0.354000s\n    4\n    CallIdle:           0.163226s\n    CallMethod:         0.355849s\n    CallVirtualMethod:  0.354166s\n    5\n    CallIdle:           0.162738s\n    CallMethod:         0.352778s\n    CallVirtualMethod:  0.357627s\n\nCompiler:\n\nGCC 8.1.0 (MinGW\\_64)\n\nCommand:\n\ng++ -std=c++17 -Wall -Werror -pedantic -O3 -o prog.exe C.cpp main.cpp X.cpp\n\nCommand ASM:\n\ng++ -std=c++17 -Wall -Werror -pedantic -O3 -S -masm=intel C.cpp main.cpp X.cpp\n\nC.cpp\n\n    #include \"C.h\"\n    \n    void CallIdle(X* x) {\n        \n    }\n    void CallMethod(X* x) {\n        x-&gt;Method();\n        x-&gt;Method();\n    }\n    void CallVirtualMethod(X* x) {\n        x-&gt;VirtualMethod();\n        x-&gt;VirtualMethod();\n    }\n\nC.s (double call of method, forces using 'call' instead of 'jump')\n\n    __Z8CallIdleP1X:\n    LFB7:\n        ret\n    LFE7:\n    __Z10CallMethodP1X:\n    LFB8:\n        push\tebx\n        sub\tesp, 8\n        mov\tebx, DWORD PTR [esp+16]\n        mov\tecx, ebx\n        call\t__ZN1X6MethodEv\n        add\tesp, 8\n        mov\tecx, ebx\n        pop\tebx\n        jmp\t__ZN1X6MethodEv\n    LFE8:\n    __Z17CallVirtualMethodP1X:\n    LFB9:\n        push\tebx\n        sub\tesp, 8\n        mov\tebx, DWORD PTR [esp+16]\n        mov\teax, DWORD PTR [ebx]\n        mov\tecx, ebx\n        call\t[DWORD PTR [eax+8]]\n        mov\teax, DWORD PTR [ebx]\n        mov\tecx, ebx\n        mov\teax, DWORD PTR [eax+8]\n        add\tesp, 8\n        pop\tebx\n        jmp\teax\n    LFE9:\n\n\\##########################################################################\n\nnumber of calls of each Call{...} function: 100 000 000\n\n    1\n    CallIdle:           0.162881s\n    CallMethod:         0.214449s\n    CallVirtualMethod:  0.238884s\n    2\n    CallIdle:           0.159846s\n    CallMethod:         0.217064s\n    CallVirtualMethod:  0.246562s\n    3\n    CallIdle:           0.159290s\n    CallMethod:         0.214154s\n    CallVirtualMethod:  0.240654s\n    4\n    CallIdle:           0.161967s\n    CallMethod:         0.215867s\n    CallVirtualMethod:  0.241240s\n    5\n    CallIdle:           0.158927s\n    CallMethod:         0.212364s\n    CallVirtualMethod:  0.241170s\n\nCompiler:\n\nMSVC 2013\n\nCommand:\n\ncl /nologo /D\\_USING\\_V110\\_SDK71\\_=1 C.cpp main.cpp X.cpp /EHs /GR /O2 /MD /MP /Fomsvc\\_make\\_temp\\\\ /Fdmsvc\\_make\\_temp\\\\ /link /out:prog.exe\n\nCommand ASM:\n\ncl /nologo /D\\_USING\\_V110\\_SDK71\\_=1 C.cpp main.cpp X.cpp /FAs /EHs /GR /O2 /MD /MP\n\nC.asm (single call of method)\n\n    ; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 \n    \n        TITLE\tG:\\work\\code\\RandomMinGW\\examples\\example_093_virtual_vs_non_virtual\\C.cpp\n        .686P\n        .XMM\n        include listing.inc\n        .model\tflat\n    \n    INCLUDELIB MSVCRT\n    INCLUDELIB OLDNAMES\n    \n    PUBLIC\t?CallIdle@@YAXPAVX@@@Z\t\t\t\t; CallIdle\n    PUBLIC\t?CallMethod@@YAXPAVX@@@Z\t\t\t; CallMethod\n    PUBLIC\t?CallVirtualMethod@@YAXPAVX@@@Z\t\t\t; CallVirtualMethod\n    EXTRN\t?Method@X@@QAEXXZ:PROC\t\t\t\t; X::Method\n    ; Function compile flags: /Ogtpy\n    ; File g:\\work\\code\\randommingw\\examples\\example_093_virtual_vs_non_virtual\\c.cpp\n    ;\tCOMDAT ?CallVirtualMethod@@YAXPAVX@@@Z\n    _TEXT\tSEGMENT\n    _x$ = 8\t\t\t\t\t\t\t; size = 4\n    ?CallVirtualMethod@@YAXPAVX@@@Z PROC\t\t\t; CallVirtualMethod, COMDAT\n    \n    ; 11   :     x-&gt;VirtualMethod();\n    \n        mov\tecx, DWORD PTR _x$[esp-4]\n        mov\teax, DWORD PTR [ecx]\n        jmp\tDWORD PTR [eax+4]\n    ?CallVirtualMethod@@YAXPAVX@@@Z ENDP\t\t\t; CallVirtualMethod\n    _TEXT\tENDS\n    ; Function compile flags: /Ogtpy\n    ; File g:\\work\\code\\randommingw\\examples\\example_093_virtual_vs_non_virtual\\c.cpp\n    ;\tCOMDAT ?CallMethod@@YAXPAVX@@@Z\n    _TEXT\tSEGMENT\n    _x$ = 8\t\t\t\t\t\t\t; size = 4\n    ?CallMethod@@YAXPAVX@@@Z PROC\t\t\t\t; CallMethod, COMDAT\n    \n    ; 7    :     x-&gt;Method();\n    \n        mov\tecx, DWORD PTR _x$[esp-4]\n        jmp\t?Method@X@@QAEXXZ\t\t\t; X::Method\n    ?CallMethod@@YAXPAVX@@@Z ENDP\t\t\t\t; CallMethod\n    _TEXT\tENDS\n    ; Function compile flags: /Ogtpy\n    ; File g:\\work\\code\\randommingw\\examples\\example_093_virtual_vs_non_virtual\\c.cpp\n    ;\tCOMDAT ?CallIdle@@YAXPAVX@@@Z\n    _TEXT\tSEGMENT\n    _x$ = 8\t\t\t\t\t\t\t; size = 4\n    ?CallIdle@@YAXPAVX@@@Z PROC\t\t\t\t; CallIdle, COMDAT\n\n\\##########################################################################\n\nAdded second call of method inside Call{...} function to force using 'call' insted of 'jump'.\n\nnumber of calls of each Call{...} function: 100 000 000\n\n    1\n    CallIdle:           0.162718s\n    CallMethod:         0.321905s\n    CallVirtualMethod:  0.346607s\n    2\n    CallIdle:           0.165081s\n    CallMethod:         0.326066s\n    CallVirtualMethod:  0.350423s\n    3\n    CallIdle:           0.160939s\n    CallMethod:         0.323516s\n    CallVirtualMethod:  0.346217s\n    4\n    CallIdle:           0.159470s\n    CallMethod:         0.321954s\n    CallVirtualMethod:  0.350222s\n    5\n    CallIdle:           0.159132s\n    CallMethod:         0.320411s\n    CallVirtualMethod:  0.350353s\n\nC.asm (double call of method, forces using 'call' instead of 'jump')\n\n    ; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 \n    \n        TITLE\tG:\\work\\code\\RandomMinGW\\examples\\example_093_virtual_vs_non_virtual\\C.cpp\n        .686P\n        .XMM\n        include listing.inc\n        .model\tflat\n    \n    INCLUDELIB MSVCRT\n    INCLUDELIB OLDNAMES\n    \n    PUBLIC\t?CallIdle@@YAXPAVX@@@Z\t\t\t\t; CallIdle\n    PUBLIC\t?CallMethod@@YAXPAVX@@@Z\t\t\t; CallMethod\n    PUBLIC\t?CallVirtualMethod@@YAXPAVX@@@Z\t\t\t; CallVirtualMethod\n    EXTRN\t?Method@X@@QAEXXZ:PROC\t\t\t\t; X::Method\n    ; Function compile flags: /Ogtpy\n    ; File g:\\work\\code\\randommingw\\examples\\example_093_virtual_vs_non_virtual\\c.cpp\n    ;\tCOMDAT ?CallVirtualMethod@@YAXPAVX@@@Z\n    _TEXT\tSEGMENT\n    _x$ = 8\t\t\t\t\t\t\t; size = 4\n    ?CallVirtualMethod@@YAXPAVX@@@Z PROC\t\t\t; CallVirtualMethod, COMDAT\n    \n    ; 10   : void CallVirtualMethod(X* x) {\n    \n        push\tesi\n    \n    ; 11   :     x-&gt;VirtualMethod();\n    \n        mov\tesi, DWORD PTR _x$[esp]\n        mov\tecx, esi\n        mov\teax, DWORD PTR [esi]\n        call\tDWORD PTR [eax+4]\n    \n    ; 12   :     x-&gt;VirtualMethod();\n    \n        mov\teax, DWORD PTR [esi]\n        mov\tecx, esi\n        pop\tesi\n        jmp\tDWORD PTR [eax+4]\n    ?CallVirtualMethod@@YAXPAVX@@@Z ENDP\t\t\t; CallVirtualMethod\n    _TEXT\tENDS\n    ; Function compile flags: /Ogtpy\n    ; File g:\\work\\code\\randommingw\\examples\\example_093_virtual_vs_non_virtual\\c.cpp\n    ;\tCOMDAT ?CallMethod@@YAXPAVX@@@Z\n    _TEXT\tSEGMENT\n    _x$ = 8\t\t\t\t\t\t\t; size = 4\n    ?CallMethod@@YAXPAVX@@@Z PROC\t\t\t\t; CallMethod, COMDAT\n    \n    ; 7    :     x-&gt;Method();\n    \n        mov\tecx, DWORD PTR _x$[esp-4]\n        call\t?Method@X@@QAEXXZ\t\t\t; X::Method\n    \n    ; 8    :     x-&gt;Method();\n    \n        mov\tecx, DWORD PTR _x$[esp-4]\n        jmp\t?Method@X@@QAEXXZ\t\t\t; X::Method\n    ?CallMethod@@YAXPAVX@@@Z ENDP\t\t\t\t; CallMethod\n    _TEXT\tENDS\n    ; Function compile flags: /Ogtpy\n    ; File g:\\work\\code\\randommingw\\examples\\example_093_virtual_vs_non_virtual\\c.cpp\n    ;\tCOMDAT ?CallIdle@@YAXPAVX@@@Z\n    _TEXT\tSEGMENT\n    _x$ = 8\t\t\t\t\t\t\t; size = 4\n    ?CallIdle@@YAXPAVX@@@Z PROC\t\t\t\t; CallIdle, COMDAT\n    \n    ; 4    :     \n    ; 5    : }\n    \n        ret\t0\n    ?CallIdle@@YAXPAVX@@@Z ENDP\t\t\t\t; CallIdle\n    _TEXT\tENDS\n    END\n\n\\##########################################################################\n\nWhole code:\n\nmain.cpp\n\n    #include &lt;windows.h&gt;\n    #include &lt;stdio.h&gt;\n    #include \"C.h\"\n    \n    #define for_ix(number) for (unsigned ix = 0; ix &lt; unsigned(number); ++ix)\n        \n    //------------------------------------------------------------------------------\n        \n    namespace {\n    LARGE_INTEGER s_freq;   // time in performance ticks\n    LARGE_INTEGER s_start;  // time in performance ticks\n    LARGE_INTEGER s_stop;   // time in performance ticks\n    double s_diff;          // time in seconds\n    } // namespace\n    \n    void Initialize();\n    void Start();\n    void Stop();\n    double Get(); // time in seconds\n    \n    //------------------------------------------------------------------------------\n    \n    int main() {\n        Initialize();\n        \n        X* x = new X();\n        \n        enum { TIMES = 100000000 };\n        \n        Start();\n        for_ix (TIMES) {\n            CallIdle(x);\n        }\n        Stop();\n        printf(\"CallIdle:           %fs\\n\", Get());\n        \n        Start();\n        for_ix (TIMES) {\n            CallMethod(x);\n        }\n        Stop();\n        printf(\"CallMethod:         %fs\\n\", Get());\n        \n        Start();\n        for_ix (TIMES) {\n            CallVirtualMethod(x);\n        }\n        Stop();\n        printf(\"CallVirtualMethod:  %fs\\n\", Get());\n        \n        delete x;\n        \n        return 0;\n    }\n    \n    //------------------------------------------------------------------------------\n    \n    inline void Initialize() {\n        QueryPerformanceFrequency(&amp;s_freq);\n    }\n    \n    inline void Start() {\n        QueryPerformanceCounter(&amp;s_start);\n    }\n    \n    inline void Stop() {\n        QueryPerformanceCounter(&amp;s_stop);\n        s_diff = double(s_stop.QuadPart - s_start.QuadPart) / s_freq.QuadPart;\n    }\n    \n    inline double Get() { \n        return s_diff; \n    } \n\nX.h\n\n    #ifndef X_H_\n    #define X_H_\n    \n    class X {\n    public:\n        X() {}\n        virtual ~X() {}\n        \n        void Method();\n        virtual void VirtualMethod();\n    };\n    \n    #endif // X_H_\n\nX.cpp\n\n    #include \"X.h\"\n    #include &lt;stdio.h&gt;\n    \n    void X::Method() {\n        //puts(\"1\");\n    }\n    \n    void X::VirtualMethod() {\n        //puts(\"2\");\n    }\n\nC.h\n\n    #ifndef C_H_\n    #define C_H_\n    \n    #include \"X.h\"\n    \n    void CallIdle(X* x);\n    void CallMethod(X* x);\n    void CallVirtualMethod(X* x);\n    \n    #endif // C_H_\n\nC.cpp\n\n    #include \"C.h\"\n    \n    void CallIdle(X* x) {\n        \n    }\n    void CallMethod(X* x) {\n        x-&gt;Method();\n        x-&gt;Method();\n    }\n    void CallVirtualMethod(X* x) {\n        x-&gt;VirtualMethod();\n        x-&gt;VirtualMethod();\n    }\n    \n\nEDIT: Minor fixes to description.", "author_fullname": "t2_270h4o", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Cost of call: Virtual Method Call vs Non Virtual Method Call (C++)", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_etpz7r", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 11, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 11, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1579954158.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1579982526.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Because I write program heavy dependent on interfaces, I was wondering, how much virtual method  call is slower than regular method call.&lt;/p&gt;\n\n&lt;p&gt;So I wrote program to check that.&lt;/p&gt;\n\n&lt;p&gt;Conclusion: Difference of call time between virtual methods and regular method is negligible in my opinion.&lt;/p&gt;\n\n&lt;p&gt;Why?&lt;/p&gt;\n\n&lt;p&gt;Is&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;mov ecx, DWORD PTR [esp+4]\nmov eax, DWORD PTR [ecx]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;combined by processor in one command/opcode?&lt;/p&gt;\n\n&lt;p&gt;Is time of receiving address of function in&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;jmp __ZN1X6MethodEv\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;the same (or almost) as in&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;jmp [DWORD PTR [eax+8]]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;?&lt;/p&gt;\n\n&lt;p&gt;Or all this costs are so marginal that make them negligible?&lt;/p&gt;\n\n&lt;p&gt;I think it is the last one.&lt;/p&gt;\n\n&lt;p&gt;##########################################################################&lt;/p&gt;\n\n&lt;p&gt;Measurement:&lt;/p&gt;\n\n&lt;p&gt;To prevent some optimizations, method calls are wrapped in to callers.&lt;/p&gt;\n\n&lt;p&gt;Glossary:&lt;/p&gt;\n\n&lt;p&gt;method - member function&lt;/p&gt;\n\n&lt;p&gt;Processor: AMD FX-8320 (8-Core 3.50GHz)&lt;/p&gt;\n\n&lt;p&gt;##########################################################################&lt;/p&gt;\n\n&lt;p&gt;number of calls of each Call{...} function: 100 000 000&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;1\nCallIdle:           0.163166s\nCallMethod:         0.220805s\nCallVirtualMethod:  0.213770s\n2\nCallIdle:           0.162361s\nCallMethod:         0.216204s\nCallVirtualMethod:  0.216748s\n3\nCallIdle:           0.164374s\nCallMethod:         0.215015s\nCallVirtualMethod:  0.215973s\n4\nCallIdle:           0.163159s\nCallMethod:         0.216749s\nCallVirtualMethod:  0.219072s\n5\nCallIdle:           0.162431s\nCallMethod:         0.215293s\nCallVirtualMethod:  0.215578s\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Compiler:&lt;/p&gt;\n\n&lt;p&gt;GCC 8.1.0 (MinGW_64)&lt;/p&gt;\n\n&lt;p&gt;Command&lt;/p&gt;\n\n&lt;p&gt;g++ -std=c++17 -Wall -Werror -pedantic -O3 -o prog.exe C.cpp main.cpp X.cpp&lt;/p&gt;\n\n&lt;p&gt;Command ASM:&lt;/p&gt;\n\n&lt;p&gt;g++ -std=c++17 -Wall -Werror -pedantic -O3 -S -masm=intel C.cpp main.cpp X.cpp&lt;/p&gt;\n\n&lt;p&gt;C.cpp&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#include &amp;quot;C.h&amp;quot;\n\nvoid CallIdle(X* x) {\n\n}\nvoid CallMethod(X* x) {\n    x-&amp;gt;Method();\n}\nvoid CallVirtualMethod(X* x) {\n    x-&amp;gt;VirtualMethod();\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;C.s (single call of method)&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;__Z8CallIdleP1X:\nLFB7:\n    ret\nLFE7:\n__Z10CallMethodP1X:\nLFB8:\n    mov ecx, DWORD PTR [esp+4]\n    jmp __ZN1X6MethodEv\nLFE8:\n__Z17CallVirtualMethodP1X:\nLFB9:\n    mov ecx, DWORD PTR [esp+4]\n    mov eax, DWORD PTR [ecx]\n    jmp [DWORD PTR [eax+8]]     ; receiving address of virtual method from virtual table\nLFE9:\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;##########################################################################&lt;/p&gt;\n\n&lt;p&gt;Added second call of method inside Call{...} function to force using &amp;#39;call&amp;#39; instead of &amp;#39;jump&amp;#39;.&lt;/p&gt;\n\n&lt;p&gt;number of calls of each Call{...} function: 100 000 000&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;1\nCallIdle:           0.163293s\nCallMethod:         0.351328s\nCallVirtualMethod:  0.351897s\n2\nCallIdle:           0.166338s\nCallMethod:         0.355633s\nCallVirtualMethod:  0.352889s\n3\nCallIdle:           0.161744s\nCallMethod:         0.355947s\nCallVirtualMethod:  0.354000s\n4\nCallIdle:           0.163226s\nCallMethod:         0.355849s\nCallVirtualMethod:  0.354166s\n5\nCallIdle:           0.162738s\nCallMethod:         0.352778s\nCallVirtualMethod:  0.357627s\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Compiler:&lt;/p&gt;\n\n&lt;p&gt;GCC 8.1.0 (MinGW_64)&lt;/p&gt;\n\n&lt;p&gt;Command:&lt;/p&gt;\n\n&lt;p&gt;g++ -std=c++17 -Wall -Werror -pedantic -O3 -o prog.exe C.cpp main.cpp X.cpp&lt;/p&gt;\n\n&lt;p&gt;Command ASM:&lt;/p&gt;\n\n&lt;p&gt;g++ -std=c++17 -Wall -Werror -pedantic -O3 -S -masm=intel C.cpp main.cpp X.cpp&lt;/p&gt;\n\n&lt;p&gt;C.cpp&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#include &amp;quot;C.h&amp;quot;\n\nvoid CallIdle(X* x) {\n\n}\nvoid CallMethod(X* x) {\n    x-&amp;gt;Method();\n    x-&amp;gt;Method();\n}\nvoid CallVirtualMethod(X* x) {\n    x-&amp;gt;VirtualMethod();\n    x-&amp;gt;VirtualMethod();\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;C.s (double call of method, forces using &amp;#39;call&amp;#39; instead of &amp;#39;jump&amp;#39;)&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;__Z8CallIdleP1X:\nLFB7:\n    ret\nLFE7:\n__Z10CallMethodP1X:\nLFB8:\n    push    ebx\n    sub esp, 8\n    mov ebx, DWORD PTR [esp+16]\n    mov ecx, ebx\n    call    __ZN1X6MethodEv\n    add esp, 8\n    mov ecx, ebx\n    pop ebx\n    jmp __ZN1X6MethodEv\nLFE8:\n__Z17CallVirtualMethodP1X:\nLFB9:\n    push    ebx\n    sub esp, 8\n    mov ebx, DWORD PTR [esp+16]\n    mov eax, DWORD PTR [ebx]\n    mov ecx, ebx\n    call    [DWORD PTR [eax+8]]\n    mov eax, DWORD PTR [ebx]\n    mov ecx, ebx\n    mov eax, DWORD PTR [eax+8]\n    add esp, 8\n    pop ebx\n    jmp eax\nLFE9:\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;##########################################################################&lt;/p&gt;\n\n&lt;p&gt;number of calls of each Call{...} function: 100 000 000&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;1\nCallIdle:           0.162881s\nCallMethod:         0.214449s\nCallVirtualMethod:  0.238884s\n2\nCallIdle:           0.159846s\nCallMethod:         0.217064s\nCallVirtualMethod:  0.246562s\n3\nCallIdle:           0.159290s\nCallMethod:         0.214154s\nCallVirtualMethod:  0.240654s\n4\nCallIdle:           0.161967s\nCallMethod:         0.215867s\nCallVirtualMethod:  0.241240s\n5\nCallIdle:           0.158927s\nCallMethod:         0.212364s\nCallVirtualMethod:  0.241170s\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Compiler:&lt;/p&gt;\n\n&lt;p&gt;MSVC 2013&lt;/p&gt;\n\n&lt;p&gt;Command:&lt;/p&gt;\n\n&lt;p&gt;cl /nologo /D_USING_V110_SDK71_=1 C.cpp main.cpp X.cpp /EHs /GR /O2 /MD /MP /Fomsvc_make_temp\\ /Fdmsvc_make_temp\\ /link /out:prog.exe&lt;/p&gt;\n\n&lt;p&gt;Command ASM:&lt;/p&gt;\n\n&lt;p&gt;cl /nologo /D_USING_V110_SDK71_=1 C.cpp main.cpp X.cpp /FAs /EHs /GR /O2 /MD /MP&lt;/p&gt;\n\n&lt;p&gt;C.asm (single call of method)&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 \n\n    TITLE   G:\\work\\code\\RandomMinGW\\examples\\example_093_virtual_vs_non_virtual\\C.cpp\n    .686P\n    .XMM\n    include listing.inc\n    .model  flat\n\nINCLUDELIB MSVCRT\nINCLUDELIB OLDNAMES\n\nPUBLIC  ?CallIdle@@YAXPAVX@@@Z              ; CallIdle\nPUBLIC  ?CallMethod@@YAXPAVX@@@Z            ; CallMethod\nPUBLIC  ?CallVirtualMethod@@YAXPAVX@@@Z         ; CallVirtualMethod\nEXTRN   ?Method@X@@QAEXXZ:PROC              ; X::Method\n; Function compile flags: /Ogtpy\n; File g:\\work\\code\\randommingw\\examples\\example_093_virtual_vs_non_virtual\\c.cpp\n;   COMDAT ?CallVirtualMethod@@YAXPAVX@@@Z\n_TEXT   SEGMENT\n_x$ = 8                         ; size = 4\n?CallVirtualMethod@@YAXPAVX@@@Z PROC            ; CallVirtualMethod, COMDAT\n\n; 11   :     x-&amp;gt;VirtualMethod();\n\n    mov ecx, DWORD PTR _x$[esp-4]\n    mov eax, DWORD PTR [ecx]\n    jmp DWORD PTR [eax+4]\n?CallVirtualMethod@@YAXPAVX@@@Z ENDP            ; CallVirtualMethod\n_TEXT   ENDS\n; Function compile flags: /Ogtpy\n; File g:\\work\\code\\randommingw\\examples\\example_093_virtual_vs_non_virtual\\c.cpp\n;   COMDAT ?CallMethod@@YAXPAVX@@@Z\n_TEXT   SEGMENT\n_x$ = 8                         ; size = 4\n?CallMethod@@YAXPAVX@@@Z PROC               ; CallMethod, COMDAT\n\n; 7    :     x-&amp;gt;Method();\n\n    mov ecx, DWORD PTR _x$[esp-4]\n    jmp ?Method@X@@QAEXXZ           ; X::Method\n?CallMethod@@YAXPAVX@@@Z ENDP               ; CallMethod\n_TEXT   ENDS\n; Function compile flags: /Ogtpy\n; File g:\\work\\code\\randommingw\\examples\\example_093_virtual_vs_non_virtual\\c.cpp\n;   COMDAT ?CallIdle@@YAXPAVX@@@Z\n_TEXT   SEGMENT\n_x$ = 8                         ; size = 4\n?CallIdle@@YAXPAVX@@@Z PROC             ; CallIdle, COMDAT\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;##########################################################################&lt;/p&gt;\n\n&lt;p&gt;Added second call of method inside Call{...} function to force using &amp;#39;call&amp;#39; insted of &amp;#39;jump&amp;#39;.&lt;/p&gt;\n\n&lt;p&gt;number of calls of each Call{...} function: 100 000 000&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;1\nCallIdle:           0.162718s\nCallMethod:         0.321905s\nCallVirtualMethod:  0.346607s\n2\nCallIdle:           0.165081s\nCallMethod:         0.326066s\nCallVirtualMethod:  0.350423s\n3\nCallIdle:           0.160939s\nCallMethod:         0.323516s\nCallVirtualMethod:  0.346217s\n4\nCallIdle:           0.159470s\nCallMethod:         0.321954s\nCallVirtualMethod:  0.350222s\n5\nCallIdle:           0.159132s\nCallMethod:         0.320411s\nCallVirtualMethod:  0.350353s\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;C.asm (double call of method, forces using &amp;#39;call&amp;#39; instead of &amp;#39;jump&amp;#39;)&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 \n\n    TITLE   G:\\work\\code\\RandomMinGW\\examples\\example_093_virtual_vs_non_virtual\\C.cpp\n    .686P\n    .XMM\n    include listing.inc\n    .model  flat\n\nINCLUDELIB MSVCRT\nINCLUDELIB OLDNAMES\n\nPUBLIC  ?CallIdle@@YAXPAVX@@@Z              ; CallIdle\nPUBLIC  ?CallMethod@@YAXPAVX@@@Z            ; CallMethod\nPUBLIC  ?CallVirtualMethod@@YAXPAVX@@@Z         ; CallVirtualMethod\nEXTRN   ?Method@X@@QAEXXZ:PROC              ; X::Method\n; Function compile flags: /Ogtpy\n; File g:\\work\\code\\randommingw\\examples\\example_093_virtual_vs_non_virtual\\c.cpp\n;   COMDAT ?CallVirtualMethod@@YAXPAVX@@@Z\n_TEXT   SEGMENT\n_x$ = 8                         ; size = 4\n?CallVirtualMethod@@YAXPAVX@@@Z PROC            ; CallVirtualMethod, COMDAT\n\n; 10   : void CallVirtualMethod(X* x) {\n\n    push    esi\n\n; 11   :     x-&amp;gt;VirtualMethod();\n\n    mov esi, DWORD PTR _x$[esp]\n    mov ecx, esi\n    mov eax, DWORD PTR [esi]\n    call    DWORD PTR [eax+4]\n\n; 12   :     x-&amp;gt;VirtualMethod();\n\n    mov eax, DWORD PTR [esi]\n    mov ecx, esi\n    pop esi\n    jmp DWORD PTR [eax+4]\n?CallVirtualMethod@@YAXPAVX@@@Z ENDP            ; CallVirtualMethod\n_TEXT   ENDS\n; Function compile flags: /Ogtpy\n; File g:\\work\\code\\randommingw\\examples\\example_093_virtual_vs_non_virtual\\c.cpp\n;   COMDAT ?CallMethod@@YAXPAVX@@@Z\n_TEXT   SEGMENT\n_x$ = 8                         ; size = 4\n?CallMethod@@YAXPAVX@@@Z PROC               ; CallMethod, COMDAT\n\n; 7    :     x-&amp;gt;Method();\n\n    mov ecx, DWORD PTR _x$[esp-4]\n    call    ?Method@X@@QAEXXZ           ; X::Method\n\n; 8    :     x-&amp;gt;Method();\n\n    mov ecx, DWORD PTR _x$[esp-4]\n    jmp ?Method@X@@QAEXXZ           ; X::Method\n?CallMethod@@YAXPAVX@@@Z ENDP               ; CallMethod\n_TEXT   ENDS\n; Function compile flags: /Ogtpy\n; File g:\\work\\code\\randommingw\\examples\\example_093_virtual_vs_non_virtual\\c.cpp\n;   COMDAT ?CallIdle@@YAXPAVX@@@Z\n_TEXT   SEGMENT\n_x$ = 8                         ; size = 4\n?CallIdle@@YAXPAVX@@@Z PROC             ; CallIdle, COMDAT\n\n; 4    :     \n; 5    : }\n\n    ret 0\n?CallIdle@@YAXPAVX@@@Z ENDP             ; CallIdle\n_TEXT   ENDS\nEND\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;##########################################################################&lt;/p&gt;\n\n&lt;p&gt;Whole code:&lt;/p&gt;\n\n&lt;p&gt;main.cpp&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#include &amp;lt;windows.h&amp;gt;\n#include &amp;lt;stdio.h&amp;gt;\n#include &amp;quot;C.h&amp;quot;\n\n#define for_ix(number) for (unsigned ix = 0; ix &amp;lt; unsigned(number); ++ix)\n\n//------------------------------------------------------------------------------\n\nnamespace {\nLARGE_INTEGER s_freq;   // time in performance ticks\nLARGE_INTEGER s_start;  // time in performance ticks\nLARGE_INTEGER s_stop;   // time in performance ticks\ndouble s_diff;          // time in seconds\n} // namespace\n\nvoid Initialize();\nvoid Start();\nvoid Stop();\ndouble Get(); // time in seconds\n\n//------------------------------------------------------------------------------\n\nint main() {\n    Initialize();\n\n    X* x = new X();\n\n    enum { TIMES = 100000000 };\n\n    Start();\n    for_ix (TIMES) {\n        CallIdle(x);\n    }\n    Stop();\n    printf(&amp;quot;CallIdle:           %fs\\n&amp;quot;, Get());\n\n    Start();\n    for_ix (TIMES) {\n        CallMethod(x);\n    }\n    Stop();\n    printf(&amp;quot;CallMethod:         %fs\\n&amp;quot;, Get());\n\n    Start();\n    for_ix (TIMES) {\n        CallVirtualMethod(x);\n    }\n    Stop();\n    printf(&amp;quot;CallVirtualMethod:  %fs\\n&amp;quot;, Get());\n\n    delete x;\n\n    return 0;\n}\n\n//------------------------------------------------------------------------------\n\ninline void Initialize() {\n    QueryPerformanceFrequency(&amp;amp;s_freq);\n}\n\ninline void Start() {\n    QueryPerformanceCounter(&amp;amp;s_start);\n}\n\ninline void Stop() {\n    QueryPerformanceCounter(&amp;amp;s_stop);\n    s_diff = double(s_stop.QuadPart - s_start.QuadPart) / s_freq.QuadPart;\n}\n\ninline double Get() { \n    return s_diff; \n} \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;X.h&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#ifndef X_H_\n#define X_H_\n\nclass X {\npublic:\n    X() {}\n    virtual ~X() {}\n\n    void Method();\n    virtual void VirtualMethod();\n};\n\n#endif // X_H_\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;X.cpp&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#include &amp;quot;X.h&amp;quot;\n#include &amp;lt;stdio.h&amp;gt;\n\nvoid X::Method() {\n    //puts(&amp;quot;1&amp;quot;);\n}\n\nvoid X::VirtualMethod() {\n    //puts(&amp;quot;2&amp;quot;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;C.h&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#ifndef C_H_\n#define C_H_\n\n#include &amp;quot;X.h&amp;quot;\n\nvoid CallIdle(X* x);\nvoid CallMethod(X* x);\nvoid CallVirtualMethod(X* x);\n\n#endif // C_H_\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;C.cpp&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#include &amp;quot;C.h&amp;quot;\n\nvoid CallIdle(X* x) {\n\n}\nvoid CallMethod(X* x) {\n    x-&amp;gt;Method();\n    x-&amp;gt;Method();\n}\nvoid CallVirtualMethod(X* x) {\n    x-&amp;gt;VirtualMethod();\n    x-&amp;gt;VirtualMethod();\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;EDIT: Minor fixes to description.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "etpz7r", "is_robot_indexable": true, "report_reasons": null, "author": "DajDwaZlote", "discussion_type": null, "num_comments": 11, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/etpz7r/cost_of_call_virtual_method_call_vs_non_virtual/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/etpz7r/cost_of_call_virtual_method_call_vs_non_virtual/", "subreddit_subscribers": 118107, "created_utc": 1579953726.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "", "author_fullname": "t2_11pe86", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "The C++ Lifetime Profile: How It Plans to Make C++ Code Safer", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_eta01f", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 102, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 102, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1579899063.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "pspdfkit.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "eta01f", "is_robot_indexable": true, "report_reasons": null, "author": "vormestrand", "discussion_type": null, "num_comments": 41, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/eta01f/the_c_lifetime_profile_how_it_plans_to_make_c/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://pspdfkit.com/blog/2020/the-cpp-lifetime-profile/", "subreddit_subscribers": 118107, "created_utc": 1579870263.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "", "author_fullname": "t2_4wlrpv84", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "To Bind and Loose a Reference", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_et6eht", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 59, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 59, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1579875340.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "thephd.github.io", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "et6eht", "is_robot_indexable": true, "report_reasons": null, "author": "8ad762515de8665ec9a1", "discussion_type": null, "num_comments": 66, "send_replies": false, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/et6eht/to_bind_and_loose_a_reference/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://thephd.github.io/to-bind-and-loose-a-reference-optional", "subreddit_subscribers": 118107, "created_utc": 1579846540.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "", "author_fullname": "t2_5bxjbjny", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Hidden reinterpret_casts", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_esz058", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 106, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 106, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1579840590.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "quuxplusone.github.io", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "esz058", "is_robot_indexable": true, "report_reasons": null, "author": "anonymous28974", "discussion_type": null, "num_comments": 91, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/esz058/hidden_reinterpret_casts/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://quuxplusone.github.io/blog/2020/01/22/expression-list-in-functional-cast/", "subreddit_subscribers": 118107, "created_utc": 1579811790.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "", "author_fullname": "t2_4lna0fc3", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "CppCast: Circle", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": "cppcast", "downs": 0, "hide_score": false, "name": "t3_et4dxp", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 25, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": "7bf857c8-4dcc-11e6-b84d-0e5fbba92363", "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "CppCast", "can_mod_post": false, "score": 25, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1579864340.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "cppcast.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": "CppCast Host", "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "et4dxp", "is_robot_indexable": true, "report_reasons": null, "author": "robwirving", "discussion_type": null, "num_comments": 18, "send_replies": false, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": "dark", "permalink": "/r/cpp/comments/et4dxp/cppcast_circle/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://cppcast.com/circle-language/", "subreddit_subscribers": 118107, "created_utc": 1579835540.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "Back in July of 2017 I started posting a series of videos under the premise that \"teaching is the best way to learn.\"  The premise what that I would read through the book \"Game Programming In C++ Start To Finish\" written by Erik Yuzwa and then adapt the information from said book into a video format. I now know that this was a terrible, terrible idea.\n\nThe code in the book was practically unusable., the software was out of date, and the version of OpenGL that it was using was already depreciated by the time I started my videos. I knew this going in. I further knew that attempting to get into game development via learning to program a game engine is the dumbest and hardest possible way to do so.\n\nBut I thought then, and I still think now, that my game ideas don't properly fit in any framework provided by current engines. I now know that I could have simply make a scaled down version of my ideas, refined them, learned how to code, and THEN learned how to make an engine that fit their needs, but at this point I'm 10 years in and I'm not backing down now. \n\nSo here's what I'm here to ask. If you have some spare time, could you give some or all the my tutorial series a watch, and tell me just how badly I messed everything up?\n\nI'm looking for critiques like \"this part was to fast\" \"this part was to slow\" \"To little information given here\" \"Should have mentioned where you got this or that resource\" \"Should have sited your sources for this\" etc.\n\nAll the criticisms will be cataloged along with my own criticisms of myself into a postmortem video. Then. Well. Then I'm going to try again. With a new book this time. One that I think will actually help me this time: Game Engine Architecture 2nd Edition by Jason Gregory. Also, if you have other books that you know to be excellent resources for building a good cross-platform game engine in C++, let me know so I can take a look at them. Also if there are any other series that cover the same topics, let me know about that too. I'll also be looking at the lists of books and series that already exist on this subreddit and others. Thanks in advance for any help you can provide!\n\n[Link to the series!](https://www.youtube.com/playlist?list=PLx25SxVo-qjn5eWRaBY96khBJSLy2wBty)", "author_fullname": "t2_yfree", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "I \"Finished\" Creating A Game Engine Programming In C++ Tutorial Series And Would Like Feedback For The Postmortem And Future Series", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_et0jeg", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 10, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 10, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1579846903.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Back in July of 2017 I started posting a series of videos under the premise that &amp;quot;teaching is the best way to learn.&amp;quot;  The premise what that I would read through the book &amp;quot;Game Programming In C++ Start To Finish&amp;quot; written by Erik Yuzwa and then adapt the information from said book into a video format. I now know that this was a terrible, terrible idea.&lt;/p&gt;\n\n&lt;p&gt;The code in the book was practically unusable., the software was out of date, and the version of OpenGL that it was using was already depreciated by the time I started my videos. I knew this going in. I further knew that attempting to get into game development via learning to program a game engine is the dumbest and hardest possible way to do so.&lt;/p&gt;\n\n&lt;p&gt;But I thought then, and I still think now, that my game ideas don&amp;#39;t properly fit in any framework provided by current engines. I now know that I could have simply make a scaled down version of my ideas, refined them, learned how to code, and THEN learned how to make an engine that fit their needs, but at this point I&amp;#39;m 10 years in and I&amp;#39;m not backing down now. &lt;/p&gt;\n\n&lt;p&gt;So here&amp;#39;s what I&amp;#39;m here to ask. If you have some spare time, could you give some or all the my tutorial series a watch, and tell me just how badly I messed everything up?&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m looking for critiques like &amp;quot;this part was to fast&amp;quot; &amp;quot;this part was to slow&amp;quot; &amp;quot;To little information given here&amp;quot; &amp;quot;Should have mentioned where you got this or that resource&amp;quot; &amp;quot;Should have sited your sources for this&amp;quot; etc.&lt;/p&gt;\n\n&lt;p&gt;All the criticisms will be cataloged along with my own criticisms of myself into a postmortem video. Then. Well. Then I&amp;#39;m going to try again. With a new book this time. One that I think will actually help me this time: Game Engine Architecture 2nd Edition by Jason Gregory. Also, if you have other books that you know to be excellent resources for building a good cross-platform game engine in C++, let me know so I can take a look at them. Also if there are any other series that cover the same topics, let me know about that too. I&amp;#39;ll also be looking at the lists of books and series that already exist on this subreddit and others. Thanks in advance for any help you can provide!&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://www.youtube.com/playlist?list=PLx25SxVo-qjn5eWRaBY96khBJSLy2wBty\"&gt;Link to the series!&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "et0jeg", "is_robot_indexable": true, "report_reasons": null, "author": "EarthOtherwise", "discussion_type": null, "num_comments": 11, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/et0jeg/i_finished_creating_a_game_engine_programming_in/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/et0jeg/i_finished_creating_a_game_engine_programming_in/", "subreddit_subscribers": 118107, "created_utc": 1579818103.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "I'm adding unit tests to a couple of codebases which haven't had them before.  To break dependencies I'm factoring out interfaces (base classes with only pure virtual functions) for each class's collaborators.\n\n**This generates so. many. new. files.**\n\nC++ already averages 2x as many files as classes because of the .h/.cpp split.  Now I have 4x as many files as (concrete) classes.  I'm not even counting test mocks, I'm talking just in the core project.\n\nI don't really want to put the interfaces in the same .h file as the concrete classes, because declaring the interface in its own file allows me to strip out #include's if they were only necessary to the concrete implementation but not needed by the interface class.\n\nI could eliminate the .cpp file for the interface, but I'm using those to define the pure virtual destructors.  Also to follow John Lakos's advice that every class / header should be included in a corresponding .cpp file even if the .cpp file otherwise has nothing to do.  (It provides assurances the header is correct and self-sufficient.)\n\nOne of my projects is a legacy MFC app.  In order to disentangle the business logic from the presentation logic from the Lovecraftian horror of Windows programming I'm splitting every dialog class into a view, presenter, and model.  But that's 3x the files.  Most need interfaces, so 2x3.  Count .h/.cpp and you have 2x2x3 = 12 files per dialog.\n\nTwelve.\n\nTimes 50 dialogs.\n\n**How am I supposed to keep this shit organized?**\n\nI mean, it is what it is.  I'm just looking for assurances before I go on a tear doing a refactoring that turns 100 code files into 600 code files that I'm not missing something here.", "author_fullname": "t2_ec0t9", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Refactoring generates so many new source files", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_et0t56", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 7, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 7, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1579848033.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m adding unit tests to a couple of codebases which haven&amp;#39;t had them before.  To break dependencies I&amp;#39;m factoring out interfaces (base classes with only pure virtual functions) for each class&amp;#39;s collaborators.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;This generates so. many. new. files.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;C++ already averages 2x as many files as classes because of the .h/.cpp split.  Now I have 4x as many files as (concrete) classes.  I&amp;#39;m not even counting test mocks, I&amp;#39;m talking just in the core project.&lt;/p&gt;\n\n&lt;p&gt;I don&amp;#39;t really want to put the interfaces in the same .h file as the concrete classes, because declaring the interface in its own file allows me to strip out #include&amp;#39;s if they were only necessary to the concrete implementation but not needed by the interface class.&lt;/p&gt;\n\n&lt;p&gt;I could eliminate the .cpp file for the interface, but I&amp;#39;m using those to define the pure virtual destructors.  Also to follow John Lakos&amp;#39;s advice that every class / header should be included in a corresponding .cpp file even if the .cpp file otherwise has nothing to do.  (It provides assurances the header is correct and self-sufficient.)&lt;/p&gt;\n\n&lt;p&gt;One of my projects is a legacy MFC app.  In order to disentangle the business logic from the presentation logic from the Lovecraftian horror of Windows programming I&amp;#39;m splitting every dialog class into a view, presenter, and model.  But that&amp;#39;s 3x the files.  Most need interfaces, so 2x3.  Count .h/.cpp and you have 2x2x3 = 12 files per dialog.&lt;/p&gt;\n\n&lt;p&gt;Twelve.&lt;/p&gt;\n\n&lt;p&gt;Times 50 dialogs.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;How am I supposed to keep this shit organized?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;I mean, it is what it is.  I&amp;#39;m just looking for assurances before I go on a tear doing a refactoring that turns 100 code files into 600 code files that I&amp;#39;m not missing something here.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "et0t56", "is_robot_indexable": true, "report_reasons": null, "author": "denito2", "discussion_type": null, "num_comments": 33, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/et0t56/refactoring_generates_so_many_new_source_files/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/et0t56/refactoring_generates_so_many_new_source_files/", "subreddit_subscribers": 118107, "created_utc": 1579819233.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "I am learning C++. In C, I can type `man function_name` and get a concise but helpful reference of a function.\n\nI tried `stdman` which is a man page version of cppreference website. It is nowhere near C man pages which neatly give function signature, arguments and return value. (maybe partly because C functions are simple and no templating). Compared to them, stdman or whatever C++ reference is horrible. Moreover, it is hard to get complete information about a function like std::string::copy() (Maybe I am missing something here though).\n\nsimilarly, in python also, documentation was one help() away in interpreter. Is there an analogue for C++? I don't need to see all possibilities with the function or heck, not even complete type signature. For some example:\n\n    std::find(iterator m, iterator n, value) - find given element in given collection\n\nI will not be learning function from scratch every time, I just need it to remind me.\n\nif you know something like that, please comment.", "author_fullname": "t2_42cz2xr8", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Concise offline reference", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_estu90", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 25, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 25, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1579818505.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I am learning C++. In C, I can type &lt;code&gt;man function_name&lt;/code&gt; and get a concise but helpful reference of a function.&lt;/p&gt;\n\n&lt;p&gt;I tried &lt;code&gt;stdman&lt;/code&gt; which is a man page version of cppreference website. It is nowhere near C man pages which neatly give function signature, arguments and return value. (maybe partly because C functions are simple and no templating). Compared to them, stdman or whatever C++ reference is horrible. Moreover, it is hard to get complete information about a function like std::string::copy() (Maybe I am missing something here though).&lt;/p&gt;\n\n&lt;p&gt;similarly, in python also, documentation was one help() away in interpreter. Is there an analogue for C++? I don&amp;#39;t need to see all possibilities with the function or heck, not even complete type signature. For some example:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;std::find(iterator m, iterator n, value) - find given element in given collection\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I will not be learning function from scratch every time, I just need it to remind me.&lt;/p&gt;\n\n&lt;p&gt;if you know something like that, please comment.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "estu90", "is_robot_indexable": true, "report_reasons": null, "author": "linus_stallman", "discussion_type": null, "num_comments": 26, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/estu90/concise_offline_reference/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/estu90/concise_offline_reference/", "subreddit_subscribers": 118107, "created_utc": 1579789705.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "We have a massive C++ code base where much of the core was written in the early 2000's using error codes and a custom template library to support an exception free environment.\n\nOver the years we've lost support in the team to continue to maintain and debug the custom template library and there's been a desire to \"modernize\" our code.  One aspect being the use of the STL.  However, this creates some issues as we can now have functions that can return error codes and throw exceptions which makes things increasingly difficult to reason about.\n\nHas anyone has experience going from exception free code to introducing something like the STL?  If so, what was your approach?\n\nA couple things I could think of off the top of my head.  Have one master catch statement in our runtime code.  Or perhaps create macro that wraps every STL call that can throw in a try catch (though this feels cumbersome).  I'll admit, I don't have much experience with exceptions as I've mainly worked in this codebase for the past couple years.", "author_fullname": "t2_kka94", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How to introduce exceptions into historically exception free code base?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_espg2t", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 61, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 61, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1579791099.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.cpp", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;We have a massive C++ code base where much of the core was written in the early 2000&amp;#39;s using error codes and a custom template library to support an exception free environment.&lt;/p&gt;\n\n&lt;p&gt;Over the years we&amp;#39;ve lost support in the team to continue to maintain and debug the custom template library and there&amp;#39;s been a desire to &amp;quot;modernize&amp;quot; our code.  One aspect being the use of the STL.  However, this creates some issues as we can now have functions that can return error codes and throw exceptions which makes things increasingly difficult to reason about.&lt;/p&gt;\n\n&lt;p&gt;Has anyone has experience going from exception free code to introducing something like the STL?  If so, what was your approach?&lt;/p&gt;\n\n&lt;p&gt;A couple things I could think of off the top of my head.  Have one master catch statement in our runtime code.  Or perhaps create macro that wraps every STL call that can throw in a try catch (though this feels cumbersome).  I&amp;#39;ll admit, I don&amp;#39;t have much experience with exceptions as I&amp;#39;ve mainly worked in this codebase for the past couple years.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "espg2t", "is_robot_indexable": true, "report_reasons": null, "author": "jokem59", "discussion_type": null, "num_comments": 78, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/espg2t/how_to_introduce_exceptions_into_historically/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/cpp/comments/espg2t/how_to_introduce_exceptions_into_historically/", "subreddit_subscribers": 118107, "created_utc": 1579762299.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "cpp", "selftext": "", "author_fullname": "t2_6gkbb", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "C++ Packaging and Design Rules | Large-Scale C++ Volume I: Process and Architecture", "link_flair_richtext": [], "subreddit_name_prefixed": "r/cpp", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_esxoq7", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 6, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 6, "approved_by": null, "author_premium": true, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1579835147.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "informit.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qi27", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "esxoq7", "is_robot_indexable": true, "report_reasons": null, "author": "mttd", "discussion_type": null, "num_comments": 4, "send_replies": false, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/cpp/comments/esxoq7/c_packaging_and_design_rules_largescale_c_volume/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "http://www.informit.com/articles/article.aspx?p=2995361", "subreddit_subscribers": 118107, "created_utc": 1579806347.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_esxoq7", "before": null}}