{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_ln3u0", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "SpaceX Dragon ISS docking autopilot using Go and WebAssembly, well documented", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_gqk61u", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.99, "author_flair_background_color": null, "subreddit_type": "public", "ups": 240, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 240, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1590472407.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gqk61u", "is_robot_indexable": true, "report_reasons": null, "author": "mbertschler", "discussion_type": null, "num_comments": 19, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gqk61u/spacex_dragon_iss_docking_autopilot_using_go_and/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/mbertschler/dragon-iss-docking-autopilot", "subreddit_subscribers": 113889, "created_utc": 1590443607.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_6fgw8z4d", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Instrumentation in Go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_gquh39", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.83, "author_flair_background_color": null, "subreddit_type": "public", "ups": 7, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 7, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1590517485.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "gbws.io", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gquh39", "is_robot_indexable": true, "report_reasons": null, "author": "ajaister", "discussion_type": null, "num_comments": 0, "send_replies": false, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gquh39/instrumentation_in_go/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://gbws.io/articles/instrumentation-in-go/", "subreddit_subscribers": 113889, "created_utc": 1590488685.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_upj0q40", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "HTTP how to stream download response", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_gqw3yg", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 4, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 4, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1590524966.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "rafallorenz.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gqw3yg", "is_robot_indexable": true, "report_reasons": null, "author": "_vardius", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gqw3yg/http_how_to_stream_download_response/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://rafallorenz.com/go/go-http-stream-download/", "subreddit_subscribers": 113889, "created_utc": 1590496166.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "It's a rather weird and perhaps, subjective question, but not without its grounds. I have been using both languages for quite some time, and like each one for its own merit. I think, there are many things that Go developers can learn from the Erlang/Elixir ecosystem.  \n\n\nAre there other people in this community who equally like both languages? How do you distinguish what to use each for?", "author_fullname": "t2_ggszd", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "What does the Go community think of Elixir?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_gqsoq1", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 7, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 7, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1590508113.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;It&amp;#39;s a rather weird and perhaps, subjective question, but not without its grounds. I have been using both languages for quite some time, and like each one for its own merit. I think, there are many things that Go developers can learn from the Erlang/Elixir ecosystem.  &lt;/p&gt;\n\n&lt;p&gt;Are there other people in this community who equally like both languages? How do you distinguish what to use each for?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gqsoq1", "is_robot_indexable": true, "report_reasons": null, "author": "preslavrachev", "discussion_type": null, "num_comments": 10, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gqsoq1/what_does_the_go_community_think_of_elixir/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/gqsoq1/what_does_the_go_community_think_of_elixir/", "subreddit_subscribers": 113889, "created_utc": 1590479313.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_2ztajdv7", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "What is a goroutine? And what is their size?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_gqat1d", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.94, "author_flair_background_color": null, "subreddit_type": "public", "ups": 141, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 141, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1590441468.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "tpaschalis.github.io", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gqat1d", "is_robot_indexable": true, "report_reasons": null, "author": "hyperTrashPanda", "discussion_type": null, "num_comments": 15, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gqat1d/what_is_a_goroutine_and_what_is_their_size/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://tpaschalis.github.io/goroutines-size/", "subreddit_subscribers": 113889, "created_utc": 1590412668.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_xuyfp", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Webassembly demos using the Pigo face detection library", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_gqvj3s", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1590522467.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gqvj3s", "is_robot_indexable": true, "report_reasons": null, "author": "esimov", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gqvj3s/webassembly_demos_using_the_pigo_face_detection/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/esimov/pigo-wasm-demos", "subreddit_subscribers": 113889, "created_utc": 1590493667.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "**Platform: Windows 10 x64**\n\nBased on [this website](https://zeromq.org/languages/go/), I want to use **zeromq**.\n\nHere is what I have done till now:\n\nI installed **msys2** and in **MSYS2 MSYS** command window, issued the following command:\n\n    pacman -Syuu\n\nThen in the **MSYS2 MinGW 64-bit** command window:\n\n    pacman -Sy libtool\n\nthen added ***\"C:\\\\msys64\\\\mingw64\\\\bin\"*** to the Path and finally in a command prompt window:\n\n    go get \"github.com/zeromq/goczmq\"\n\nThis gave me this error:\n\n    # github.com/zeromq/goczmq\n    Documents\\Golang\\GoWorkspace\\src\\github.com\\zeromq\\goczmq\\auth.go:4:10: fatal error: czmq.h: No such file or directory\n        4 | #include \"czmq.h\"\n          |          ^~~~~~~~\n    compilation terminated.\n\nSo I downloaded **zeromq** from [here](https://github.com/zeromq/czmq/releases) copied all the contents of its **include** folder into the ***\"Documents\\\\Golang\\\\GoWorkspace\\\\src\\\\***[***github.com***](https://github.com)***\\\\zeromq\\\\goczmq\\\\\"*** path and got this error:\n\n    # github.com/zeromq/goczmq\n    In file included from ./czmq_library.h:23,\n                     from ./czmq.h:37,\n                     from Documents\\Golang\\GoWorkspace\\src\\github.com\\zeromq\\goczmq\\auth.go:4:\n    ./czmq_prelude.h:217:10: fatal error: zmq.h: No such file or directory\n      217 | #include \"zmq.h\"\n          |          ^~~~~~~\n    compilation terminated.\n\nthis time I downloaded the  **ZeroMQ** library from [here](https://zeromq.org/download/) ([Visual Studio 15 2017 x64](https://dl.bintray.com/zeromq/generic/libzmq-v141-x64-4_3_2.zip)) and copied all of its content into the ***\"Documents\\\\Golang\\\\GoWorkspace\\\\src\\\\***[***github.com***](https://github.com)***\\\\zeromq\\\\goczmq\\\\\"*** path and got:\n\n    # github.com/zeromq/goczmq\n    C:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/10.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe: cannot find -lsodium\n    C:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/10.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe: cannot find -lzmq\n    C:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/10.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe: cannot find -lczmq\n    collect2.exe: error: ld returned 1 exit status\n\nI was able to fix the missing -lsodium by using:\n\n    pacman -Ss libsodium\n    \n    and then:\n    \n    pacman -S mingw64/mingw-w64-x86_64-libsodium\n\nbut I still get the error of missing **-lczmq** and **-lzmq**. How can I install those packages? Actually what is the proper way for installing and using packages such as **zeromq** in Go?", "author_fullname": "t2_3erzrzyu", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "What is the proper way to get zeromq up and running in Go?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_gqv77p", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1590521004.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;strong&gt;Platform: Windows 10 x64&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Based on &lt;a href=\"https://zeromq.org/languages/go/\"&gt;this website&lt;/a&gt;, I want to use &lt;strong&gt;zeromq&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;Here is what I have done till now:&lt;/p&gt;\n\n&lt;p&gt;I installed &lt;strong&gt;msys2&lt;/strong&gt; and in &lt;strong&gt;MSYS2 MSYS&lt;/strong&gt; command window, issued the following command:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;pacman -Syuu\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then in the &lt;strong&gt;MSYS2 MinGW 64-bit&lt;/strong&gt; command window:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;pacman -Sy libtool\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;then added &lt;strong&gt;&lt;em&gt;&amp;quot;C:\\msys64\\mingw64\\bin&amp;quot;&lt;/em&gt;&lt;/strong&gt; to the Path and finally in a command prompt window:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;go get &amp;quot;github.com/zeromq/goczmq&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This gave me this error:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;# github.com/zeromq/goczmq\nDocuments\\Golang\\GoWorkspace\\src\\github.com\\zeromq\\goczmq\\auth.go:4:10: fatal error: czmq.h: No such file or directory\n    4 | #include &amp;quot;czmq.h&amp;quot;\n      |          ^~~~~~~~\ncompilation terminated.\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So I downloaded &lt;strong&gt;zeromq&lt;/strong&gt; from &lt;a href=\"https://github.com/zeromq/czmq/releases\"&gt;here&lt;/a&gt; copied all the contents of its &lt;strong&gt;include&lt;/strong&gt; folder into the &lt;strong&gt;&lt;em&gt;&amp;quot;Documents\\Golang\\GoWorkspace\\src\\&lt;/em&gt;&lt;/strong&gt;&lt;a href=\"https://github.com\"&gt;&lt;strong&gt;&lt;em&gt;github.com&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;\\zeromq\\goczmq\\&amp;quot;&lt;/em&gt;&lt;/strong&gt; path and got this error:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;# github.com/zeromq/goczmq\nIn file included from ./czmq_library.h:23,\n                 from ./czmq.h:37,\n                 from Documents\\Golang\\GoWorkspace\\src\\github.com\\zeromq\\goczmq\\auth.go:4:\n./czmq_prelude.h:217:10: fatal error: zmq.h: No such file or directory\n  217 | #include &amp;quot;zmq.h&amp;quot;\n      |          ^~~~~~~\ncompilation terminated.\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;this time I downloaded the  &lt;strong&gt;ZeroMQ&lt;/strong&gt; library from &lt;a href=\"https://zeromq.org/download/\"&gt;here&lt;/a&gt; (&lt;a href=\"https://dl.bintray.com/zeromq/generic/libzmq-v141-x64-4_3_2.zip\"&gt;Visual Studio 15 2017 x64&lt;/a&gt;) and copied all of its content into the &lt;strong&gt;&lt;em&gt;&amp;quot;Documents\\Golang\\GoWorkspace\\src\\&lt;/em&gt;&lt;/strong&gt;&lt;a href=\"https://github.com\"&gt;&lt;strong&gt;&lt;em&gt;github.com&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;\\zeromq\\goczmq\\&amp;quot;&lt;/em&gt;&lt;/strong&gt; path and got:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;# github.com/zeromq/goczmq\nC:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/10.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe: cannot find -lsodium\nC:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/10.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe: cannot find -lzmq\nC:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/10.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe: cannot find -lczmq\ncollect2.exe: error: ld returned 1 exit status\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I was able to fix the missing -lsodium by using:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;pacman -Ss libsodium\n\nand then:\n\npacman -S mingw64/mingw-w64-x86_64-libsodium\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;but I still get the error of missing &lt;strong&gt;-lczmq&lt;/strong&gt; and &lt;strong&gt;-lzmq&lt;/strong&gt;. How can I install those packages? Actually what is the proper way for installing and using packages such as &lt;strong&gt;zeromq&lt;/strong&gt; in Go?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gqv77p", "is_robot_indexable": true, "report_reasons": null, "author": "xita9x9", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gqv77p/what_is_the_proper_way_to_get_zeromq_up_and/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/gqv77p/what_is_the_proper_way_to_get_zeromq_up_and/", "subreddit_subscribers": 113889, "created_utc": 1590492204.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "I've looked at both\n\n1. [https://github.com/go-telegram-bot-api/telegram-bot-api](https://github.com/go-telegram-bot-api/telegram-bot-api)\n2. [https://github.com/tucnak/telebot](https://github.com/tucnak/telebot)\n\nThe first one seems to have minimal abstraction (too bare) while the second one seems to rely too much on interfaces (possible runtime type safety issues). Does anyone have any experience with either of these frameworks and which one is more reliable?", "author_fullname": "t2_4lsrg0y", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Which Go telegram bot framework to use?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_gqrp0g", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.81, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1590503097.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;ve looked at both&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=\"https://github.com/go-telegram-bot-api/telegram-bot-api\"&gt;https://github.com/go-telegram-bot-api/telegram-bot-api&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://github.com/tucnak/telebot\"&gt;https://github.com/tucnak/telebot&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;The first one seems to have minimal abstraction (too bare) while the second one seems to rely too much on interfaces (possible runtime type safety issues). Does anyone have any experience with either of these frameworks and which one is more reliable?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gqrp0g", "is_robot_indexable": true, "report_reasons": null, "author": "chuabingquan", "discussion_type": null, "num_comments": 1, "send_replies": false, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gqrp0g/which_go_telegram_bot_framework_to_use/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/gqrp0g/which_go_telegram_bot_framework_to_use/", "subreddit_subscribers": 113889, "created_utc": 1590474297.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "As applications grow, so does their complexity, and with it, the traceability of things running in parallel Go's race detector is good for keeping an eye on shared memory touched by multiple goroutines. It won't however, report on goroutines stuck on a channel that never gets emptied. In large concurrent applications, this use case is fairly common. Unless one adds log traces on each step, it is fairly easy to get a running app (no compile or runtime errors), which does nothing, because some goroutine somewhere gets stuck, and with it, a whole chain of actions.\n\nWhat would be some cool tips for instrumenting Go code, such that stuck long-running goroutines can be pointed out immediately? The only thing I can think of right now is pprof", "author_fullname": "t2_ggszd", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "What are some good tips for keeping an eye on blocked / stuck goroutines?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_gqvt1f", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1590523685.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;As applications grow, so does their complexity, and with it, the traceability of things running in parallel Go&amp;#39;s race detector is good for keeping an eye on shared memory touched by multiple goroutines. It won&amp;#39;t however, report on goroutines stuck on a channel that never gets emptied. In large concurrent applications, this use case is fairly common. Unless one adds log traces on each step, it is fairly easy to get a running app (no compile or runtime errors), which does nothing, because some goroutine somewhere gets stuck, and with it, a whole chain of actions.&lt;/p&gt;\n\n&lt;p&gt;What would be some cool tips for instrumenting Go code, such that stuck long-running goroutines can be pointed out immediately? The only thing I can think of right now is pprof&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gqvt1f", "is_robot_indexable": true, "report_reasons": null, "author": "preslavrachev", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gqvt1f/what_are_some_good_tips_for_keeping_an_eye_on/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/gqvt1f/what_are_some_good_tips_for_keeping_an_eye_on/", "subreddit_subscribers": 113889, "created_utc": 1590494885.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": " \n\nI plan to use grpc as an inter-service sync communication protocol. There are lots of different services and I have generated a pb.go  \n file with all the relevant code for client and server using protoc  \n with the go-rpc plugin.\n\nNow I'm trying to figure out the best way or the common way of consuming this service from another service. Here is what I have so far:\n\n**Option 1**\n\n1. use the .proto  \n file from the service (download it)\n2. run the protoc  \n compiler and generate the ...pb.go  \n file for the consumer to use\n\n**Option 2**\n\n1. because the ...pb.go  \n is already generated on the grpc service side to implement the server and my client is another service written in go I can expose this as a sub module (another .mod  \n file in a sub- directory)\n2. use go get github.com/usr/my-cool-grpc-service/client\n\nOption 2 seems more appealing to me because it makes the consumption of a service very easy and available for all other services that may require it.\n\nOn the other hand I know that the .proto  \n file is the contract that cann generate clients for many different languages and should be used the the source of truth.\n\nI fear that by choosing option 2 I'm unaware of any possible pitfalls I might encounter with regards to backwards compatibility or any other topic..\n\nSo, what is the idiomatic way of consuming a gRPC service?", "author_fullname": "t2_1329i2", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "consuming grpc service using go (re-post from stackoverflow) - https://stackoverflow.com/questions/62021444/consuming-grpc-service-using-go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_gqvqjb", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1590523376.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I plan to use grpc as an inter-service sync communication protocol. There are lots of different services and I have generated a pb.go&lt;br/&gt;\n file with all the relevant code for client and server using protoc&lt;br/&gt;\n with the go-rpc plugin.&lt;/p&gt;\n\n&lt;p&gt;Now I&amp;#39;m trying to figure out the best way or the common way of consuming this service from another service. Here is what I have so far:&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Option 1&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;use the .proto&lt;br/&gt;\nfile from the service (download it)&lt;/li&gt;\n&lt;li&gt;run the protoc&lt;br/&gt;\ncompiler and generate the ...pb.go&lt;br/&gt;\nfile for the consumer to use&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;&lt;strong&gt;Option 2&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;because the ...pb.go&lt;br/&gt;\nis already generated on the grpc service side to implement the server and my client is another service written in go I can expose this as a sub module (another .mod&lt;br/&gt;\nfile in a sub- directory)&lt;/li&gt;\n&lt;li&gt;use go get github.com/usr/my-cool-grpc-service/client&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Option 2 seems more appealing to me because it makes the consumption of a service very easy and available for all other services that may require it.&lt;/p&gt;\n\n&lt;p&gt;On the other hand I know that the .proto&lt;br/&gt;\n file is the contract that cann generate clients for many different languages and should be used the the source of truth.&lt;/p&gt;\n\n&lt;p&gt;I fear that by choosing option 2 I&amp;#39;m unaware of any possible pitfalls I might encounter with regards to backwards compatibility or any other topic..&lt;/p&gt;\n\n&lt;p&gt;So, what is the idiomatic way of consuming a gRPC service?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gqvqjb", "is_robot_indexable": true, "report_reasons": null, "author": "arthurvaverko", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gqvqjb/consuming_grpc_service_using_go_repost_from/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/gqvqjb/consuming_grpc_service_using_go_repost_from/", "subreddit_subscribers": 113889, "created_utc": 1590494576.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_gqvqjb", "before": null}}