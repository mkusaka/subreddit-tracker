{"kind": "Listing", "data": {"modhash": "", "dist": 12, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "Mystified about strings? Borrow checker have you in a headlock? Seek help here! There are no stupid questions, only docs that haven't been written yet.\n\nIf you have a [StackOverflow](http://stackoverflow.com/) account, consider asking it there instead! StackOverflow shows up much higher in search results, so having your question there also helps future Rust users (be sure to give it [the \"Rust\" tag](http://stackoverflow.com/questions/tagged/rust) for maximum visibility). Note that this site is very interested in question quality. I've been asked to read a RFC I authored once. If you want your code reviewed or review other's code, there's a [codereview stackexchange](https://codereview.stackexchange.com/questions/tagged/rust), too. If you need to test your code, maybe [the Rust playground](https://play.rust-lang.org) is for you.\n\nHere are some other venues where help may be found:\n\n[/r/learnrust](https://www.reddit.com/r/learnrust) is a subreddit to share your questions and epiphanies learning Rust programming.\n\nThe official Rust user forums: [https://users.rust-lang.org/](https://users.rust-lang.org/).\n\nThe official Rust Programming Language Discord: [https://discord.gg/rust-lang](https://discord.gg/rust-lang)\n\nThe unofficial Rust community Discord: [https://bit.ly/rust-community](https://bit.ly/rust-community)\n\nThe Rust-related IRC channels on irc.mozilla.org (click the links to open a web-based IRC client):\n\n - [#rust](https://chat.mibbit.com/?server=irc.mozilla.org%3A%2B6697&amp;amp;channel=%23rust) (general questions)\n - [#rust-beginners](https://chat.mibbit.com/?server=irc.mozilla.org%3A%2B6697&amp;amp;channel=%23rust-beginners) (beginner questions)\n - [#cargo](https://chat.mibbit.com/?server=irc.mozilla.org%3A%2B6697&amp;amp;channel=%23cargo) (the package manager)\n - [#rust-gamedev](https://chat.mibbit.com/?server=irc.mozilla.org%3A%2B6697&amp;amp;channel=%23rust-gamedev) (graphics and video games, and see also [/r/rust_gamedev](https://www.reddit.com/r/rust_gamedev))\n - [#rust-osdev](https://chat.mibbit.com/?server=irc.mozilla.org%3A%2B6697&amp;amp;channel=%23rust-osdev) (operating systems and embedded systems)\n - [#rust-webdev](https://chat.mibbit.com/?server=irc.mozilla.org%3A%2B6697&amp;amp;channel=%23rust-webdev) (web development)\n - [#rust-networking](https://chat.mibbit.com/?server=irc.mozilla.org%3A%2B6697&amp;amp;channel=%23rust-networking) (computer networking, and see also [/r/rust_networking](https://www.reddit.com/r/rust_networking))\n\nAlso check out [last week's thread](https://reddit.com/r/rust/comments/f1ucwh/hey_rustaceans_got_an_easy_question_ask_here/) with many good questions and answers. And if you believe your question to be either very complex or worthy of larger dissemination, feel free to create a text post.\n\nAlso if you want to be mentored by experienced Rustaceans, tell us the area of expertise that you seek.", "author_fullname": "t2_1kxp4", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Hey Rustaceans! Got an easy question? Ask here (8/2020)!", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f5413m", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": "", "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": "contrib", "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581946962.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.rust", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Mystified about strings? Borrow checker have you in a headlock? Seek help here! There are no stupid questions, only docs that haven&amp;#39;t been written yet.&lt;/p&gt;\n\n&lt;p&gt;If you have a &lt;a href=\"http://stackoverflow.com/\"&gt;StackOverflow&lt;/a&gt; account, consider asking it there instead! StackOverflow shows up much higher in search results, so having your question there also helps future Rust users (be sure to give it &lt;a href=\"http://stackoverflow.com/questions/tagged/rust\"&gt;the &amp;quot;Rust&amp;quot; tag&lt;/a&gt; for maximum visibility). Note that this site is very interested in question quality. I&amp;#39;ve been asked to read a RFC I authored once. If you want your code reviewed or review other&amp;#39;s code, there&amp;#39;s a &lt;a href=\"https://codereview.stackexchange.com/questions/tagged/rust\"&gt;codereview stackexchange&lt;/a&gt;, too. If you need to test your code, maybe &lt;a href=\"https://play.rust-lang.org\"&gt;the Rust playground&lt;/a&gt; is for you.&lt;/p&gt;\n\n&lt;p&gt;Here are some other venues where help may be found:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://www.reddit.com/r/learnrust\"&gt;/r/learnrust&lt;/a&gt; is a subreddit to share your questions and epiphanies learning Rust programming.&lt;/p&gt;\n\n&lt;p&gt;The official Rust user forums: &lt;a href=\"https://users.rust-lang.org/\"&gt;https://users.rust-lang.org/&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;The official Rust Programming Language Discord: &lt;a href=\"https://discord.gg/rust-lang\"&gt;https://discord.gg/rust-lang&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;The unofficial Rust community Discord: &lt;a href=\"https://bit.ly/rust-community\"&gt;https://bit.ly/rust-community&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;The Rust-related IRC channels on irc.mozilla.org (click the links to open a web-based IRC client):&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://chat.mibbit.com/?server=irc.mozilla.org%3A%2B6697&amp;amp;amp;channel=%23rust\"&gt;#rust&lt;/a&gt; (general questions)&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://chat.mibbit.com/?server=irc.mozilla.org%3A%2B6697&amp;amp;amp;channel=%23rust-beginners\"&gt;#rust-beginners&lt;/a&gt; (beginner questions)&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://chat.mibbit.com/?server=irc.mozilla.org%3A%2B6697&amp;amp;amp;channel=%23cargo\"&gt;#cargo&lt;/a&gt; (the package manager)&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://chat.mibbit.com/?server=irc.mozilla.org%3A%2B6697&amp;amp;amp;channel=%23rust-gamedev\"&gt;#rust-gamedev&lt;/a&gt; (graphics and video games, and see also &lt;a href=\"https://www.reddit.com/r/rust_gamedev\"&gt;/r/rust_gamedev&lt;/a&gt;)&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://chat.mibbit.com/?server=irc.mozilla.org%3A%2B6697&amp;amp;amp;channel=%23rust-osdev\"&gt;#rust-osdev&lt;/a&gt; (operating systems and embedded systems)&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://chat.mibbit.com/?server=irc.mozilla.org%3A%2B6697&amp;amp;amp;channel=%23rust-webdev\"&gt;#rust-webdev&lt;/a&gt; (web development)&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://chat.mibbit.com/?server=irc.mozilla.org%3A%2B6697&amp;amp;amp;channel=%23rust-networking\"&gt;#rust-networking&lt;/a&gt; (computer networking, and see also &lt;a href=\"https://www.reddit.com/r/rust_networking\"&gt;/r/rust_networking&lt;/a&gt;)&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Also check out &lt;a href=\"https://reddit.com/r/rust/comments/f1ucwh/hey_rustaceans_got_an_easy_question_ask_here/\"&gt;last week&amp;#39;s thread&lt;/a&gt; with many good questions and answers. And if you believe your question to be either very complex or worthy of larger dissemination, feel free to create a text post.&lt;/p&gt;\n\n&lt;p&gt;Also if you want to be mentored by experienced Rustaceans, tell us the area of expertise that you seek.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": "new", "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": "clippy \u00b7 twir \u00b7 rust \u00b7 mutagen \u00b7 flamer \u00b7 overflower \u00b7 bytecount", "visited": false, "removed_by": null, "num_reports": null, "distinguished": "moderator", "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f5413m", "is_robot_indexable": true, "report_reasons": null, "author": "llogiq", "discussion_type": null, "num_comments": 5, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": "dark", "permalink": "/r/rust/comments/f5413m/hey_rustaceans_got_an_easy_question_ask_here_82020/", "parent_whitelist_status": "all_ads", "stickied": true, "url": "https://www.reddit.com/r/rust/comments/f5413m/hey_rustaceans_got_an_easy_question_ask_here_82020/", "subreddit_subscribers": 91048, "created_utc": 1581918162.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "New week, new Rust! What are you folks up to? Answer here or over at [rust-users](https://users.rust-lang.org/t/whats-everyone-working-on-this-week-8-2020/38329?u=llogiq)!", "author_fullname": "t2_1kxp4", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "What's everyone working on this week (8/2020)?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f541u0", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": "", "subreddit_type": "public", "ups": 6, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 6, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": "contrib", "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581947073.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.rust", "allow_live_comments": true, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;New week, new Rust! What are you folks up to? Answer here or over at &lt;a href=\"https://users.rust-lang.org/t/whats-everyone-working-on-this-week-8-2020/38329?u=llogiq\"&gt;rust-users&lt;/a&gt;!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": "clippy \u00b7 twir \u00b7 rust \u00b7 mutagen \u00b7 flamer \u00b7 overflower \u00b7 bytecount", "visited": false, "removed_by": null, "num_reports": null, "distinguished": "moderator", "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f541u0", "is_robot_indexable": true, "report_reasons": null, "author": "llogiq", "discussion_type": null, "num_comments": 8, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": "dark", "permalink": "/r/rust/comments/f541u0/whats_everyone_working_on_this_week_82020/", "parent_whitelist_status": "all_ads", "stickied": true, "url": "https://www.reddit.com/r/rust/comments/f541u0/whats_everyone_working_on_this_week_82020/", "subreddit_subscribers": 91048, "created_utc": 1581918273.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "Recently, I updated Rust to the latest stable version (1.41.0) on my macOS system and noticed that the tests of my [pet project](https://github.com/dfyz/osm-renderer) started crashing with `capacity overflow` errors coming from `alloc::raw_vec::capacity_overflow()`. My gut reaction was that I must have been bitten by UB in my unsafe code, but surprisingly this doesn't seem to be the case here.\n\nI managed to reproduce the problem with [a tiny program](https://github.com/dfyz/rust-segfault) without any unsafe code at all (and no external crates). When I run it with `cargo run --release` on either Ubuntu 19.10 or macOS 10.15, I get something like this:\n\n```\n$ cargo run --release\n[...]\n0 0 3 18446744073709551615\n[1]    19196 segmentation fault  cargo run --release\n```\n\nBasically, a slice obtained from an array of small length somehow has length `2**64 - 1`, which allows you to read from memory you don't have access to without bounds checking. The expected output is something like this:\n```\n[...]\n0 0 3 0\nthread 'main' panicked at 'index out of bounds: the len is 0 but the index is 16777216', src/main.rs:13:35\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n```\n\nThe problem goes away if I do any of the following:\n  * remove either of the two `do_test(...);` calls in `main()`;\n  * remove the `for _ in 0..1 {` loop;\n  * replace the `for y in 0..x {` loop with `for y in 0..1 {`;\n  * remove the `z.extend(std::iter::repeat(0).take(x));` line or replace it with `z.extend(std::iter::repeat(0).take(1));`;\n  * replace the `for arr_ref in arr {` loop with `let arr_ref = &amp;arr[0];`;\n  * specify `RUSTFLAGS=\"-C opt-level=2\"` (the default optimization level for release builds is 3);\n  * specify `RUSTFLAGS=\"-C codegen-units=1\"` (the default is 16).\n\nI can't reproduce the problem:\n  * in the Rust playground, presumably because it uses `codegen-units = 1` in its Cargo.toml;\n  * on a Windows 10 machine (I have no idea why).\n\n`cargo-bisect-rustc` says the regression first happened in the `2019-12-12` nightly, specifically [in this commit](https://github.com/rust-lang/rust/commit/033662dfbca088937b9cdfd3d9584015b5e375b2), which is a rollup of multiple commits. Neither of them seems related to the problem I'm seeing.\n\nMy best guess so far is `-C opt-level=3` enables a problematic optimization pass in LLVM, which results in miscompilation. This is corroborated by the fact that MIR (`--emit mir`) and LLVM IR before optimizations (`--emit llvm-ir -C no-prepopulate-passes`) is the same for both `-C opt-level=2` and `-C opt-level=3`.\n\nIf this indeed is LLVM acting up, I guess I should follow [this guide](https://github.com/rust-lang/rustc-guide/blob/master/src/codegen/debugging.md). This seems doable but time-consuming, given that the problem only appears with multiple codegen units. So, is there a chance that I stumbled upon a known issue? I searched through the GitHub issues, but failed to find anything similar.", "author_fullname": "t2_32dim", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Weird memory unsafety problem in safe Rust", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f51fem", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 192, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 192, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581934386.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.rust", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Recently, I updated Rust to the latest stable version (1.41.0) on my macOS system and noticed that the tests of my &lt;a href=\"https://github.com/dfyz/osm-renderer\"&gt;pet project&lt;/a&gt; started crashing with &lt;code&gt;capacity overflow&lt;/code&gt; errors coming from &lt;code&gt;alloc::raw_vec::capacity_overflow()&lt;/code&gt;. My gut reaction was that I must have been bitten by UB in my unsafe code, but surprisingly this doesn&amp;#39;t seem to be the case here.&lt;/p&gt;\n\n&lt;p&gt;I managed to reproduce the problem with &lt;a href=\"https://github.com/dfyz/rust-segfault\"&gt;a tiny program&lt;/a&gt; without any unsafe code at all (and no external crates). When I run it with &lt;code&gt;cargo run --release&lt;/code&gt; on either Ubuntu 19.10 or macOS 10.15, I get something like this:&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;\n$ cargo run --release\n[...]\n0 0 3 18446744073709551615\n[1]    19196 segmentation fault  cargo run --release\n&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;Basically, a slice obtained from an array of small length somehow has length &lt;code&gt;2**64 - 1&lt;/code&gt;, which allows you to read from memory you don&amp;#39;t have access to without bounds checking. The expected output is something like this:\n&lt;code&gt;\n[...]\n0 0 3 0\nthread &amp;#39;main&amp;#39; panicked at &amp;#39;index out of bounds: the len is 0 but the index is 16777216&amp;#39;, src/main.rs:13:35\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;The problem goes away if I do any of the following:\n  * remove either of the two &lt;code&gt;do_test(...);&lt;/code&gt; calls in &lt;code&gt;main()&lt;/code&gt;;\n  * remove the &lt;code&gt;for _ in 0..1 {&lt;/code&gt; loop;\n  * replace the &lt;code&gt;for y in 0..x {&lt;/code&gt; loop with &lt;code&gt;for y in 0..1 {&lt;/code&gt;;\n  * remove the &lt;code&gt;z.extend(std::iter::repeat(0).take(x));&lt;/code&gt; line or replace it with &lt;code&gt;z.extend(std::iter::repeat(0).take(1));&lt;/code&gt;;\n  * replace the &lt;code&gt;for arr_ref in arr {&lt;/code&gt; loop with &lt;code&gt;let arr_ref = &amp;amp;arr[0];&lt;/code&gt;;\n  * specify &lt;code&gt;RUSTFLAGS=&amp;quot;-C opt-level=2&amp;quot;&lt;/code&gt; (the default optimization level for release builds is 3);\n  * specify &lt;code&gt;RUSTFLAGS=&amp;quot;-C codegen-units=1&amp;quot;&lt;/code&gt; (the default is 16).&lt;/p&gt;\n\n&lt;p&gt;I can&amp;#39;t reproduce the problem:\n  * in the Rust playground, presumably because it uses &lt;code&gt;codegen-units = 1&lt;/code&gt; in its Cargo.toml;\n  * on a Windows 10 machine (I have no idea why).&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;cargo-bisect-rustc&lt;/code&gt; says the regression first happened in the &lt;code&gt;2019-12-12&lt;/code&gt; nightly, specifically &lt;a href=\"https://github.com/rust-lang/rust/commit/033662dfbca088937b9cdfd3d9584015b5e375b2\"&gt;in this commit&lt;/a&gt;, which is a rollup of multiple commits. Neither of them seems related to the problem I&amp;#39;m seeing.&lt;/p&gt;\n\n&lt;p&gt;My best guess so far is &lt;code&gt;-C opt-level=3&lt;/code&gt; enables a problematic optimization pass in LLVM, which results in miscompilation. This is corroborated by the fact that MIR (&lt;code&gt;--emit mir&lt;/code&gt;) and LLVM IR before optimizations (&lt;code&gt;--emit llvm-ir -C no-prepopulate-passes&lt;/code&gt;) is the same for both &lt;code&gt;-C opt-level=2&lt;/code&gt; and &lt;code&gt;-C opt-level=3&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;If this indeed is LLVM acting up, I guess I should follow &lt;a href=\"https://github.com/rust-lang/rustc-guide/blob/master/src/codegen/debugging.md\"&gt;this guide&lt;/a&gt;. This seems doable but time-consuming, given that the problem only appears with multiple codegen units. So, is there a chance that I stumbled upon a known issue? I searched through the GitHub issues, but failed to find anything similar.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f51fem", "is_robot_indexable": true, "report_reasons": null, "author": "dfyz", "discussion_type": null, "num_comments": 10, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/f51fem/weird_memory_unsafety_problem_in_safe_rust/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/rust/comments/f51fem/weird_memory_unsafety_problem_in_safe_rust/", "subreddit_subscribers": 91048, "created_utc": 1581905586.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "\"Audit\" is probably a strong word. Also, take this with a grain of salt. I am by no means an expert with task scheduling. I am, however, interested in using an async `RwLock` in a production environment.\n\nWhat I was really interested in is answering the question: If I have a ton of readers acquiring and releasing the lock at all times, do the writers get a chance to acquire the lock, too?\n\nTo start with, I first looked at blocking implementations. If you check the docs for [`std::sync::RwLock`](https://doc.rust-lang.org/stable/std/sync/struct.RwLock.html), you'll clearly find that answering this question is entirely left up to the kernel implementation:\n\n&gt;The priority policy of the lock is dependent on the underlying operating system's implementation, and this type does not guarantee that any particular policy will be used.\n\nSo what *actually* happens on various platforms?\n\n* Windows: Readers and writers are fairly queued\n* Linux: Readers will starve the writers\n* macOS: Readers and writers are fairly queued\n\nBy \"fairly queued\" I mean that interleaved read/write locks will be queued in the order they attempt to acquire. With the bonus that all readers will acquire the lock in groups. This means that readers will have to wait behind any writers, and writers will have to wait behind any readers. But importantly, neither will be the dominant workload.\n\nI first wrote a small test (on macOS), and was surprised to see the behavior that *I wanted* out of an `RwLock`. But then I ran the same code on Linux and was dismayed that it prioritizes readers. The lock on Windows behaves roughly the same as on macOS.\n\n    #[cfg(test)]\n    mod test {\n        use std::sync::{Arc, RwLock};\n        use std::thread::{self, JoinHandle};\n        use std::time::Duration;\n    \n        fn create_reader(name: i32, lock: Arc&lt;RwLock&lt;u32&gt;&gt;) -&gt; JoinHandle&lt;()&gt; {\n            thread::spawn(move || {\n                println!(\"reader {}: acquiring read lock...\", name);\n                let guard = lock.read().unwrap();\n    \n                println!(\"reader {}: sleeping...\", name);\n                thread::sleep(Duration::from_secs(3));\n    \n                println!(\"reader {}: end: {}\", name, *guard);\n            })\n        }\n    \n        fn create_writer(name: i32, lock: Arc&lt;RwLock&lt;u32&gt;&gt;) -&gt; JoinHandle&lt;()&gt; {\n            thread::spawn(move || {\n                println!(\"writer {}: acquiring write lock...\", name);\n                let guard = lock.write().unwrap();\n    \n                println!(\"writer {}: sleeping...\", name);\n                thread::sleep(Duration::from_secs(3));\n    \n                println!(\"writer {}: end: {}\", name, *guard);\n            })\n        }\n    \n        #[test]\n        fn test_rwlock() {\n            let mut threads = Vec::new();\n            let shared_lock = Arc::new(RwLock::new(0));\n    \n            // Start two reader threads\n            let lock = Arc::clone(&amp;shared_lock);\n            threads.push(create_reader(1, lock));\n    \n            let lock = Arc::clone(&amp;shared_lock);\n            threads.push(create_reader(2, lock));\n    \n            // Wait for threads to sleep\n            thread::sleep(Duration::from_millis(100));\n    \n            // Start a writer thread\n            let lock = Arc::clone(&amp;shared_lock);\n            threads.push(create_writer(1, lock));\n    \n            // Wait for threads to sleep\n            thread::sleep(Duration::from_millis(100));\n    \n            // Start another two reader threads\n            let lock = Arc::clone(&amp;shared_lock);\n            threads.push(create_reader(3, lock));\n    \n            let lock = Arc::clone(&amp;shared_lock);\n            threads.push(create_reader(4, lock));\n    \n            // Wait for threads to sleep\n            thread::sleep(Duration::from_millis(100));\n    \n            // Start another writer thread\n            let lock = Arc::clone(&amp;shared_lock);\n            threads.push(create_writer(2, lock));\n    \n            // Wait for all threads to exit\n            for t in threads {\n                t.join().unwrap();\n            }\n        }\n    }\n\nExpected results from this test: the \"sleeping...\" message for readers and writers should be interleaved, with reader 1 &amp; 2 sleeping first, followed by writer 1. After this point is kind of a mixed bag, depending on the OS scheduler. Windows behavior is pretty wild! macOS seems to be very consistent. And Linux is the worst; it allows *all readers* to sleep right away, even though writer 1 wants to acquire before readers 3 &amp; 4.\n\nThe `RwLock` implementation in `parking_lot` does not have this inconsistency problem. In fact, it implements task-fair locking on all platforms: [https://docs.rs/parking\\_lot/0.10.0/parking\\_lot/type.RwLock.html](https://docs.rs/parking_lot/0.10.0/parking_lot/type.RwLock.html) I used this specific implementation as a benchmark for evaluating async `RwLock` implementations.\n\n## The contestants\n\n* [`futures_locks::RwLock`](https://docs.rs/futures-locks/0.5.0/futures_locks/struct.RwLock.html)\n* [`async_std::sync::RwLock`](https://docs.rs/async-std/1.5.0/async_std/sync/struct.RwLock.html)\n* [`futures_util::lock::RwLock` (currently open PR)](https://github.com/rust-lang/futures-rs/pull/2082)\n* [`tokio::sync::RwLock`](https://docs.rs/tokio/0.2.11/tokio/sync/struct.RwLock.html)\n\nedit: Tokio was added after the initial post.\n\nIn the case of `futures_locks::RwLock`, readers and writers are queued independently. There is no way for the scheduler to interleave lock acquisitions with this model. An async version of the test shows the expected readers-starve-writers behavior.\n\n`async_std::sync::RwLock` does not queue tasks explicitly but instead relies on a bi-state counter, which can either be \"locked for writing\" or \"locked by *n* readers\". The trouble with this implementation is that the bi-state counter can remain in the read state forever. The only requirement for acquiring the read lock is that the lock is not held by a writer. This allows readers to starve writers.\n\n`futures_util::lock::RwLock` has a very similar implementation that we see in `async-std`. Because this is an open (and active!) PR, the author is responsive to my report. And I suspect this implementation will address the starvation problem before it is reviewed.\n\nFinally, `tokio::sync::RwLock` uses a waiter queue where readers acquire 1 permit from a semaphore, and writers acquire all permits. The waiter queue interleaves read and write lock acquisitions in FIFO order, so it does provide a task-fair locking policy! Hooray!\n\n## The results\n\nIf you want to use `RwLock` in an async context, be aware that of the implementations I looked at, only Tokio will fairly queue the locks across tasks. A non-fair locking policy is fine in use cases where the lock is held infrequently. But with read-heavy workloads, the writer tasks will be starved.\n\nOn the flip-side, crate authors have been receptive! And I'm hopeful that raising awareness on these issues will help everyone.", "author_fullname": "t2_eocsn", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "I audited 3 different implementation of async RwLock.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f4zldz", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 203, "total_awards_received": 1, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 203, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1581906866.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {"gid_1": 1}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581925941.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.rust", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&amp;quot;Audit&amp;quot; is probably a strong word. Also, take this with a grain of salt. I am by no means an expert with task scheduling. I am, however, interested in using an async &lt;code&gt;RwLock&lt;/code&gt; in a production environment.&lt;/p&gt;\n\n&lt;p&gt;What I was really interested in is answering the question: If I have a ton of readers acquiring and releasing the lock at all times, do the writers get a chance to acquire the lock, too?&lt;/p&gt;\n\n&lt;p&gt;To start with, I first looked at blocking implementations. If you check the docs for &lt;a href=\"https://doc.rust-lang.org/stable/std/sync/struct.RwLock.html\"&gt;&lt;code&gt;std::sync::RwLock&lt;/code&gt;&lt;/a&gt;, you&amp;#39;ll clearly find that answering this question is entirely left up to the kernel implementation:&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;The priority policy of the lock is dependent on the underlying operating system&amp;#39;s implementation, and this type does not guarantee that any particular policy will be used.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So what &lt;em&gt;actually&lt;/em&gt; happens on various platforms?&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Windows: Readers and writers are fairly queued&lt;/li&gt;\n&lt;li&gt;Linux: Readers will starve the writers&lt;/li&gt;\n&lt;li&gt;macOS: Readers and writers are fairly queued&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;By &amp;quot;fairly queued&amp;quot; I mean that interleaved read/write locks will be queued in the order they attempt to acquire. With the bonus that all readers will acquire the lock in groups. This means that readers will have to wait behind any writers, and writers will have to wait behind any readers. But importantly, neither will be the dominant workload.&lt;/p&gt;\n\n&lt;p&gt;I first wrote a small test (on macOS), and was surprised to see the behavior that &lt;em&gt;I wanted&lt;/em&gt; out of an &lt;code&gt;RwLock&lt;/code&gt;. But then I ran the same code on Linux and was dismayed that it prioritizes readers. The lock on Windows behaves roughly the same as on macOS.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#[cfg(test)]\nmod test {\n    use std::sync::{Arc, RwLock};\n    use std::thread::{self, JoinHandle};\n    use std::time::Duration;\n\n    fn create_reader(name: i32, lock: Arc&amp;lt;RwLock&amp;lt;u32&amp;gt;&amp;gt;) -&amp;gt; JoinHandle&amp;lt;()&amp;gt; {\n        thread::spawn(move || {\n            println!(&amp;quot;reader {}: acquiring read lock...&amp;quot;, name);\n            let guard = lock.read().unwrap();\n\n            println!(&amp;quot;reader {}: sleeping...&amp;quot;, name);\n            thread::sleep(Duration::from_secs(3));\n\n            println!(&amp;quot;reader {}: end: {}&amp;quot;, name, *guard);\n        })\n    }\n\n    fn create_writer(name: i32, lock: Arc&amp;lt;RwLock&amp;lt;u32&amp;gt;&amp;gt;) -&amp;gt; JoinHandle&amp;lt;()&amp;gt; {\n        thread::spawn(move || {\n            println!(&amp;quot;writer {}: acquiring write lock...&amp;quot;, name);\n            let guard = lock.write().unwrap();\n\n            println!(&amp;quot;writer {}: sleeping...&amp;quot;, name);\n            thread::sleep(Duration::from_secs(3));\n\n            println!(&amp;quot;writer {}: end: {}&amp;quot;, name, *guard);\n        })\n    }\n\n    #[test]\n    fn test_rwlock() {\n        let mut threads = Vec::new();\n        let shared_lock = Arc::new(RwLock::new(0));\n\n        // Start two reader threads\n        let lock = Arc::clone(&amp;amp;shared_lock);\n        threads.push(create_reader(1, lock));\n\n        let lock = Arc::clone(&amp;amp;shared_lock);\n        threads.push(create_reader(2, lock));\n\n        // Wait for threads to sleep\n        thread::sleep(Duration::from_millis(100));\n\n        // Start a writer thread\n        let lock = Arc::clone(&amp;amp;shared_lock);\n        threads.push(create_writer(1, lock));\n\n        // Wait for threads to sleep\n        thread::sleep(Duration::from_millis(100));\n\n        // Start another two reader threads\n        let lock = Arc::clone(&amp;amp;shared_lock);\n        threads.push(create_reader(3, lock));\n\n        let lock = Arc::clone(&amp;amp;shared_lock);\n        threads.push(create_reader(4, lock));\n\n        // Wait for threads to sleep\n        thread::sleep(Duration::from_millis(100));\n\n        // Start another writer thread\n        let lock = Arc::clone(&amp;amp;shared_lock);\n        threads.push(create_writer(2, lock));\n\n        // Wait for all threads to exit\n        for t in threads {\n            t.join().unwrap();\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Expected results from this test: the &amp;quot;sleeping...&amp;quot; message for readers and writers should be interleaved, with reader 1 &amp;amp; 2 sleeping first, followed by writer 1. After this point is kind of a mixed bag, depending on the OS scheduler. Windows behavior is pretty wild! macOS seems to be very consistent. And Linux is the worst; it allows &lt;em&gt;all readers&lt;/em&gt; to sleep right away, even though writer 1 wants to acquire before readers 3 &amp;amp; 4.&lt;/p&gt;\n\n&lt;p&gt;The &lt;code&gt;RwLock&lt;/code&gt; implementation in &lt;code&gt;parking_lot&lt;/code&gt; does not have this inconsistency problem. In fact, it implements task-fair locking on all platforms: &lt;a href=\"https://docs.rs/parking_lot/0.10.0/parking_lot/type.RwLock.html\"&gt;https://docs.rs/parking_lot/0.10.0/parking_lot/type.RwLock.html&lt;/a&gt; I used this specific implementation as a benchmark for evaluating async &lt;code&gt;RwLock&lt;/code&gt; implementations.&lt;/p&gt;\n\n&lt;h2&gt;The contestants&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://docs.rs/futures-locks/0.5.0/futures_locks/struct.RwLock.html\"&gt;&lt;code&gt;futures_locks::RwLock&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://docs.rs/async-std/1.5.0/async_std/sync/struct.RwLock.html\"&gt;&lt;code&gt;async_std::sync::RwLock&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://github.com/rust-lang/futures-rs/pull/2082\"&gt;&lt;code&gt;futures_util::lock::RwLock&lt;/code&gt; (currently open PR)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://docs.rs/tokio/0.2.11/tokio/sync/struct.RwLock.html\"&gt;&lt;code&gt;tokio::sync::RwLock&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;edit: Tokio was added after the initial post.&lt;/p&gt;\n\n&lt;p&gt;In the case of &lt;code&gt;futures_locks::RwLock&lt;/code&gt;, readers and writers are queued independently. There is no way for the scheduler to interleave lock acquisitions with this model. An async version of the test shows the expected readers-starve-writers behavior.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;async_std::sync::RwLock&lt;/code&gt; does not queue tasks explicitly but instead relies on a bi-state counter, which can either be &amp;quot;locked for writing&amp;quot; or &amp;quot;locked by &lt;em&gt;n&lt;/em&gt; readers&amp;quot;. The trouble with this implementation is that the bi-state counter can remain in the read state forever. The only requirement for acquiring the read lock is that the lock is not held by a writer. This allows readers to starve writers.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;futures_util::lock::RwLock&lt;/code&gt; has a very similar implementation that we see in &lt;code&gt;async-std&lt;/code&gt;. Because this is an open (and active!) PR, the author is responsive to my report. And I suspect this implementation will address the starvation problem before it is reviewed.&lt;/p&gt;\n\n&lt;p&gt;Finally, &lt;code&gt;tokio::sync::RwLock&lt;/code&gt; uses a waiter queue where readers acquire 1 permit from a semaphore, and writers acquire all permits. The waiter queue interleaves read and write lock acquisitions in FIFO order, so it does provide a task-fair locking policy! Hooray!&lt;/p&gt;\n\n&lt;h2&gt;The results&lt;/h2&gt;\n\n&lt;p&gt;If you want to use &lt;code&gt;RwLock&lt;/code&gt; in an async context, be aware that of the implementations I looked at, only Tokio will fairly queue the locks across tasks. A non-fair locking policy is fine in use cases where the lock is held infrequently. But with read-heavy workloads, the writer tasks will be starved.&lt;/p&gt;\n\n&lt;p&gt;On the flip-side, crate authors have been receptive! And I&amp;#39;m hopeful that raising awareness on these issues will help everyone.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [{"count": 1, "is_enabled": true, "subreddit_id": null, "description": "Shows the Silver Award... and that's it.", "end_date": null, "coin_reward": 0, "icon_url": "https://www.redditstatic.com/gold/awards/icon/silver_512.png", "days_of_premium": 0, "coin_price": 100, "is_new": false, "icon_format": null, "award_sub_type": "GLOBAL", "resized_icons": [{"url": "https://www.redditstatic.com/gold/awards/icon/silver_16.png", "width": 16, "height": 16}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_32.png", "width": 32, "height": 32}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_48.png", "width": 48, "height": 48}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_64.png", "width": 64, "height": 64}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_128.png", "width": 128, "height": 128}], "icon_height": 512, "award_type": "global", "start_date": null, "days_of_drip_extension": 0, "id": "gid_1", "icon_width": 512, "subreddit_coin_reward": 0, "name": "Silver"}], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f4zldz", "is_robot_indexable": true, "report_reasons": null, "author": "kodewerx", "discussion_type": null, "num_comments": 19, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/f4zldz/i_audited_3_different_implementation_of_async/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/rust/comments/f4zldz/i_audited_3_different_implementation_of_async/", "subreddit_subscribers": 91048, "created_utc": 1581897141.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "", "author_fullname": "t2_5phxca7t", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "WASM Vector Graphics", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f574bg", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 9, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 9, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581965708.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "crates.io", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f574bg", "is_robot_indexable": true, "report_reasons": null, "author": "coastalwhite", "discussion_type": null, "num_comments": 4, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/f574bg/wasm_vector_graphics/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://crates.io/crates/wasm_svg_graphics", "subreddit_subscribers": 91048, "created_utc": 1581936908.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "", "author_fullname": "t2_kxmdq", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Introducing Prodash - a terminal dashboard for visualising the progress of concurrent tasks", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f4qyvn", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 285, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 285, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581890285.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "asciinema.org", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f4qyvn", "is_robot_indexable": true, "report_reasons": null, "author": "ByronBates", "discussion_type": null, "num_comments": 12, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/f4qyvn/introducing_prodash_a_terminal_dashboard_for/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://asciinema.org/a/301838", "subreddit_subscribers": 91048, "created_utc": 1581861485.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "Hi,\n\nI have a feeling that FromStr trait overlaps with the more generic From&lt;T&gt; trait. Basically I am a bit confused, when I should choose to implement FromStr and when From&lt;&amp;str&gt;. On top of that, if I choose to implement a From&lt;&amp;str&gt; trait, is there any reason why I should NOT implement the From&lt;String&gt; trait ? And if I implement a From&lt;&amp;str&gt; or a From&lt;String&gt;, is there a reason why I should NOT implement the Into&lt;&amp;str&gt; or Into&lt;String&gt; ?\n\nEdit: For instance the Rust uuid library implements only the FromStr and if you want to convert the UUID to String, you need to use the \\`to\\_string\\` method. Why they chose FromStr, instead of the more generic From&lt;&amp;str&gt; and why they don't provide an Into&lt;String&gt; as well instead of the fixed \\`to\\_string\\` method? There must be a reason, but I just don't see it.", "author_fullname": "t2_jtfvb", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "FromStr vs From&lt;&amp;str&gt; vs From&lt;String&gt; Which should I use and when ?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f55ur9", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 5, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 5, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1581929048.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581957556.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.rust", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hi,&lt;/p&gt;\n\n&lt;p&gt;I have a feeling that FromStr trait overlaps with the more generic From&amp;lt;T&amp;gt; trait. Basically I am a bit confused, when I should choose to implement FromStr and when From&amp;lt;&amp;amp;str&amp;gt;. On top of that, if I choose to implement a From&amp;lt;&amp;amp;str&amp;gt; trait, is there any reason why I should NOT implement the From&amp;lt;String&amp;gt; trait ? And if I implement a From&amp;lt;&amp;amp;str&amp;gt; or a From&amp;lt;String&amp;gt;, is there a reason why I should NOT implement the Into&amp;lt;&amp;amp;str&amp;gt; or Into&amp;lt;String&amp;gt; ?&lt;/p&gt;\n\n&lt;p&gt;Edit: For instance the Rust uuid library implements only the FromStr and if you want to convert the UUID to String, you need to use the `to_string` method. Why they chose FromStr, instead of the more generic From&amp;lt;&amp;amp;str&amp;gt; and why they don&amp;#39;t provide an Into&amp;lt;String&amp;gt; as well instead of the fixed `to_string` method? There must be a reason, but I just don&amp;#39;t see it.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f55ur9", "is_robot_indexable": true, "report_reasons": null, "author": "vasilakisfil", "discussion_type": null, "num_comments": 8, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/f55ur9/fromstr_vs_fromstr_vs_fromstring_which_should_i/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/rust/comments/f55ur9/fromstr_vs_fromstr_vs_fromstring_which_should_i/", "subreddit_subscribers": 91048, "created_utc": 1581928756.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "", "author_fullname": "t2_e9tj6", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "cow-utils: copy-on-write string utilities for Rust", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f4zc5z", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 15, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 15, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581924787.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f4zc5z", "is_robot_indexable": true, "report_reasons": null, "author": "RReverser", "discussion_type": null, "num_comments": 4, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/f4zc5z/cowutils_copyonwrite_string_utilities_for_rust/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/RReverser/cow-utils-rs", "subreddit_subscribers": 91048, "created_utc": 1581895987.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "Hello all.\n\nI am making a web server using warp, and I need to await a function call inside of the .map() call for a path.\n\nI have a minimal example of what I am trying to get working here:\n\n    #![feature(async_closure)]\n    \n    #[tokio::main]\n    async fn main() {\n        let path = warp::post()\n            .and(warp::path(\"path\"))\n            .and(warp::body::json())\n            .map(async move |instance: CustomStruct| {\n                let output: serde_json::Value = function_that_returns_value().await.unwrap();\n                \n                warp::reply::json(&amp;output)\n            });\n    \n        warp::serve(path).run(([127, 0, 0, 1], 3030)).await\n    }\n\nThis does not work because `^^^^^^^ the trait \\`warp::reply::Reply\\` is not implemented for \\`impl core::future::future::Future\\``\n\nThat is fine, because I really want to use the stable compiler.\n\nThe only thought I had to remedy the situation, would be to get the `output` variable stored somehow with a `collect()` call, and then make the `function_that_returns_value()` and `warp::reply::json()` calls outside of the map.\n\nAny help is appreciated.\n\nCheers :)", "author_fullname": "t2_13awwu", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Awaiting Closures With Warp", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f53rgu", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 4, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 4, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1581945562.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.rust", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hello all.&lt;/p&gt;\n\n&lt;p&gt;I am making a web server using warp, and I need to await a function call inside of the .map() call for a path.&lt;/p&gt;\n\n&lt;p&gt;I have a minimal example of what I am trying to get working here:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#![feature(async_closure)]\n\n#[tokio::main]\nasync fn main() {\n    let path = warp::post()\n        .and(warp::path(&amp;quot;path&amp;quot;))\n        .and(warp::body::json())\n        .map(async move |instance: CustomStruct| {\n            let output: serde_json::Value = function_that_returns_value().await.unwrap();\n\n            warp::reply::json(&amp;amp;output)\n        });\n\n    warp::serve(path).run(([127, 0, 0, 1], 3030)).await\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This does not work because &lt;code&gt;^^^^^^^ the trait \\&lt;/code&gt;warp::reply::Reply` is not implemented for `impl core::future::future::Future``&lt;/p&gt;\n\n&lt;p&gt;That is fine, because I really want to use the stable compiler.&lt;/p&gt;\n\n&lt;p&gt;The only thought I had to remedy the situation, would be to get the &lt;code&gt;output&lt;/code&gt; variable stored somehow with a &lt;code&gt;collect()&lt;/code&gt; call, and then make the &lt;code&gt;function_that_returns_value()&lt;/code&gt; and &lt;code&gt;warp::reply::json()&lt;/code&gt; calls outside of the map.&lt;/p&gt;\n\n&lt;p&gt;Any help is appreciated.&lt;/p&gt;\n\n&lt;p&gt;Cheers :)&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f53rgu", "is_robot_indexable": true, "report_reasons": null, "author": "TheDarkula", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/f53rgu/awaiting_closures_with_warp/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/rust/comments/f53rgu/awaiting_closures_with_warp/", "subreddit_subscribers": 91048, "created_utc": 1581916762.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "", "author_fullname": "t2_54u8qmg1", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Krabs: x86 bootloader that can boot vmlinux.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f51eao", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 9, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 9, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581934245.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f51eao", "is_robot_indexable": true, "report_reasons": null, "author": "ellbrid", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/f51eao/krabs_x86_bootloader_that_can_boot_vmlinux/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/ellbrid/krabs", "subreddit_subscribers": 91048, "created_utc": 1581905445.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "", "author_fullname": "t2_5l5kcoxw", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Trying out Actix by creating a simple TODO service. Part 3", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f50ut2", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 9, "total_awards_received": 0, "media_embed": {"content": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/3vMxuM7ezEk?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "width": 600, "scrolling": false, "height": 338}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": {"type": "youtube.com", "oembed": {"provider_url": "https://www.youtube.com/", "version": "1.0", "title": "The FASTEST web framework 2020! Simple TODO service with Actix [3/3]", "type": "video", "thumbnail_width": 480, "height": 338, "width": 600, "html": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/3vMxuM7ezEk?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "author_name": "genus-v", "provider_name": "YouTube", "thumbnail_url": "https://i.ytimg.com/vi/3vMxuM7ezEk/hqdefault.jpg", "thumbnail_height": 360, "author_url": "https://www.youtube.com/channel/UCSkHbGjrjJmuAbDPhIQ5T0A"}}, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {"content": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/3vMxuM7ezEk?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "width": 600, "scrolling": false, "media_domain_url": "https://www.redditmedia.com/mediaembed/f50ut2", "height": 338}, "link_flair_text": null, "can_mod_post": false, "score": 9, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581931805.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "youtu.be", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f50ut2", "is_robot_indexable": true, "report_reasons": null, "author": "nemesiscodex1", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/rust/comments/f50ut2/trying_out_actix_by_creating_a_simple_todo/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://youtu.be/3vMxuM7ezEk", "subreddit_subscribers": 91048, "created_utc": 1581903005.0, "num_crossposts": 0, "media": {"type": "youtube.com", "oembed": {"provider_url": "https://www.youtube.com/", "version": "1.0", "title": "The FASTEST web framework 2020! Simple TODO service with Actix [3/3]", "type": "video", "thumbnail_width": 480, "height": 338, "width": 600, "html": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/3vMxuM7ezEk?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "author_name": "genus-v", "provider_name": "YouTube", "thumbnail_url": "https://i.ytimg.com/vi/3vMxuM7ezEk/hqdefault.jpg", "thumbnail_height": 360, "author_url": "https://www.youtube.com/channel/UCSkHbGjrjJmuAbDPhIQ5T0A"}}, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "rust", "selftext": "", "author_fullname": "t2_dla2t", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "This Month in Rust GameDev #6 - January 2020", "link_flair_richtext": [], "subreddit_name_prefixed": "r/rust", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_f4r368", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": "", "subreddit_type": "public", "ups": 73, "total_awards_received": 1, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 73, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1581890889.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "rust-gamedev.github.io", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [{"count": 1, "is_enabled": true, "subreddit_id": null, "description": "When you come across a feel-good thing.", "end_date": null, "coin_reward": 0, "icon_url": "https://i.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png", "days_of_premium": 0, "coin_price": 150, "is_new": false, "icon_format": null, "award_sub_type": "GLOBAL", "resized_icons": [{"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=16&amp;height=16&amp;auto=webp&amp;s=92932f465d58e4c16b12b6eac4ca07d27e3d11c0", "width": 16, "height": 16}, {"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=32&amp;height=32&amp;auto=webp&amp;s=d11484a208d68a318bf9d4fcf371171a1cb6a7ef", "width": 32, "height": 32}, {"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=48&amp;height=48&amp;auto=webp&amp;s=febdf28b6f39f7da7eb1365325b85e0bb49a9f63", "width": 48, "height": 48}, {"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=64&amp;height=64&amp;auto=webp&amp;s=b4406a2d88bf86fa3dc8a45aacf7e0c7bdccc4fb", "width": 64, "height": 64}, {"url": "https://preview.redd.it/award_images/t5_22cerq/5izbv4fn0md41_Wholesome.png?width=128&amp;height=128&amp;auto=webp&amp;s=19555b13e3e196b62eeb9160d1ac1d1b372dcb0b", "width": 128, "height": 128}], "icon_height": 2048, "award_type": "global", "start_date": null, "days_of_drip_extension": 0, "id": "award_5f123e3d-4f48-42f4-9c11-e98b566d5897", "icon_width": 2048, "subreddit_coin_reward": 0, "name": "Wholesome"}], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": "zemeroth \u00b7 zoc", "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2s7lj", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "f4r368", "is_robot_indexable": true, "report_reasons": null, "author": "ozkriff", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": "dark", "permalink": "/r/rust/comments/f4r368/this_month_in_rust_gamedev_6_january_2020/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://rust-gamedev.github.io/posts/newsletter-006", "subreddit_subscribers": 91048, "created_utc": 1581862089.0, "num_crossposts": 1, "media": null, "is_video": false}}], "after": "t3_f4r368", "before": null}}