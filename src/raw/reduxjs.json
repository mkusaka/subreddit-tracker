{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "", "author_fullname": "t2_1t7y74gw", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How Redux Toolkit can reduce your setup of Redux in your next React app", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_hbc6ca", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1592505329.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "medium.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "hbc6ca", "is_robot_indexable": true, "report_reasons": null, "author": "jsloverr", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/hbc6ca/how_redux_toolkit_can_reduce_your_setup_of_redux/", "parent_whitelist_status": null, "stickied": false, "url": "https://medium.com//how-redux-toolkit-can-reduce-your-setup-of-redux-in-your-react-app-d87baab59268?source=friends_link&amp;sk=626b48e7ab94dff289177c14be3b7383", "subreddit_subscribers": 3501, "created_utc": 1592476529.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "I am trying to teach myself Redux and I am having trouble with an assignment.  I'm trying to figure out how to let a child use componentDidMount without the whole component tree, it belongs to, re-rendering.\nHere's are some pics to explain my problem:\nWhen I click on the [todo item](https://imgur.com/5SJ3QFS) I expect it to open up and reveal the details of the todo item including the [steps](https://imgur.com/bhSL24w).  This does happen BUT I only see the steps flash for a second and I'm back to seeing only the [todo list item](https://imgur.com/5SJ3QFS).  The todo items(parents) are fetched just like the steps(children).\n\nPlease let me know if you need more information!!!\n\nHere is my code...\n\n\nChild component:\n\n\n    class TodoViewDetail extends React.Component {\n        constructor(props) {\n            super(props);\n            this.props = props;\n        }\n        componentDidMount() {\n            this.props.fetchSteps();\n        }\n        render() {\n            const { body, id } = this.props.todo;\n            return (\n                &lt;div className=\"todo-details\"&gt;\n                    &lt;p&gt;{body}&lt;/p&gt;\n                    &lt;StepListContainer todoId={id} /&gt;\n                    &lt;button onClick={this.props.deleteTodo}&gt;Delete&lt;/button&gt;\n                &lt;/div&gt;\n            );\n        }\n    }\n\nfetchSteps action:\n\n\n    export const receiveSteps = (steps) =&gt;  ({\n        type: RECEIVE_STEPS,\n        steps: steps\n    });\n    export function fetchSteps(todoId) {\n        return (dispatch, state) =&gt; {\n            return stepAPIUtil.fetchSteps(todoId).then(\n                    successfulStepsResponse =&gt; dispatch(receiveSteps(successfulStepsResponse)\n                )\n            )\n        }\n    }\n\najax request:\n\n\n    export function fetchSteps(todoId) {\n        return $.ajax({\n            type: \"GET\",\n            url: `/api/todos/${todoId}/steps`,\n        });\n    }", "author_fullname": "t2_fwz46", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Parent componentDidMount and child componentDidMount.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_hbbc6n", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1592501033.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I am trying to teach myself Redux and I am having trouble with an assignment.  I&amp;#39;m trying to figure out how to let a child use componentDidMount without the whole component tree, it belongs to, re-rendering.\nHere&amp;#39;s are some pics to explain my problem:\nWhen I click on the &lt;a href=\"https://imgur.com/5SJ3QFS\"&gt;todo item&lt;/a&gt; I expect it to open up and reveal the details of the todo item including the &lt;a href=\"https://imgur.com/bhSL24w\"&gt;steps&lt;/a&gt;.  This does happen BUT I only see the steps flash for a second and I&amp;#39;m back to seeing only the &lt;a href=\"https://imgur.com/5SJ3QFS\"&gt;todo list item&lt;/a&gt;.  The todo items(parents) are fetched just like the steps(children).&lt;/p&gt;\n\n&lt;p&gt;Please let me know if you need more information!!!&lt;/p&gt;\n\n&lt;p&gt;Here is my code...&lt;/p&gt;\n\n&lt;p&gt;Child component:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;class TodoViewDetail extends React.Component {\n    constructor(props) {\n        super(props);\n        this.props = props;\n    }\n    componentDidMount() {\n        this.props.fetchSteps();\n    }\n    render() {\n        const { body, id } = this.props.todo;\n        return (\n            &amp;lt;div className=&amp;quot;todo-details&amp;quot;&amp;gt;\n                &amp;lt;p&amp;gt;{body}&amp;lt;/p&amp;gt;\n                &amp;lt;StepListContainer todoId={id} /&amp;gt;\n                &amp;lt;button onClick={this.props.deleteTodo}&amp;gt;Delete&amp;lt;/button&amp;gt;\n            &amp;lt;/div&amp;gt;\n        );\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;fetchSteps action:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;export const receiveSteps = (steps) =&amp;gt;  ({\n    type: RECEIVE_STEPS,\n    steps: steps\n});\nexport function fetchSteps(todoId) {\n    return (dispatch, state) =&amp;gt; {\n        return stepAPIUtil.fetchSteps(todoId).then(\n                successfulStepsResponse =&amp;gt; dispatch(receiveSteps(successfulStepsResponse)\n            )\n        )\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;ajax request:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;export function fetchSteps(todoId) {\n    return $.ajax({\n        type: &amp;quot;GET&amp;quot;,\n        url: `/api/todos/${todoId}/steps`,\n    });\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "hbbc6n", "is_robot_indexable": true, "report_reasons": null, "author": "ben53125", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/hbbc6n/parent_componentdidmount_and_child/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/hbbc6n/parent_componentdidmount_and_child/", "subreddit_subscribers": 3501, "created_utc": 1592472233.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "I'm working on an application that uses legacy code from its version 1, where Redux middlewares were used to handle some actions. This middlewear would do something like `import Logger from './logger';` and `Logger.emit('some log');`.\n\nIn the new version of this application, `Logger` (among other objects, functions, and values) are no longer static modules. They are dependency injected:\n\n    &lt;Application logger={Logger} /&gt;\n\nThe middleware can no longer import these variables this way, because they don't exist as simple modules. They exist within the React lifecycle as props.\n\nWhat is the best way to handle this?\n\nMy team has two ideas, but I wanted to make sure we aren't overlooking anything obvious or potential problems.\n\n1) Pass these values as a part of the action. Instead of `{ type: 'do', value: true }` it would now need to be `{ type: 'do', value: true, logger: Logger }`.\n\n2) Create the store inside a `useMemo` on `Application` mount.\n\nWhat is the optimal solution for injecting dependencies into actions?", "author_fullname": "t2_1r41bikz", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "I need help refactoring a middleware to use dependency injection.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_hb8u24", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1592467043.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1592488785.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m working on an application that uses legacy code from its version 1, where Redux middlewares were used to handle some actions. This middlewear would do something like &lt;code&gt;import Logger from &amp;#39;./logger&amp;#39;;&lt;/code&gt; and &lt;code&gt;Logger.emit(&amp;#39;some log&amp;#39;);&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;In the new version of this application, &lt;code&gt;Logger&lt;/code&gt; (among other objects, functions, and values) are no longer static modules. They are dependency injected:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;&amp;lt;Application logger={Logger} /&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The middleware can no longer import these variables this way, because they don&amp;#39;t exist as simple modules. They exist within the React lifecycle as props.&lt;/p&gt;\n\n&lt;p&gt;What is the best way to handle this?&lt;/p&gt;\n\n&lt;p&gt;My team has two ideas, but I wanted to make sure we aren&amp;#39;t overlooking anything obvious or potential problems.&lt;/p&gt;\n\n&lt;p&gt;1) Pass these values as a part of the action. Instead of &lt;code&gt;{ type: &amp;#39;do&amp;#39;, value: true }&lt;/code&gt; it would now need to be &lt;code&gt;{ type: &amp;#39;do&amp;#39;, value: true, logger: Logger }&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;2) Create the store inside a &lt;code&gt;useMemo&lt;/code&gt; on &lt;code&gt;Application&lt;/code&gt; mount.&lt;/p&gt;\n\n&lt;p&gt;What is the optimal solution for injecting dependencies into actions?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "hb8u24", "is_robot_indexable": true, "report_reasons": null, "author": "Charles_Stover", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/hb8u24/i_need_help_refactoring_a_middleware_to_use/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/hb8u24/i_need_help_refactoring_a_middleware_to_use/", "subreddit_subscribers": 3501, "created_utc": 1592459985.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "", "author_fullname": "t2_cdjg8", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Modern React/React Router Auth Best Practices with Redux Saga Firebase + React Hooks?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_hauvve", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 4, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 4, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "crosspost_parent_list": [{"approved_at_utc": null, "subreddit": "reactjs", "selftext": "Does anyone know of modern React/React Router Auth best practices that I can implement into my project with Redux Saga Firebase? A template for guidance works too.\n\nI know a pretty idea how everything should work, just wondering if I\u2019m missing something, could improve a process, or if there\u2019s a really good template I could use for guidance. Here\u2019s my current stack:\n\n&amp;#x200B;\n\n**My Stack:**\n\n* React\n* React Router\n* Redux\n* React Redux\n* Redux Saga\n* Redux Saga Firebase\n* Firebase\n* Redux Persist\n\n**React:**\n\n* On App.js, use OnAuthStateChanged() to redirect the user somehow.\n\n**React Router (Protect using Redirect):**\n\n* Public Routes (\u201c/\u201c, \u201c/login\u201d, \u201csignup\u201d)\n* Private Routes (\u201c/dashboard\u201d, \u201c/settings\u201d)\n\n**Redux:**\n\n* authReducer with state 4 state properties: loading, error, user, and uid. User is the user object from Firebase given when logged out. uid is the user\u2019s Firebase UID.\n\n**Redux Saga:**\n\n* I see see some people using an event channel to sync users data. Is that necessary and what benefit does that add?\n\n**ReduxSagaFirebase:**\n\n* rsf.auth.signInWithEmailAndPassword\n* rsf.auth.logout\n\n&amp;#x200B;\n\n**Additional questions:**\n\n* Do I need to worry about sessions at all?\n* I will be using Firebase for auth, cloud functions, and cloud firestore. Has anyone had experience using this with a real world app with thousands of users? How\u2019s the performance, reliability, and cold starts?\n* Anything else I should take into consideration?", "author_fullname": "t2_cdjg8", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Modern React/React Router Auth Best Practices with Redux Saga Firebase + React Hooks?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reactjs", "hidden": false, "pwls": 6, "link_flair_css_class": "link-flair-needs-help", "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_hauut4", "quarantine": false, "link_flair_text_color": "light", "upvote_ratio": 0.67, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Needs Help", "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1592413800.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1592440908.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reactjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Does anyone know of modern React/React Router Auth best practices that I can implement into my project with Redux Saga Firebase? A template for guidance works too.&lt;/p&gt;\n\n&lt;p&gt;I know a pretty idea how everything should work, just wondering if I\u2019m missing something, could improve a process, or if there\u2019s a really good template I could use for guidance. Here\u2019s my current stack:&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;My Stack:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;React&lt;/li&gt;\n&lt;li&gt;React Router&lt;/li&gt;\n&lt;li&gt;Redux&lt;/li&gt;\n&lt;li&gt;React Redux&lt;/li&gt;\n&lt;li&gt;Redux Saga&lt;/li&gt;\n&lt;li&gt;Redux Saga Firebase&lt;/li&gt;\n&lt;li&gt;Firebase&lt;/li&gt;\n&lt;li&gt;Redux Persist&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;strong&gt;React:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;On App.js, use OnAuthStateChanged() to redirect the user somehow.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;strong&gt;React Router (Protect using Redirect):&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Public Routes (\u201c/\u201c, \u201c/login\u201d, \u201csignup\u201d)&lt;/li&gt;\n&lt;li&gt;Private Routes (\u201c/dashboard\u201d, \u201c/settings\u201d)&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;strong&gt;Redux:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;authReducer with state 4 state properties: loading, error, user, and uid. User is the user object from Firebase given when logged out. uid is the user\u2019s Firebase UID.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;strong&gt;Redux Saga:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;I see see some people using an event channel to sync users data. Is that necessary and what benefit does that add?&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;strong&gt;ReduxSagaFirebase:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;rsf.auth.signInWithEmailAndPassword&lt;/li&gt;\n&lt;li&gt;rsf.auth.logout&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Additional questions:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Do I need to worry about sessions at all?&lt;/li&gt;\n&lt;li&gt;I will be using Firebase for auth, cloud functions, and cloud firestore. Has anyone had experience using this with a real world app with thousands of users? How\u2019s the performance, reliability, and cold starts?&lt;/li&gt;\n&lt;li&gt;Anything else I should take into consideration?&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": "confidence", "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "c808a3ce-8520-11e8-b3d4-0e03aa55af0c", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2zldd", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "#b8001f", "id": "hauut4", "is_robot_indexable": true, "report_reasons": null, "author": "Jeffylew77", "discussion_type": null, "num_comments": 4, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reactjs/comments/hauut4/modern_reactreact_router_auth_best_practices_with/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/reactjs/comments/hauut4/modern_reactreact_router_auth_best_practices_with/", "subreddit_subscribers": 194725, "created_utc": 1592412108.0, "num_crossposts": 2, "media": null, "is_video": false}], "created": 1592440989.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reactjs", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "hauvve", "is_robot_indexable": true, "report_reasons": null, "author": "Jeffylew77", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "crosspost_parent": "t3_hauut4", "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/hauvve/modern_reactreact_router_auth_best_practices_with/", "parent_whitelist_status": null, "stickied": false, "url": "/r/reactjs/comments/hauut4/modern_reactreact_router_auth_best_practices_with/", "subreddit_subscribers": 3501, "created_utc": 1592412189.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "", "author_fullname": "t2_10yfl9", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Create simple POS with React, Node and MongoDB #6: Redux Integration", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_ha0wdc", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 6, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 6, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1592329766.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "blog.soshace.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "ha0wdc", "is_robot_indexable": true, "report_reasons": null, "author": "branikita", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/ha0wdc/create_simple_pos_with_react_node_and_mongodb_6/", "parent_whitelist_status": null, "stickied": false, "url": "https://blog.soshace.com/create-simple-pos-with-react-node-and-mongodb-6-redux-integration/", "subreddit_subscribers": 3501, "created_utc": 1592300966.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "I'm struggling to find the right words to convey what I'm looking for in my research, so I thought I would ask the reddit community. I am looking for best practices to create records in different tables at once.\n\nAn example would be, user registration. Say you need to create 6 records for that user when they sign up, which need to connect. By connect I mean in the sense that if a user and team were created on user registration, the `userID` would need to be included in the team's members array. So the records need to fire in order so the relationship is properly recorded. So user would need to be created first, then the team record so I can add the `userID` to the team's members. Also note that the user record would need to be updated later on (after the team's record is created) with the `teamID` under the user's teams.\n\nSo as you can see it feels a bit all over the place. Currently I have multiple API calls being fired on user submit. While I have this working using `redux`, `firebase` and `react` \u2014\u00a0I foresee a lot of potential errors happening and feel as if I am not doing this in the most efficient way. I want to do this correctly and happy to do the research, I'm just not exactly sure what I am looking for. I was hoping for some guides, information, search terms, etc \u2014 basically anything to help me understand this concept more throughly if that makes sense.", "author_fullname": "t2_53ahvmsq", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Advice for a frontend dev \u2014 firing multiple api calls at once", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_h9u0mp", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1592301071.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m struggling to find the right words to convey what I&amp;#39;m looking for in my research, so I thought I would ask the reddit community. I am looking for best practices to create records in different tables at once.&lt;/p&gt;\n\n&lt;p&gt;An example would be, user registration. Say you need to create 6 records for that user when they sign up, which need to connect. By connect I mean in the sense that if a user and team were created on user registration, the &lt;code&gt;userID&lt;/code&gt; would need to be included in the team&amp;#39;s members array. So the records need to fire in order so the relationship is properly recorded. So user would need to be created first, then the team record so I can add the &lt;code&gt;userID&lt;/code&gt; to the team&amp;#39;s members. Also note that the user record would need to be updated later on (after the team&amp;#39;s record is created) with the &lt;code&gt;teamID&lt;/code&gt; under the user&amp;#39;s teams.&lt;/p&gt;\n\n&lt;p&gt;So as you can see it feels a bit all over the place. Currently I have multiple API calls being fired on user submit. While I have this working using &lt;code&gt;redux&lt;/code&gt;, &lt;code&gt;firebase&lt;/code&gt; and &lt;code&gt;react&lt;/code&gt; \u2014\u00a0I foresee a lot of potential errors happening and feel as if I am not doing this in the most efficient way. I want to do this correctly and happy to do the research, I&amp;#39;m just not exactly sure what I am looking for. I was hoping for some guides, information, search terms, etc \u2014 basically anything to help me understand this concept more throughly if that makes sense.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "h9u0mp", "is_robot_indexable": true, "report_reasons": null, "author": "LurelinVillage", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/h9u0mp/advice_for_a_frontend_dev_firing_multiple_api/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/h9u0mp/advice_for_a_frontend_dev_firing_multiple_api/", "subreddit_subscribers": 3501, "created_utc": 1592272271.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "I'm using Redux with my React Hooks simple counter project. It worked without any bugs or problems when the only global state was a simple integer with +/- buttons to. Then I added a second global state for light/dark themes and found that the add/subtract buttons affect the light/dark variable! I think I'm misusing the useDispatch() hook or combining reducers incorrectly. I've tried moving things into different containers and fiddled a lot with the syntax. In the code below I have omitted `import` and `export` statements for brevity:  \n  \nApp.js:  \n  \n    const App = () =&gt; {\n        return (\n          &lt;div className=\"App\"&gt;\n            &lt;ThemeBar /&gt;\n            &lt;Counter /&gt;\n          &lt;/div&gt;\n        );\n    }\n  \nThemeBar.js:  \n  \n    const ThemeBar = () =&gt; {\n        const theme = useSelector(state =&gt; state.theme.themeIsLight)\n        const dispatch = useDispatch();\n    \n        return (\n            &lt;div&gt;\n                &lt;ThemeOutput value={theme} /&gt;\n                &lt;ThemeButton label=\"Toggle Theme\"\n                             clicked={()=&gt;dispatch({type: 'TOGGLE_THEME'})}/&gt;\n            &lt;/div&gt;\n        );\n    };\n  \nCounter.js:  \n  \n    const Counter = () =&gt; {\n        const count = useSelector(state =&gt; state.number.counter);\n        const dispatch = useDispatch();\n    \n            return (\n                &lt;div&gt;\n                    &lt;CounterOutput value={count} /&gt;\n                    &lt;CounterControl label=\"Increment\"\n                                    clicked={()=&gt;dispatch({ type: 'INCREMENT'})} /&gt;\n                    &lt;CounterControl label=\"Decrement\"\n                                    clicked={()=&gt;dispatch({ type: 'DECREMENT'})} /&gt;\n                    &lt;CounterControl label=\"Add 5\"\n                                    clicked={()=&gt;dispatch({ type: 'ADD', value: 5})} /&gt;\n                    &lt;CounterControl label=\"Subtract 5\"\n                                    clicked={()=&gt;dispatch({ type: 'SUBTRACT', value: 5})} /&gt;\n                &lt;/div&gt;\n            );\n    };  \n  \nthemeReducer.js:  \n  \n    const themeReducer = (state = initialState, action) =&gt; {\n        console.log('Theme: ' + state.themeIsLight);\n        if (action.type === 'TOGGLE_THEME')\n            return { themeIsLight: !state.themeIsLight};\n        return state;\n    };\n  \nglobalNumberReducer.js:  \n  \n    const globalNumberReducer = (state = initialState, action) =&gt; {\n        switch (action.type) {\n            case 'INCREMENT': return {counter: state.counter + 1};\n            case 'DECREMENT': return {counter: state.counter - 1};\n            case 'ADD': return {counter: state.counter + action.value};\n            case 'SUBTRACT': return {counter: state.counter - action.value};\n            default: return state;\n        }\n    };\n  \nindex.js:  \n  \n    const rootReducer = combineReducers({\n        number: globalNumberReducer,\n        theme:themeReducer\n    });\n    \n    const store = createStore(rootReducer);\n    console.log(store.getState());\n    \n    \n    ReactDOM.render(\n        &lt;Provider store={store}&gt;&lt;App /&gt;&lt;/Provider&gt;, document.getElementById('root')\n    );\n    registerServiceWorker();", "author_fullname": "t2_fxfaw", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Dispatching for one type of global state affects the other. Why?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_h7t6sq", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.67, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1592024882.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m using Redux with my React Hooks simple counter project. It worked without any bugs or problems when the only global state was a simple integer with +/- buttons to. Then I added a second global state for light/dark themes and found that the add/subtract buttons affect the light/dark variable! I think I&amp;#39;m misusing the useDispatch() hook or combining reducers incorrectly. I&amp;#39;ve tried moving things into different containers and fiddled a lot with the syntax. In the code below I have omitted &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; statements for brevity:  &lt;/p&gt;\n\n&lt;p&gt;App.js:  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const App = () =&amp;gt; {\n    return (\n      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;\n        &amp;lt;ThemeBar /&amp;gt;\n        &amp;lt;Counter /&amp;gt;\n      &amp;lt;/div&amp;gt;\n    );\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;ThemeBar.js:  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const ThemeBar = () =&amp;gt; {\n    const theme = useSelector(state =&amp;gt; state.theme.themeIsLight)\n    const dispatch = useDispatch();\n\n    return (\n        &amp;lt;div&amp;gt;\n            &amp;lt;ThemeOutput value={theme} /&amp;gt;\n            &amp;lt;ThemeButton label=&amp;quot;Toggle Theme&amp;quot;\n                         clicked={()=&amp;gt;dispatch({type: &amp;#39;TOGGLE_THEME&amp;#39;})}/&amp;gt;\n        &amp;lt;/div&amp;gt;\n    );\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Counter.js:  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const Counter = () =&amp;gt; {\n    const count = useSelector(state =&amp;gt; state.number.counter);\n    const dispatch = useDispatch();\n\n        return (\n            &amp;lt;div&amp;gt;\n                &amp;lt;CounterOutput value={count} /&amp;gt;\n                &amp;lt;CounterControl label=&amp;quot;Increment&amp;quot;\n                                clicked={()=&amp;gt;dispatch({ type: &amp;#39;INCREMENT&amp;#39;})} /&amp;gt;\n                &amp;lt;CounterControl label=&amp;quot;Decrement&amp;quot;\n                                clicked={()=&amp;gt;dispatch({ type: &amp;#39;DECREMENT&amp;#39;})} /&amp;gt;\n                &amp;lt;CounterControl label=&amp;quot;Add 5&amp;quot;\n                                clicked={()=&amp;gt;dispatch({ type: &amp;#39;ADD&amp;#39;, value: 5})} /&amp;gt;\n                &amp;lt;CounterControl label=&amp;quot;Subtract 5&amp;quot;\n                                clicked={()=&amp;gt;dispatch({ type: &amp;#39;SUBTRACT&amp;#39;, value: 5})} /&amp;gt;\n            &amp;lt;/div&amp;gt;\n        );\n};  \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;themeReducer.js:  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const themeReducer = (state = initialState, action) =&amp;gt; {\n    console.log(&amp;#39;Theme: &amp;#39; + state.themeIsLight);\n    if (action.type === &amp;#39;TOGGLE_THEME&amp;#39;)\n        return { themeIsLight: !state.themeIsLight};\n    return state;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;globalNumberReducer.js:  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const globalNumberReducer = (state = initialState, action) =&amp;gt; {\n    switch (action.type) {\n        case &amp;#39;INCREMENT&amp;#39;: return {counter: state.counter + 1};\n        case &amp;#39;DECREMENT&amp;#39;: return {counter: state.counter - 1};\n        case &amp;#39;ADD&amp;#39;: return {counter: state.counter + action.value};\n        case &amp;#39;SUBTRACT&amp;#39;: return {counter: state.counter - action.value};\n        default: return state;\n    }\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;index.js:  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const rootReducer = combineReducers({\n    number: globalNumberReducer,\n    theme:themeReducer\n});\n\nconst store = createStore(rootReducer);\nconsole.log(store.getState());\n\n\nReactDOM.render(\n    &amp;lt;Provider store={store}&amp;gt;&amp;lt;App /&amp;gt;&amp;lt;/Provider&amp;gt;, document.getElementById(&amp;#39;root&amp;#39;)\n);\nregisterServiceWorker();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "h7t6sq", "is_robot_indexable": true, "report_reasons": null, "author": "chunyukuo", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/h7t6sq/dispatching_for_one_type_of_global_state_affects/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/h7t6sq/dispatching_for_one_type_of_global_state_affects/", "subreddit_subscribers": 3501, "created_utc": 1591996082.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "**The problem:**\n\nI have a list of buttons that when each is clicked I dispatch some actions to fetch various bits of data from a server and populate the Redux store. Lets say the store looks like the following:\n\n`{ customerDetails: { name: \"John\", age: 25 }, tasks: [] }`\n\nand the actions are split into 2, the first fetches customer details and the other fetches tasks.\n\nIf the user clicks the first button to see Customer1 and then clicks to see Customer2 before all the async actions for Customer1 have come back then the Redux store can get into a state where it'll be populated with Customer1 data if the async actions from the first button come back \\_after\\_ the async actions from the second button click (Customer2).\n\n&amp;#x200B;\n\nI can think of a few solutions to this, but all seem slightly complex..\n\n1. Store a `latestButtonClickedID` in the store and when all the async actions come back they can then check whether they were dispatched with the same ID as the one that is in the store now. If the IDs match then we update the store, if the IDs do not match then we do nothing with the API response (i.e. do not update the store). This means I would have to pass in `latestButtonClickedID` into a lot of my actions that fetch data, not really ideal.\n2. Change the store to look like  `{ buttonID1: { customerDetails: { ... }, tasks [] }, buttonID2: { customerDetails: { ... }, tasks [] } }` I'd then need to pass the correct data into the presentational component by using a selector that selects the data for the correct `buttonID`, where the `buttonID` is set synchronously on button click. This would also involve passing `buttonID`'s around everywhere.\n3. Some sort of promise cancellation? Can anyone point me in the right direction for this if possible?\n4. Disable any other button from being clicked until all promises of fetching the data have resolved. I can't really do this as the buttons are from a 3rd party library.\n5. redux-saga `takeLatest`... I'd rather not as the team have found this to be fairly complex for our needs.\n\n&amp;#x200B;\n\nAny other suggestions? Thanks.", "author_fullname": "t2_2rp7wnuv", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Asynchronous actions, Redux store and race conditions.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_h7j059", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.78, "author_flair_background_color": null, "subreddit_type": "public", "ups": 5, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 5, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591990179.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;strong&gt;The problem:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;I have a list of buttons that when each is clicked I dispatch some actions to fetch various bits of data from a server and populate the Redux store. Lets say the store looks like the following:&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;{ customerDetails: { name: &amp;quot;John&amp;quot;, age: 25 }, tasks: [] }&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;and the actions are split into 2, the first fetches customer details and the other fetches tasks.&lt;/p&gt;\n\n&lt;p&gt;If the user clicks the first button to see Customer1 and then clicks to see Customer2 before all the async actions for Customer1 have come back then the Redux store can get into a state where it&amp;#39;ll be populated with Customer1 data if the async actions from the first button come back _after_ the async actions from the second button click (Customer2).&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;I can think of a few solutions to this, but all seem slightly complex..&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Store a &lt;code&gt;latestButtonClickedID&lt;/code&gt; in the store and when all the async actions come back they can then check whether they were dispatched with the same ID as the one that is in the store now. If the IDs match then we update the store, if the IDs do not match then we do nothing with the API response (i.e. do not update the store). This means I would have to pass in &lt;code&gt;latestButtonClickedID&lt;/code&gt; into a lot of my actions that fetch data, not really ideal.&lt;/li&gt;\n&lt;li&gt;Change the store to look like  &lt;code&gt;{ buttonID1: { customerDetails: { ... }, tasks [] }, buttonID2: { customerDetails: { ... }, tasks [] } }&lt;/code&gt; I&amp;#39;d then need to pass the correct data into the presentational component by using a selector that selects the data for the correct &lt;code&gt;buttonID&lt;/code&gt;, where the &lt;code&gt;buttonID&lt;/code&gt; is set synchronously on button click. This would also involve passing &lt;code&gt;buttonID&lt;/code&gt;&amp;#39;s around everywhere.&lt;/li&gt;\n&lt;li&gt;Some sort of promise cancellation? Can anyone point me in the right direction for this if possible?&lt;/li&gt;\n&lt;li&gt;Disable any other button from being clicked until all promises of fetching the data have resolved. I can&amp;#39;t really do this as the buttons are from a 3rd party library.&lt;/li&gt;\n&lt;li&gt;redux-saga &lt;code&gt;takeLatest&lt;/code&gt;... I&amp;#39;d rather not as the team have found this to be fairly complex for our needs.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;Any other suggestions? Thanks.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "h7j059", "is_robot_indexable": true, "report_reasons": null, "author": "jet810", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/h7j059/asynchronous_actions_redux_store_and_race/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/h7j059/asynchronous_actions_redux_store_and_race/", "subreddit_subscribers": 3501, "created_utc": 1591961379.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "At my work we use something along the lines of every real \"action\" having a pending, success, and fail action. Out of curiosity I checked some online resources and I'll see more of a SET vs GET sort of thing for actions. Just wondering if there is a best practice for this sort of thing for my own projects?\n\nThanks", "author_fullname": "t2_15a1fn", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Best practice for actions?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_h13l2y", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591924761.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;At my work we use something along the lines of every real &amp;quot;action&amp;quot; having a pending, success, and fail action. Out of curiosity I checked some online resources and I&amp;#39;ll see more of a SET vs GET sort of thing for actions. Just wondering if there is a best practice for this sort of thing for my own projects?&lt;/p&gt;\n\n&lt;p&gt;Thanks&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "h13l2y", "is_robot_indexable": true, "report_reasons": null, "author": "SweetestTeaCups", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/h13l2y/best_practice_for_actions/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/h13l2y/best_practice_for_actions/", "subreddit_subscribers": 3501, "created_utc": 1591895961.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reduxjs", "selftext": "Reference from [Official docs](https://redux.js.org/recipes/writing-tests#action-creators):\n\nIn Redux, action creators are functions which return plain objects. When testing action creators, we want to test whether the correct action creator was called and also whether the right action was returned.\n\nBut my question is WHY?\n\nActionCreator is a function that returns an object. It's a pure function. All it does is returning an object with whatever data is passed while calling. Is there any risk of not testing this function?\n\n    export function addTodo(text) {\n      return {\n        type: types.ADD_TODO,\n        text\n      }\n    }\n\nIts more like creating two objects and doing deep comparison.\n\n&gt;expect(actions.addTodo(text)).toEqual(expectedAction)\n\nThe only scenario I can think of where unit tests can be useful is when someone accidentally changes this function to return an object with type: `types.EDIT_TODO`\n\nBut  is this the only case? Are there any other benefits  of writing tests cases for functions that does the obvious?  \n\n\nEDIT: I do use `redux-saga` for managing async actions (fetching data through API calls etc) and I do write unit tests for sagas. I'm only concerned  about writing unit tests for action creators!", "author_fullname": "t2_1yqbwig6", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Why should I write unit test for actionCreators?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reduxjs", "hidden": false, "pwls": null, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_h0ue75", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1591861874.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591888959.0, "link_flair_type": "text", "wls": null, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reduxjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Reference from &lt;a href=\"https://redux.js.org/recipes/writing-tests#action-creators\"&gt;Official docs&lt;/a&gt;:&lt;/p&gt;\n\n&lt;p&gt;In Redux, action creators are functions which return plain objects. When testing action creators, we want to test whether the correct action creator was called and also whether the right action was returned.&lt;/p&gt;\n\n&lt;p&gt;But my question is WHY?&lt;/p&gt;\n\n&lt;p&gt;ActionCreator is a function that returns an object. It&amp;#39;s a pure function. All it does is returning an object with whatever data is passed while calling. Is there any risk of not testing this function?&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;export function addTodo(text) {\n  return {\n    type: types.ADD_TODO,\n    text\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Its more like creating two objects and doing deep comparison.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;expect(actions.addTodo(text)).toEqual(expectedAction)&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The only scenario I can think of where unit tests can be useful is when someone accidentally changes this function to return an object with type: &lt;code&gt;types.EDIT_TODO&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;But  is this the only case? Are there any other benefits  of writing tests cases for functions that does the obvious?  &lt;/p&gt;\n\n&lt;p&gt;EDIT: I do use &lt;code&gt;redux-saga&lt;/code&gt; for managing async actions (fetching data through API calls etc) and I do write unit tests for sagas. I&amp;#39;m only concerned  about writing unit tests for action creators!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_39l3a", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "h0ue75", "is_robot_indexable": true, "report_reasons": null, "author": "rehman_00001", "discussion_type": null, "num_comments": 6, "send_replies": true, "whitelist_status": null, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reduxjs/comments/h0ue75/why_should_i_write_unit_test_for_actioncreators/", "parent_whitelist_status": null, "stickied": false, "url": "https://www.reddit.com/r/reduxjs/comments/h0ue75/why_should_i_write_unit_test_for_actioncreators/", "subreddit_subscribers": 3501, "created_utc": 1591860159.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_h0ue75", "before": null}}