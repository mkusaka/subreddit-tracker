{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "Kotlin", "selftext": "", "author_fullname": "t2_obpis", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Deep recursion with coroutines", "link_flair_richtext": [], "subreddit_name_prefixed": "r/Kotlin", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_g819ai", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 43, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 43, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1587877262.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "medium.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2so2r", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "g819ai", "is_robot_indexable": true, "report_reasons": null, "author": "dayanruben", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/Kotlin/comments/g819ai/deep_recursion_with_coroutines/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://medium.com/@elizarov/deep-recursion-with-coroutines-7c53e15993e3", "subreddit_subscribers": 30671, "created_utc": 1587848462.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "Kotlin", "selftext": "", "author_fullname": "t2_noyby", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Kotlin ArrayList Tutorial with Examples", "link_flair_richtext": [], "subreddit_name_prefixed": "r/Kotlin", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_g8dojp", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1587933665.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "kotlin-android.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2so2r", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "g8dojp", "is_robot_indexable": true, "report_reasons": null, "author": "waheed388", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/Kotlin/comments/g8dojp/kotlin_arraylist_tutorial_with_examples/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://kotlin-android.com/kotlin-arraylist/", "subreddit_subscribers": 30671, "created_utc": 1587904865.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "Kotlin", "selftext": "", "author_fullname": "t2_jqi5fhx", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Preview of Harmony: A multi-process safe SharedPreference", "link_flair_richtext": [], "subreddit_name_prefixed": "r/Kotlin", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_g838so", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 7, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 7, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "crosspost_parent_list": [{"approved_at_utc": null, "subreddit": "androiddev", "selftext": "[https://github.com/pablobaxter/HarmonyPreferences](https://github.com/pablobaxter/HarmonyPreferences)\n\nI know there are other \"multi-process SharedPreference\" libraries out there like Tray ([https://github.com/grandcentrix/tray](https://github.com/grandcentrix/tray)) and Tencent's MMKV ([https://github.com/Tencent/MMKV](https://github.com/Tencent/MMKV)), but what bothered me about them was the use of either NDK or that it used a ContentProvider. I didn't want something to depend on a second process starting, especially if I needed the preference data early.\n\nHarmony uses no ContentProviders, is available as quickly as SharedPreferences (first read does memory caching), and has no native code (NDK). It implements the `SharedPreference` interface, and is completely functional. All you have to do to get it is call `Harmony.getSharedPreferences(context, \"pref_name\")` in Java or `Context.getHarmonyPrefs(\"pref_name\")` in Kotlin.\n\nI'm still actively developing on it (mostly unit and performance tests), so use it at your own risk if you decide to run with it. I know some of us have suffered dealing with multi-process apps and sharing app data between it, so I'm hoping some find this potentially useful.", "author_fullname": "t2_jqi5fhx", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Preview of Harmony: A multi-process safe SharedPreference", "link_flair_richtext": [{"e": "text", "t": "Library"}], "subreddit_name_prefixed": "r/androiddev", "hidden": false, "pwls": 6, "link_flair_css_class": "library", "downs": 0, "hide_score": false, "name": "t3_g835oy", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 9, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Library", "can_mod_post": false, "score": 9, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1587864271.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1587884091.0, "link_flair_type": "richtext", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.androiddev", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;a href=\"https://github.com/pablobaxter/HarmonyPreferences\"&gt;https://github.com/pablobaxter/HarmonyPreferences&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;I know there are other &amp;quot;multi-process SharedPreference&amp;quot; libraries out there like Tray (&lt;a href=\"https://github.com/grandcentrix/tray\"&gt;https://github.com/grandcentrix/tray&lt;/a&gt;) and Tencent&amp;#39;s MMKV (&lt;a href=\"https://github.com/Tencent/MMKV\"&gt;https://github.com/Tencent/MMKV&lt;/a&gt;), but what bothered me about them was the use of either NDK or that it used a ContentProvider. I didn&amp;#39;t want something to depend on a second process starting, especially if I needed the preference data early.&lt;/p&gt;\n\n&lt;p&gt;Harmony uses no ContentProviders, is available as quickly as SharedPreferences (first read does memory caching), and has no native code (NDK). It implements the &lt;code&gt;SharedPreference&lt;/code&gt; interface, and is completely functional. All you have to do to get it is call &lt;code&gt;Harmony.getSharedPreferences(context, &amp;quot;pref_name&amp;quot;)&lt;/code&gt; in Java or &lt;code&gt;Context.getHarmonyPrefs(&amp;quot;pref_name&amp;quot;)&lt;/code&gt; in Kotlin.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m still actively developing on it (mostly unit and performance tests), so use it at your own risk if you decide to run with it. I know some of us have suffered dealing with multi-process apps and sharing app data between it, so I&amp;#39;m hoping some find this potentially useful.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "1174b8d6-e885-11e4-a11e-22000b268490", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2r26y", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "g835oy", "is_robot_indexable": true, "report_reasons": null, "author": "soaboz", "discussion_type": null, "num_comments": 7, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/androiddev/comments/g835oy/preview_of_harmony_a_multiprocess_safe/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/androiddev/comments/g835oy/preview_of_harmony_a_multiprocess_safe/", "subreddit_subscribers": 140945, "created_utc": 1587855291.0, "num_crossposts": 1, "media": null, "is_video": false}], "created": 1587884425.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.androiddev", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2so2r", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "g838so", "is_robot_indexable": true, "report_reasons": null, "author": "soaboz", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "crosspost_parent": "t3_g835oy", "author_flair_text_color": null, "permalink": "/r/Kotlin/comments/g838so/preview_of_harmony_a_multiprocess_safe/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "/r/androiddev/comments/g835oy/preview_of_harmony_a_multiprocess_safe/", "subreddit_subscribers": 30671, "created_utc": 1587855625.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "Kotlin", "selftext": "For this application my weapon of choice is Micronaut but I'm pretty sure the issue would be the same had I used Spring.\n\nI have a lot entities that I want to synchronize with various clients.\n\nAll the entities are exposed through a repository and on top of that a service.\n\nEach repository implements a method as illustrated below\n\n    interface EntityRepository {\n        fun findByUpdatedAfter(updatedDateTime: LocalDateTime): Iterable&lt;Entity&gt;\n    }\n\nAnd then in the service a similar (entity specific) method is implemented.\n\nSince this is duplicated for all repositories and services I thought I'd make it a bit more generic.\n\nSo I created an interface for my entities to ensure that a property called `updated` would exists\n\n    interface DateUpdatedEntity&lt;T&gt; {\n        val updated: T\n    }\n\nA generic repository\n\n    interface UpdatedAfterRepository&lt;E : DateUpdatedEntity&lt;T&gt;, T&gt; {\n        fun findByUpdatedAfter(updatedDateTime: T): Iterable&lt;E&gt;\n    }\n\nAnd a service interface with a default implementation of a method called `findAllAfter` as illustrated below\n\n    interface UpdatedAfterService&lt;E : DateUpdatedEntity&lt;T&gt;, T&gt; {\n        val updatedAfterRepository: UpdatedAfterRepository&lt;E, T&gt;\n        fun findAllAfter(updatedDateTime: T): Iterable&lt;E&gt; = updatedAfterRepository.findByUpdatedAfter(updatedDateTime)\n    }\n\nHowever when I try to implement the above in one of my services as illustrated below\n\n    @Singleton\n    @Transactional\n    class ExerciseServiceImpl(\n            override val updatedAfterRepository: UpdatedAfterRepository&lt;Exercise, LocalDateTime&gt;,\n            ...\n    ) : ExerciseService {\n    ...\n    }\n\nI get the following error message telling me that dependency injection has failed.\n\n    Message: Multiple possible bean candidates found: [dk.fitfit.fitlog.repository.WorkoutRepository$Intercepted, dk.fitfit.fitlog.repository.VideoRepository$Intercepted, dk.fitfit.fitlog.repository.SessionExerciseRepository$Intercepted, dk.fitfit.fitlog.repository.PictureRepository$Intercepted, dk.fitfit.fitlog.repository.SessionRepository$Intercepted, dk.fitfit.fitlog.repository.SessionRoundRepository$Intercepted, dk.fitfit.fitlog.repository.RoundRepository$Intercepted, dk.fitfit.fitlog.repository.RoundExerciseRepository$Intercepted, dk.fitfit.fitlog.repository.ExerciseRepository$Intercepted]\n\nI'm guessing it's because of type erasure but is there anything I can do about it? Or can anyone here suggest me an alternative approach? So I don't have to have repeating code in all my repositories and services", "author_fullname": "t2_4av7n0ta", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Generic repository/service method", "link_flair_richtext": [], "subreddit_name_prefixed": "r/Kotlin", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_g8ae4n", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1587915767.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.Kotlin", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;For this application my weapon of choice is Micronaut but I&amp;#39;m pretty sure the issue would be the same had I used Spring.&lt;/p&gt;\n\n&lt;p&gt;I have a lot entities that I want to synchronize with various clients.&lt;/p&gt;\n\n&lt;p&gt;All the entities are exposed through a repository and on top of that a service.&lt;/p&gt;\n\n&lt;p&gt;Each repository implements a method as illustrated below&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;interface EntityRepository {\n    fun findByUpdatedAfter(updatedDateTime: LocalDateTime): Iterable&amp;lt;Entity&amp;gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And then in the service a similar (entity specific) method is implemented.&lt;/p&gt;\n\n&lt;p&gt;Since this is duplicated for all repositories and services I thought I&amp;#39;d make it a bit more generic.&lt;/p&gt;\n\n&lt;p&gt;So I created an interface for my entities to ensure that a property called &lt;code&gt;updated&lt;/code&gt; would exists&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;interface DateUpdatedEntity&amp;lt;T&amp;gt; {\n    val updated: T\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;A generic repository&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;interface UpdatedAfterRepository&amp;lt;E : DateUpdatedEntity&amp;lt;T&amp;gt;, T&amp;gt; {\n    fun findByUpdatedAfter(updatedDateTime: T): Iterable&amp;lt;E&amp;gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And a service interface with a default implementation of a method called &lt;code&gt;findAllAfter&lt;/code&gt; as illustrated below&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;interface UpdatedAfterService&amp;lt;E : DateUpdatedEntity&amp;lt;T&amp;gt;, T&amp;gt; {\n    val updatedAfterRepository: UpdatedAfterRepository&amp;lt;E, T&amp;gt;\n    fun findAllAfter(updatedDateTime: T): Iterable&amp;lt;E&amp;gt; = updatedAfterRepository.findByUpdatedAfter(updatedDateTime)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However when I try to implement the above in one of my services as illustrated below&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;@Singleton\n@Transactional\nclass ExerciseServiceImpl(\n        override val updatedAfterRepository: UpdatedAfterRepository&amp;lt;Exercise, LocalDateTime&amp;gt;,\n        ...\n) : ExerciseService {\n...\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I get the following error message telling me that dependency injection has failed.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Message: Multiple possible bean candidates found: [dk.fitfit.fitlog.repository.WorkoutRepository$Intercepted, dk.fitfit.fitlog.repository.VideoRepository$Intercepted, dk.fitfit.fitlog.repository.SessionExerciseRepository$Intercepted, dk.fitfit.fitlog.repository.PictureRepository$Intercepted, dk.fitfit.fitlog.repository.SessionRepository$Intercepted, dk.fitfit.fitlog.repository.SessionRoundRepository$Intercepted, dk.fitfit.fitlog.repository.RoundRepository$Intercepted, dk.fitfit.fitlog.repository.RoundExerciseRepository$Intercepted, dk.fitfit.fitlog.repository.ExerciseRepository$Intercepted]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I&amp;#39;m guessing it&amp;#39;s because of type erasure but is there anything I can do about it? Or can anyone here suggest me an alternative approach? So I don&amp;#39;t have to have repeating code in all my repositories and services&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2so2r", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "g8ae4n", "is_robot_indexable": true, "report_reasons": null, "author": "baconialis", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/Kotlin/comments/g8ae4n/generic_repositoryservice_method/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/Kotlin/comments/g8ae4n/generic_repositoryservice_method/", "subreddit_subscribers": 30671, "created_utc": 1587886967.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "Kotlin", "selftext": "", "author_fullname": "t2_rqxvo", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Github Template for starting an Android app project with: 100% Kotlin + Github Actions + ktlint + Detekt + Gradle Kotlin DSL + buildSrc dependencies already set up.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/Kotlin", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_g7rhne", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 40, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 40, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "crosspost_parent_list": [{"approved_at_utc": null, "subreddit": "androiddev", "selftext": "", "author_fullname": "t2_rqxvo", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Github Template for starting an Android app project with: 100% Kotlin + Github Actions + ktlint + Detekt + Gradle Kotlin DSL + buildSrc dependencies already set up.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/androiddev", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_g7rhi8", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 205, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": "ddf77812-ffe5-11e0-be95-12313d18857a", "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 205, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [{"e": "text", "t": "Spotify"}], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1587839881.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "richtext", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": "Spotify", "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2r26y", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "g7rhi8", "is_robot_indexable": true, "report_reasons": null, "author": "cortinico", "discussion_type": null, "num_comments": 21, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": "dark", "permalink": "/r/androiddev/comments/g7rhi8/github_template_for_starting_an_android_app/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/cortinico/kotlin-android-template", "subreddit_subscribers": 140945, "created_utc": 1587811081.0, "num_crossposts": 2, "media": null, "is_video": false}], "created": 1587839905.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2so2r", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "g7rhne", "is_robot_indexable": true, "report_reasons": null, "author": "cortinico", "discussion_type": null, "num_comments": 6, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "crosspost_parent": "t3_g7rhi8", "author_flair_text_color": null, "permalink": "/r/Kotlin/comments/g7rhne/github_template_for_starting_an_android_app/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/cortinico/kotlin-android-template", "subreddit_subscribers": 30671, "created_utc": 1587811105.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "Kotlin", "selftext": "", "author_fullname": "t2_jqi5fhx", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "When I see a Java dev write Kotlin in a Java-esque way", "link_flair_richtext": [], "subreddit_name_prefixed": "r/Kotlin", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_g7iskp", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 179, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": true, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 179, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1587798650.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "i.redd.it", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2so2r", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "g7iskp", "is_robot_indexable": true, "report_reasons": null, "author": "soaboz", "discussion_type": null, "num_comments": 31, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/Kotlin/comments/g7iskp/when_i_see_a_java_dev_write_kotlin_in_a_javaesque/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://i.redd.it/btt1mk0aluu41.png", "subreddit_subscribers": 30671, "created_utc": 1587769850.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "Kotlin", "selftext": "I'd like to share our helper class which we use to organize multicasted Project Reactor streams.\n\nIn our crypto-currency exchange we pretty often use a multicasting when we broadcast messages from the server-side to our clients.\n\nAs an example, our gateway listens to a kernel which sends us all the information we need, but that information is streamed in one stream regardless of a trader it belongs to. So we listen to it, separate on different streams and broadcast them to our clients - such a process is called a multicasting.\n\nFor the sake of simplicity we moved all the multicast logic into a standalone class called `Multicast`. And here it is:\n\n    class Multicast&lt;in ReqT, RespT&gt;(\n        private val meterRegistry: MeterRegistry,\n        private val callerClassName: String,\n        private val numberOfCachedItemsAtStart: Int = 0,\n        private val subscribe: (ReqT) -&gt; Flux&lt;RespT&gt;\n    ) {\n    \n        private val subscriptions = ConcurrentHashMap&lt;ReqT, FluxProcessor&lt;RespT, RespT&gt;&gt;()\n    \n        init {\n            addMeter(\"multicast_total_upstreams\") { totalUpstreams().toDouble() }\n            addMeter(\"multicast_active_upstreams\") { activeUpstreams().toDouble() }\n        }\n    \n        private fun addMeter(name: String, function: (Multicast&lt;ReqT, RespT&gt;) -&gt; Double) {\n            meterRegistry.gauge(name, Tags.of(\"caller_class\", callerClassName), this, function)\n        }\n    \n        operator fun invoke(request: ReqT): Flux&lt;RespT&gt; {\n            return subscriptions.compute(request) { req, latest -&gt;\n                if (latest != null &amp;&amp; !latest.isTerminated) {\n                    latest\n                } else {\n                    val upstream = subscribe(req)\n                    val processor = ReplayProcessor.create&lt;RespT&gt;(numberOfCachedItemsAtStart)\n                    upstream.subscribe(processor)\n                    processor\n                }\n            }!!\n        }\n    \n        private fun totalUpstreams(): Int = subscriptions.values.size\n        private fun activeUpstreams(): Int = subscriptions.values.count { !it.isTerminated }\n        internal fun downstreamsNumber(request: ReqT): Long = subscriptions.getValue(request).downstreamCount()\n    }\n\nHere you see that we store a map of subscriptions where the keys are requests which received from the consumers and the values are Project Reactor FluxProcessors which help us to shift messages from an upstream subscription to downstream subscriptions.\n\nAlso we create some meters to have an opportunity to monitor number of alive and dead upstreams we have in the `Multicast`.\n\nIn the main `invoke` method, which essentially is a kotlin `Operator`, we check wether we have an existing `FluxProcessor` related to the specified request. If we have - we reuse it. Otherwise - we create a new upstream connection provided through the `subscribe` lambda in the class constructor, and then we create new `ReplayProcessor` which essentially is a Project Reactor `FluxProcessor` supporting a history of messages with a manageable history depth. This `ReplayProcessor` allows us to set a `numberOfCachedItemsAtStart` which we often use to store snapshot data. The created `ReplayProcessor` immediately subscribes to the upstream we initialized before, and then we return a `Flux` from the prepared `FluxProcessor`.\n\nAlso you can see that when we reuse an existing `FluxProcessor` we check wether it's terminated or not. It's necessary for the case when a client subscribed to our upstream, then unsubscribed (hence the `FluxProcessor` terminated) and then another client tries to subscribe. Of course in this case we should create a brand new `FluxProcessor` and we do it.\n\n&amp;#x200B;\n\nAnd what approaches do you use to manage multicasting in your projects?", "author_fullname": "t2_3pjjcuxn", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Multicasting for server-side using Kotlin and Project Reactor", "link_flair_richtext": [], "subreddit_name_prefixed": "r/Kotlin", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_g7zequ", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1587893250.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1587870854.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.Kotlin", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;d like to share our helper class which we use to organize multicasted Project Reactor streams.&lt;/p&gt;\n\n&lt;p&gt;In our crypto-currency exchange we pretty often use a multicasting when we broadcast messages from the server-side to our clients.&lt;/p&gt;\n\n&lt;p&gt;As an example, our gateway listens to a kernel which sends us all the information we need, but that information is streamed in one stream regardless of a trader it belongs to. So we listen to it, separate on different streams and broadcast them to our clients - such a process is called a multicasting.&lt;/p&gt;\n\n&lt;p&gt;For the sake of simplicity we moved all the multicast logic into a standalone class called &lt;code&gt;Multicast&lt;/code&gt;. And here it is:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;class Multicast&amp;lt;in ReqT, RespT&amp;gt;(\n    private val meterRegistry: MeterRegistry,\n    private val callerClassName: String,\n    private val numberOfCachedItemsAtStart: Int = 0,\n    private val subscribe: (ReqT) -&amp;gt; Flux&amp;lt;RespT&amp;gt;\n) {\n\n    private val subscriptions = ConcurrentHashMap&amp;lt;ReqT, FluxProcessor&amp;lt;RespT, RespT&amp;gt;&amp;gt;()\n\n    init {\n        addMeter(&amp;quot;multicast_total_upstreams&amp;quot;) { totalUpstreams().toDouble() }\n        addMeter(&amp;quot;multicast_active_upstreams&amp;quot;) { activeUpstreams().toDouble() }\n    }\n\n    private fun addMeter(name: String, function: (Multicast&amp;lt;ReqT, RespT&amp;gt;) -&amp;gt; Double) {\n        meterRegistry.gauge(name, Tags.of(&amp;quot;caller_class&amp;quot;, callerClassName), this, function)\n    }\n\n    operator fun invoke(request: ReqT): Flux&amp;lt;RespT&amp;gt; {\n        return subscriptions.compute(request) { req, latest -&amp;gt;\n            if (latest != null &amp;amp;&amp;amp; !latest.isTerminated) {\n                latest\n            } else {\n                val upstream = subscribe(req)\n                val processor = ReplayProcessor.create&amp;lt;RespT&amp;gt;(numberOfCachedItemsAtStart)\n                upstream.subscribe(processor)\n                processor\n            }\n        }!!\n    }\n\n    private fun totalUpstreams(): Int = subscriptions.values.size\n    private fun activeUpstreams(): Int = subscriptions.values.count { !it.isTerminated }\n    internal fun downstreamsNumber(request: ReqT): Long = subscriptions.getValue(request).downstreamCount()\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here you see that we store a map of subscriptions where the keys are requests which received from the consumers and the values are Project Reactor FluxProcessors which help us to shift messages from an upstream subscription to downstream subscriptions.&lt;/p&gt;\n\n&lt;p&gt;Also we create some meters to have an opportunity to monitor number of alive and dead upstreams we have in the &lt;code&gt;Multicast&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;In the main &lt;code&gt;invoke&lt;/code&gt; method, which essentially is a kotlin &lt;code&gt;Operator&lt;/code&gt;, we check wether we have an existing &lt;code&gt;FluxProcessor&lt;/code&gt; related to the specified request. If we have - we reuse it. Otherwise - we create a new upstream connection provided through the &lt;code&gt;subscribe&lt;/code&gt; lambda in the class constructor, and then we create new &lt;code&gt;ReplayProcessor&lt;/code&gt; which essentially is a Project Reactor &lt;code&gt;FluxProcessor&lt;/code&gt; supporting a history of messages with a manageable history depth. This &lt;code&gt;ReplayProcessor&lt;/code&gt; allows us to set a &lt;code&gt;numberOfCachedItemsAtStart&lt;/code&gt; which we often use to store snapshot data. The created &lt;code&gt;ReplayProcessor&lt;/code&gt; immediately subscribes to the upstream we initialized before, and then we return a &lt;code&gt;Flux&lt;/code&gt; from the prepared &lt;code&gt;FluxProcessor&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Also you can see that when we reuse an existing &lt;code&gt;FluxProcessor&lt;/code&gt; we check wether it&amp;#39;s terminated or not. It&amp;#39;s necessary for the case when a client subscribed to our upstream, then unsubscribed (hence the &lt;code&gt;FluxProcessor&lt;/code&gt; terminated) and then another client tries to subscribe. Of course in this case we should create a brand new &lt;code&gt;FluxProcessor&lt;/code&gt; and we do it.&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;And what approaches do you use to manage multicasting in your projects?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2so2r", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "g7zequ", "is_robot_indexable": true, "report_reasons": null, "author": "vadlit", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/Kotlin/comments/g7zequ/multicasting_for_serverside_using_kotlin_and/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/Kotlin/comments/g7zequ/multicasting_for_serverside_using_kotlin_and/", "subreddit_subscribers": 30671, "created_utc": 1587842054.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "Kotlin", "selftext": "", "author_fullname": "t2_3hfuxt4m", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Implementing Retrofit in Android | Paging | Part 17", "link_flair_richtext": [], "subreddit_name_prefixed": "r/Kotlin", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_g7pd0x", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {"content": "&lt;iframe width=\"459\" height=\"344\" src=\"https://www.youtube.com/embed/9jibu3RZ1S4?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "width": 459, "scrolling": false, "height": 344}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": {"oembed": {"provider_url": "https://www.youtube.com/", "title": "Implementing Retrofit in Android | Paging | Part 17", "html": "&lt;iframe width=\"459\" height=\"344\" src=\"https://www.youtube.com/embed/9jibu3RZ1S4?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "thumbnail_width": 480, "height": 344, "width": 459, "version": "1.0", "author_name": "teachmesome", "provider_name": "YouTube", "thumbnail_url": "https://i.ytimg.com/vi/9jibu3RZ1S4/hqdefault.jpg", "type": "video", "thumbnail_height": 360, "author_url": "https://www.youtube.com/channel/UCIWC3bm2eKj0wLGFULhzKdA"}, "type": "youtube.com"}, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {"content": "&lt;iframe width=\"459\" height=\"344\" src=\"https://www.youtube.com/embed/9jibu3RZ1S4?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "width": 459, "scrolling": false, "media_domain_url": "https://www.redditmedia.com/mediaembed/g7pd0x", "height": 344}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1587827618.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "youtube.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2so2r", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "g7pd0x", "is_robot_indexable": true, "report_reasons": null, "author": "teachmesome_com", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/Kotlin/comments/g7pd0x/implementing_retrofit_in_android_paging_part_17/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.youtube.com/watch?v=9jibu3RZ1S4", "subreddit_subscribers": 30671, "created_utc": 1587798818.0, "num_crossposts": 0, "media": {"oembed": {"provider_url": "https://www.youtube.com/", "title": "Implementing Retrofit in Android | Paging | Part 17", "html": "&lt;iframe width=\"459\" height=\"344\" src=\"https://www.youtube.com/embed/9jibu3RZ1S4?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "thumbnail_width": 480, "height": 344, "width": 459, "version": "1.0", "author_name": "teachmesome", "provider_name": "YouTube", "thumbnail_url": "https://i.ytimg.com/vi/9jibu3RZ1S4/hqdefault.jpg", "type": "video", "thumbnail_height": 360, "author_url": "https://www.youtube.com/channel/UCIWC3bm2eKj0wLGFULhzKdA"}, "type": "youtube.com"}, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "Kotlin", "selftext": "Hi folks,\n\nIn these days of quarantine, I started an open source project. I'd like to share it with you and gently ask, to everyone interested, feedback or critiques.\n\nThe project is hosted here: [https://github.com/besil/kobot](https://github.com/besil/kobot).\n\nIt is a framework to create conversational bots, using a simple configuration file.\n\nThe goal is to help non technical users to create conversational channels in an easy way. I know some proprietary software already do this, but I didn't find any open source project about it.\n\nMain feature include:\n\n* multiple conversational channels: telegram, http, cli, ...\n* Database interaction through sql language, in order to send dynamic messages or to store information\n* External HTTP API integration, in order to interact with web services\n* Published as docker image to simplify devops\n\nFramework is implemented 100% in Kotlin, with Spring Boot integration.\n\nAny critique or feedback is welcome!\n\nThank you!", "author_fullname": "t2_10yftk", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Kobot - configurable conversational bot framework, open source", "link_flair_richtext": [], "subreddit_name_prefixed": "r/Kotlin", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_g77jye", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 27, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 27, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1587760327.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.Kotlin", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hi folks,&lt;/p&gt;\n\n&lt;p&gt;In these days of quarantine, I started an open source project. I&amp;#39;d like to share it with you and gently ask, to everyone interested, feedback or critiques.&lt;/p&gt;\n\n&lt;p&gt;The project is hosted here: &lt;a href=\"https://github.com/besil/kobot\"&gt;https://github.com/besil/kobot&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;It is a framework to create conversational bots, using a simple configuration file.&lt;/p&gt;\n\n&lt;p&gt;The goal is to help non technical users to create conversational channels in an easy way. I know some proprietary software already do this, but I didn&amp;#39;t find any open source project about it.&lt;/p&gt;\n\n&lt;p&gt;Main feature include:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;multiple conversational channels: telegram, http, cli, ...&lt;/li&gt;\n&lt;li&gt;Database interaction through sql language, in order to send dynamic messages or to store information&lt;/li&gt;\n&lt;li&gt;External HTTP API integration, in order to interact with web services&lt;/li&gt;\n&lt;li&gt;Published as docker image to simplify devops&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Framework is implemented 100% in Kotlin, with Spring Boot integration.&lt;/p&gt;\n\n&lt;p&gt;Any critique or feedback is welcome!&lt;/p&gt;\n\n&lt;p&gt;Thank you!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2so2r", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "g77jye", "is_robot_indexable": true, "report_reasons": null, "author": "besil", "discussion_type": null, "num_comments": 6, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/Kotlin/comments/g77jye/kobot_configurable_conversational_bot_framework/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/Kotlin/comments/g77jye/kobot_configurable_conversational_bot_framework/", "subreddit_subscribers": 30671, "created_utc": 1587731527.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "Kotlin", "selftext": "", "author_fullname": "t2_y00ol", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Broker: Publish-Subscribe (a.k.a Pub/Sub, EventBus) library for Android and JVM built with Coroutines", "link_flair_richtext": [], "subreddit_name_prefixed": "r/Kotlin", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_g7gv2k", "quarantine": false, "link_flair_text_color": "dark", "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1587791934.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2so2r", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "g7gv2k", "is_robot_indexable": true, "report_reasons": null, "author": "adrielcafe", "discussion_type": null, "num_comments": 4, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/Kotlin/comments/g7gv2k/broker_publishsubscribe_aka_pubsub_eventbus/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/adrielcafe/Broker", "subreddit_subscribers": 30671, "created_utc": 1587763134.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_g7gv2k", "before": null}}