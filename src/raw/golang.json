{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "A massive shout out to sacado2 on hackernews\n\n Imagine we're working together and I have some text document I want you to work on and update. If I send you the text by email, I send a *copy* of it (the original text is still on my computer). If you modify that copy and keep it for you, I won't ever know what you did. I just used a function\n\n       func (c Coworker) SendForUpdates(d Document) {         ...     } \n\nThat wouldn't make sense. You worked hard and I don't even know what you did. So, what I would expect you to do is, once you made updates on the copy, to send me back that copy by email. That would be akin to\n\n       func (c Coworker) SendForUpdates(d Document) Document {         ...         return d     } \n\nI sent you a copy, and you returned another updated copy. That is \"pass-by-value\", the default, no-pointer style.\n\nNow, let's say I think those emails back and forth and boring. Rather than sending you a copy of the text each time, I could rather use Google Docs, and send you the *link* to that document. Its URL, rather than a copy of its content. Now, you can just go to that URL and do the updates on the document. You don't have to send me back the document: you're working on it, not on a copy of it! Well, that URL is a reference to the document rather than the document itself, or, if you prefer, a *pointer* to it. So, now, the function would be\n\n       func (c Coworker) SendForUpdates(d *Document) {         ...     } \n\nAnd we're done, no more back-and-forth dance now! That is \"pass-by-reference\".\n\nYou don't only use \"pass-by-reference\" just to be able to check updates on the document sent, by the way. If I want to send you some text just for your information and I don't expect any kind of update, I'll use pass-by-value (the very first function). But what if I want to send you a 3 GB video? I can't send that through e-mail! Sending a copy would be totally inefficient. Once again, I'll send you a pointer, an URL to download the video:\n\n       func (c Coworker) InformText(d Document) // d is small: pass-by-value      func (c Coworker) InformBigVideo(v *Video) // videos are huge: pass-by-reference \n\nWhy not use pointers everywhere by default, they seem easier, right? That's basically what java and python do. Well, they can be tricky too. I gave you the URL to the link and you could work on it. Once you're done, I don't want you to modify the document anymore. I want to send it to our boss. But, how could I know you didn't keep the URL somewhere in your bookmarks? How do I know, of all the coworkers I sent the URL to, one of them doesn't keep on updating that document even when I don't want to anymore? With copies, I'm safe, do whatever the hell you want with your copy, I don't care anymore. But a reference to the original document? That can be dangerous.   \n\n\nLink to full discussion:  [https://news.ycombinator.com/item?id=23206440](https://news.ycombinator.com/item?id=23206440)", "author_fullname": "t2_35r22fco", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "The best description on when to use a pointer and when to pass by value in GO I've seen!!!", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_gldrek", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.97, "author_flair_background_color": null, "subreddit_type": "public", "ups": 52, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 52, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1589743199.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;A massive shout out to sacado2 on hackernews&lt;/p&gt;\n\n&lt;p&gt;Imagine we&amp;#39;re working together and I have some text document I want you to work on and update. If I send you the text by email, I send a &lt;em&gt;copy&lt;/em&gt; of it (the original text is still on my computer). If you modify that copy and keep it for you, I won&amp;#39;t ever know what you did. I just used a function&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;   func (c Coworker) SendForUpdates(d Document) {         ...     } \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;That wouldn&amp;#39;t make sense. You worked hard and I don&amp;#39;t even know what you did. So, what I would expect you to do is, once you made updates on the copy, to send me back that copy by email. That would be akin to&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;   func (c Coworker) SendForUpdates(d Document) Document {         ...         return d     } \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I sent you a copy, and you returned another updated copy. That is &amp;quot;pass-by-value&amp;quot;, the default, no-pointer style.&lt;/p&gt;\n\n&lt;p&gt;Now, let&amp;#39;s say I think those emails back and forth and boring. Rather than sending you a copy of the text each time, I could rather use Google Docs, and send you the &lt;em&gt;link&lt;/em&gt; to that document. Its URL, rather than a copy of its content. Now, you can just go to that URL and do the updates on the document. You don&amp;#39;t have to send me back the document: you&amp;#39;re working on it, not on a copy of it! Well, that URL is a reference to the document rather than the document itself, or, if you prefer, a &lt;em&gt;pointer&lt;/em&gt; to it. So, now, the function would be&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;   func (c Coworker) SendForUpdates(d *Document) {         ...     } \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And we&amp;#39;re done, no more back-and-forth dance now! That is &amp;quot;pass-by-reference&amp;quot;.&lt;/p&gt;\n\n&lt;p&gt;You don&amp;#39;t only use &amp;quot;pass-by-reference&amp;quot; just to be able to check updates on the document sent, by the way. If I want to send you some text just for your information and I don&amp;#39;t expect any kind of update, I&amp;#39;ll use pass-by-value (the very first function). But what if I want to send you a 3 GB video? I can&amp;#39;t send that through e-mail! Sending a copy would be totally inefficient. Once again, I&amp;#39;ll send you a pointer, an URL to download the video:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;   func (c Coworker) InformText(d Document) // d is small: pass-by-value      func (c Coworker) InformBigVideo(v *Video) // videos are huge: pass-by-reference \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Why not use pointers everywhere by default, they seem easier, right? That&amp;#39;s basically what java and python do. Well, they can be tricky too. I gave you the URL to the link and you could work on it. Once you&amp;#39;re done, I don&amp;#39;t want you to modify the document anymore. I want to send it to our boss. But, how could I know you didn&amp;#39;t keep the URL somewhere in your bookmarks? How do I know, of all the coworkers I sent the URL to, one of them doesn&amp;#39;t keep on updating that document even when I don&amp;#39;t want to anymore? With copies, I&amp;#39;m safe, do whatever the hell you want with your copy, I don&amp;#39;t care anymore. But a reference to the original document? That can be dangerous.   &lt;/p&gt;\n\n&lt;p&gt;Link to full discussion:  &lt;a href=\"https://news.ycombinator.com/item?id=23206440\"&gt;https://news.ycombinator.com/item?id=23206440&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gldrek", "is_robot_indexable": true, "report_reasons": null, "author": "BritishBotWriter", "discussion_type": null, "num_comments": 14, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gldrek/the_best_description_on_when_to_use_a_pointer_and/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/gldrek/the_best_description_on_when_to_use_a_pointer_and/", "subreddit_subscribers": 112903, "created_utc": 1589714399.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_eiueu", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Learn Go: 1000+ Hand-crafted Go exercises and examples", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_gl1jo2", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.98, "author_flair_background_color": null, "subreddit_type": "public", "ups": 274, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 274, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1589688970.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gl1jo2", "is_robot_indexable": true, "report_reasons": null, "author": "blackflicker", "discussion_type": null, "num_comments": 16, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gl1jo2/learn_go_1000_handcrafted_go_exercises_and/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/inancgumus/learngo", "subreddit_subscribers": 112903, "created_utc": 1589660170.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_dglb8", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Go: AWS Lambda Project Structure Using Golang", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_glf3n3", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1589749579.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "medium.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "glf3n3", "is_robot_indexable": true, "report_reasons": null, "author": "dm03514", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/glf3n3/go_aws_lambda_project_structure_using_golang/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://medium.com/dm03514-tech-blog/go-aws-lambda-project-structure-using-golang-98b6c0a5339d", "subreddit_subscribers": 112903, "created_utc": 1589720779.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hi guys,\n\nI'm relatively new to SAML. I am using gosaml2, which seems to be the easiest to use and understand.\n\nI have basic HTTP-Redirect working just fine, but I wanted to use Traefik's forwardAuth facility. I thought about using HTTP-POST instead to send a POST form to the IdP (using KeyCloak at home to test), and hopefully getting a response back. Then using a 2XX series answer, send the result for Traefik to proxy or auth.\n\nAt the moment, when I do a POST, I get a \"saml\\_token\\_not\\_found\" in the IdP events (Invalid Request).\n\nAny idea if this can be done using POST? I would use the Redirect method, except I don't know how to capture the response back from the IdP in the same request. \"traefik-forward-auth\" seems to be able to do this for Oauth, which I believe also does a redirect, but I am not sure. I will look at this source again to see what's going on.\n\nI would appreciate the help. I've been hitting my head on this for over a week now...\n\nEdit: Replace \"Vouch\" with \"traefik-forward-auth.\"\n\nEdit 1: I posted the form from the browser, which did work, so I have been trying to replicate the complicated methods traefik-forward-auth uses.", "author_fullname": "t2_38yht", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Capture SAML Response (HTTP-Post) / Forward Auth for Traefik?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_glc9uw", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1589717876.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1589734804.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hi guys,&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m relatively new to SAML. I am using gosaml2, which seems to be the easiest to use and understand.&lt;/p&gt;\n\n&lt;p&gt;I have basic HTTP-Redirect working just fine, but I wanted to use Traefik&amp;#39;s forwardAuth facility. I thought about using HTTP-POST instead to send a POST form to the IdP (using KeyCloak at home to test), and hopefully getting a response back. Then using a 2XX series answer, send the result for Traefik to proxy or auth.&lt;/p&gt;\n\n&lt;p&gt;At the moment, when I do a POST, I get a &amp;quot;saml_token_not_found&amp;quot; in the IdP events (Invalid Request).&lt;/p&gt;\n\n&lt;p&gt;Any idea if this can be done using POST? I would use the Redirect method, except I don&amp;#39;t know how to capture the response back from the IdP in the same request. &amp;quot;traefik-forward-auth&amp;quot; seems to be able to do this for Oauth, which I believe also does a redirect, but I am not sure. I will look at this source again to see what&amp;#39;s going on.&lt;/p&gt;\n\n&lt;p&gt;I would appreciate the help. I&amp;#39;ve been hitting my head on this for over a week now...&lt;/p&gt;\n\n&lt;p&gt;Edit: Replace &amp;quot;Vouch&amp;quot; with &amp;quot;traefik-forward-auth.&amp;quot;&lt;/p&gt;\n\n&lt;p&gt;Edit 1: I posted the form from the browser, which did work, so I have been trying to replicate the complicated methods traefik-forward-auth uses.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "glc9uw", "is_robot_indexable": true, "report_reasons": null, "author": "dazealex", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/glc9uw/capture_saml_response_httppost_forward_auth_for/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/glc9uw/capture_saml_response_httppost_forward_auth_for/", "subreddit_subscribers": 112903, "created_utc": 1589706004.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "I've been working with go for a bit now, but this is my first time creating a rest API. I found that I had a lot of repetition when it came to returning JSON error responses (I know that error handling in go can be repetitive, which I generally like coming from the python world). \n\nLet's say my method validates the request, and then does a few database queries, does a computation, and then some other work, all of which can fail.\n\nI register my routes like\n\n    srv.r.HandleFunc(\"/api/foo/\", srv.getFoo).Methods(\"GET\")\n\nand then I created a helper function to reduce the amount of repetition. This helped clean up my code a bit.\n\n    func createError(w http.ResponseWriter, code int, msg string) {\n    \tw.WriteHeader(code)\n    \tjson.NewEncoder(w).Encode(myError{Msg: msg})\n    }\n    \n    type myError struct {\n    \tMsg string `json:\"msg\"`\n    }\n    \n\nAnd then one of the methods might look something like \n\n    func (srv *Server) getFoo(w http.ResponseWriter, r *http.Request) {\n    \tw.Header().Set(\"Content-Type\", \"application/json\")\n    \treq := Foo{FooID: r.Header.Get(\"foo_id\")}\n    \t_, err := govalidator.ValidateStruct(&amp;req)\n    \tif err != nil {\n    \t\t// log error\n    \t\tcreateError(w, http.StatusBadRequest, err.Error())\n    \t\treturn\n    \t}\n            ...\n            fooInfo, err := srv.getFooDetailsFromDB(req)\n            if err != nil {\n                createError(w, http.StatusInternalServerError, \"unexpected error\")\n                return\n            }\n            \n            fooValue, err := srv.calculateFooValue(fooInfo)\n            if err != nil {\n                createError(w, http.StatusInternalServerError, \"unexpected error\")\n                return\n            }\n            // etc etc\n            response, err := srv.generateFooResponse(fooValue, fooInfo)\n            if err != nil {\n                createError(w, http.StatusInternalServerError, \"unexpected error\")\n                return\n            }\n            json.NewEncoder(w).Encode(response)\n    }\n\nIs there a better way to do this? I find it isn't as bad with my \\`createError\\` function, but it still feels a bit clunky.\n\nI suppose I could combine all of my methods into something like \\`doWorkForFoo()\\`, and then call all of these methods from there, passing the appropriate HTTP status code to \\`createError\\` if any of those fail. But it still results in the same amount of repetition.\n\nAlternatively, I could return one error from \\`doWorkForFoo()\\`, and then check what the error is, and set the appropriate status code/message there.\n\nAny thoughts/ideas would be greatly appreciated!", "author_fullname": "t2_476cgn8q", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Avoiding repetition in a REST API?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": true, "name": "t3_glekya", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 1, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 1, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1589747297.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;ve been working with go for a bit now, but this is my first time creating a rest API. I found that I had a lot of repetition when it came to returning JSON error responses (I know that error handling in go can be repetitive, which I generally like coming from the python world). &lt;/p&gt;\n\n&lt;p&gt;Let&amp;#39;s say my method validates the request, and then does a few database queries, does a computation, and then some other work, all of which can fail.&lt;/p&gt;\n\n&lt;p&gt;I register my routes like&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;srv.r.HandleFunc(&amp;quot;/api/foo/&amp;quot;, srv.getFoo).Methods(&amp;quot;GET&amp;quot;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and then I created a helper function to reduce the amount of repetition. This helped clean up my code a bit.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func createError(w http.ResponseWriter, code int, msg string) {\n    w.WriteHeader(code)\n    json.NewEncoder(w).Encode(myError{Msg: msg})\n}\n\ntype myError struct {\n    Msg string `json:&amp;quot;msg&amp;quot;`\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And then one of the methods might look something like &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (srv *Server) getFoo(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)\n    req := Foo{FooID: r.Header.Get(&amp;quot;foo_id&amp;quot;)}\n    _, err := govalidator.ValidateStruct(&amp;amp;req)\n    if err != nil {\n        // log error\n        createError(w, http.StatusBadRequest, err.Error())\n        return\n    }\n        ...\n        fooInfo, err := srv.getFooDetailsFromDB(req)\n        if err != nil {\n            createError(w, http.StatusInternalServerError, &amp;quot;unexpected error&amp;quot;)\n            return\n        }\n\n        fooValue, err := srv.calculateFooValue(fooInfo)\n        if err != nil {\n            createError(w, http.StatusInternalServerError, &amp;quot;unexpected error&amp;quot;)\n            return\n        }\n        // etc etc\n        response, err := srv.generateFooResponse(fooValue, fooInfo)\n        if err != nil {\n            createError(w, http.StatusInternalServerError, &amp;quot;unexpected error&amp;quot;)\n            return\n        }\n        json.NewEncoder(w).Encode(response)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Is there a better way to do this? I find it isn&amp;#39;t as bad with my `createError` function, but it still feels a bit clunky.&lt;/p&gt;\n\n&lt;p&gt;I suppose I could combine all of my methods into something like `doWorkForFoo()`, and then call all of these methods from there, passing the appropriate HTTP status code to `createError` if any of those fail. But it still results in the same amount of repetition.&lt;/p&gt;\n\n&lt;p&gt;Alternatively, I could return one error from `doWorkForFoo()`, and then check what the error is, and set the appropriate status code/message there.&lt;/p&gt;\n\n&lt;p&gt;Any thoughts/ideas would be greatly appreciated!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "glekya", "is_robot_indexable": true, "report_reasons": null, "author": "jimgopher84", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/glekya/avoiding_repetition_in_a_rest_api/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/glekya/avoiding_repetition_in_a_rest_api/", "subreddit_subscribers": 112903, "created_utc": 1589718497.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_m3e44", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Gorched is terminal based game written in GO inspired by \"The Mother of all games\" Scorched Earth", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_gku4i7", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.95, "author_flair_background_color": null, "subreddit_type": "public", "ups": 75, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 75, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1589662147.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gku4i7", "is_robot_indexable": true, "report_reasons": null, "author": "zladovan", "discussion_type": null, "num_comments": 9, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gku4i7/gorched_is_terminal_based_game_written_in_go/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/zladovan/gorched", "subreddit_subscribers": 112903, "created_utc": 1589633347.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "\u201cThe key point here is our programmers are Googlers, they\u2019re not researchers. They\u2019re typically fairly young, fresh out of school, probably learned Java, maybe learned C or C++, probably learned Python. They\u2019re not capable of understanding a brilliant language but we want to use them to build good software. So, the language that we give them has to be easy for them to understand and easy to adopt.\u201d\n\n-- Rob Pike\n\n[https://youtube.com/watch?v=uwajp0g-bY4]", "author_fullname": "t2_6i1i7m6l", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "What the co-designer of Go thinks of Gophers", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_glcz3v", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.44, "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1589738811.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;\u201cThe key point here is our programmers are Googlers, they\u2019re not researchers. They\u2019re typically fairly young, fresh out of school, probably learned Java, maybe learned C or C++, probably learned Python. They\u2019re not capable of understanding a brilliant language but we want to use them to build good software. So, the language that we give them has to be easy for them to understand and easy to adopt.\u201d&lt;/p&gt;\n\n&lt;p&gt;-- Rob Pike&lt;/p&gt;\n\n&lt;p&gt;[&lt;a href=\"https://youtube.com/watch?v=uwajp0g-bY4\"&gt;https://youtube.com/watch?v=uwajp0g-bY4&lt;/a&gt;]&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "glcz3v", "is_robot_indexable": true, "report_reasons": null, "author": "sooslack", "discussion_type": null, "num_comments": 21, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/glcz3v/what_the_codesigner_of_go_thinks_of_gophers/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/glcz3v/what_the_codesigner_of_go_thinks_of_gophers/", "subreddit_subscribers": 112903, "created_utc": 1589710011.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_3em9l", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Representing JSON structures in Go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_gkwxka", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.82, "author_flair_background_color": null, "subreddit_type": "public", "ups": 27, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 27, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1589673347.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "eli.thegreenplace.net", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gkwxka", "is_robot_indexable": true, "report_reasons": null, "author": "skeeto", "discussion_type": null, "num_comments": 6, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gkwxka/representing_json_structures_in_go/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://eli.thegreenplace.net/2020/representing-json-structures-in-go/", "subreddit_subscribers": 112903, "created_utc": 1589644547.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "It's functional options pattern with appliance in #Go.\u263a\ufe0f\n\nThis design pattern is used by Google API.\n\n&amp;#x200B;\n\nhttps://preview.redd.it/s5l5ejh5v7z41.png?width=476&amp;format=png&amp;auto=webp&amp;s=f46aa7972c6ca4f29b0a475740c80ca9fc35b858\n\nhttps://preview.redd.it/8qvmurh5v7z41.png?width=779&amp;format=png&amp;auto=webp&amp;s=2b8f1fe2c92809fbf0acf74ba3a17dcd2c6ee4d3\n\nhttps://preview.redd.it/twb1vqh5v7z41.png?width=284&amp;format=png&amp;auto=webp&amp;s=c68bc97c42126ce366664f39b719cf32b90ad63e", "author_fullname": "t2_48qiy5az", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "functional options pattern using by Google API.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "media_metadata": {"s5l5ejh5v7z41": {"status": "valid", "e": "Image", "m": "image/png", "p": [{"y": 131, "x": 108, "u": "https://preview.redd.it/s5l5ejh5v7z41.png?width=108&amp;crop=smart&amp;auto=webp&amp;s=a1e955e09f34ce12da0cc8dfeb65e9f2bf67c4e9"}, {"y": 262, "x": 216, "u": "https://preview.redd.it/s5l5ejh5v7z41.png?width=216&amp;crop=smart&amp;auto=webp&amp;s=24fb15199388a3afac491e0a9240011f00414814"}, {"y": 388, "x": 320, "u": "https://preview.redd.it/s5l5ejh5v7z41.png?width=320&amp;crop=smart&amp;auto=webp&amp;s=f8f19e00e9039b9f51b1cbc16847c1e3dadde813"}], "s": {"y": 578, "x": 476, "u": "https://preview.redd.it/s5l5ejh5v7z41.png?width=476&amp;format=png&amp;auto=webp&amp;s=f46aa7972c6ca4f29b0a475740c80ca9fc35b858"}, "id": "s5l5ejh5v7z41"}, "8qvmurh5v7z41": {"status": "valid", "e": "Image", "m": "image/png", "p": [{"y": 68, "x": 108, "u": "https://preview.redd.it/8qvmurh5v7z41.png?width=108&amp;crop=smart&amp;auto=webp&amp;s=08de16b48c6e5e606402ede458382b3d33bad6ee"}, {"y": 137, "x": 216, "u": "https://preview.redd.it/8qvmurh5v7z41.png?width=216&amp;crop=smart&amp;auto=webp&amp;s=bb88541c0aefef9f7501736b71c79d86eaac3570"}, {"y": 203, "x": 320, "u": "https://preview.redd.it/8qvmurh5v7z41.png?width=320&amp;crop=smart&amp;auto=webp&amp;s=b09250fe67a3789e6caf957fad9b0abb1a06fe30"}, {"y": 406, "x": 640, "u": "https://preview.redd.it/8qvmurh5v7z41.png?width=640&amp;crop=smart&amp;auto=webp&amp;s=cb8a3728bc043b4dbbe7a97419eb155df1bffda4"}], "s": {"y": 495, "x": 779, "u": "https://preview.redd.it/8qvmurh5v7z41.png?width=779&amp;format=png&amp;auto=webp&amp;s=2b8f1fe2c92809fbf0acf74ba3a17dcd2c6ee4d3"}, "id": "8qvmurh5v7z41"}, "twb1vqh5v7z41": {"status": "valid", "e": "Image", "m": "image/png", "p": [{"y": 147, "x": 108, "u": "https://preview.redd.it/twb1vqh5v7z41.png?width=108&amp;crop=smart&amp;auto=webp&amp;s=c0321f4b473178ce8835439e991dfa7645369449"}, {"y": 294, "x": 216, "u": "https://preview.redd.it/twb1vqh5v7z41.png?width=216&amp;crop=smart&amp;auto=webp&amp;s=fd2deedcdd46116c492196f34cce5698cde9b36c"}], "s": {"y": 387, "x": 284, "u": "https://preview.redd.it/twb1vqh5v7z41.png?width=284&amp;format=png&amp;auto=webp&amp;s=c68bc97c42126ce366664f39b719cf32b90ad63e"}, "id": "twb1vqh5v7z41"}}, "name": "t3_gl5bkn", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.78, "author_flair_background_color": null, "subreddit_type": "public", "ups": 5, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 5, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1589702752.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;It&amp;#39;s functional options pattern with appliance in #Go.\u263a\ufe0f&lt;/p&gt;\n\n&lt;p&gt;This design pattern is used by Google API.&lt;/p&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://preview.redd.it/s5l5ejh5v7z41.png?width=476&amp;amp;format=png&amp;amp;auto=webp&amp;amp;s=f46aa7972c6ca4f29b0a475740c80ca9fc35b858\"&gt;https://preview.redd.it/s5l5ejh5v7z41.png?width=476&amp;amp;format=png&amp;amp;auto=webp&amp;amp;s=f46aa7972c6ca4f29b0a475740c80ca9fc35b858&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://preview.redd.it/8qvmurh5v7z41.png?width=779&amp;amp;format=png&amp;amp;auto=webp&amp;amp;s=2b8f1fe2c92809fbf0acf74ba3a17dcd2c6ee4d3\"&gt;https://preview.redd.it/8qvmurh5v7z41.png?width=779&amp;amp;format=png&amp;amp;auto=webp&amp;amp;s=2b8f1fe2c92809fbf0acf74ba3a17dcd2c6ee4d3&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://preview.redd.it/twb1vqh5v7z41.png?width=284&amp;amp;format=png&amp;amp;auto=webp&amp;amp;s=c68bc97c42126ce366664f39b719cf32b90ad63e\"&gt;https://preview.redd.it/twb1vqh5v7z41.png?width=284&amp;amp;format=png&amp;amp;auto=webp&amp;amp;s=c68bc97c42126ce366664f39b719cf32b90ad63e&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gl5bkn", "is_robot_indexable": true, "report_reasons": null, "author": "we_are_noknow", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gl5bkn/functional_options_pattern_using_by_google_api/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/gl5bkn/functional_options_pattern_using_by_google_api/", "subreddit_subscribers": 112903, "created_utc": 1589673952.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_oi307", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "A little history and legacy on Go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "hide_score": false, "name": "t3_gl5439", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 6, "total_awards_received": 0, "media_embed": {"content": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/k0VsfTAqqEA?start=8&amp;feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "width": 600, "scrolling": false, "height": 338}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": {"type": "youtube.com", "oembed": {"provider_url": "https://www.youtube.com/", "version": "1.0", "title": "GoLab 2019 - Steve Francia - Day 3 Closing Talk: The Legacy of Go", "type": "video", "thumbnail_width": 480, "height": 338, "width": 600, "html": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/k0VsfTAqqEA?start=8&amp;feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "author_name": "GoLab conference", "provider_name": "YouTube", "thumbnail_url": "https://i.ytimg.com/vi/k0VsfTAqqEA/hqdefault.jpg", "thumbnail_height": 360, "author_url": "https://www.youtube.com/channel/UCMEvzoHTIdZI7IM8LoRbLsQ"}}, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {"content": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/k0VsfTAqqEA?start=8&amp;feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "width": 600, "scrolling": false, "media_domain_url": "https://www.redditmedia.com/mediaembed/gl5439", "height": 338}, "link_flair_text": null, "can_mod_post": false, "score": 6, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1589701958.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "youtu.be", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gl5439", "is_robot_indexable": true, "report_reasons": null, "author": "jhampac", "discussion_type": null, "num_comments": 0, "send_replies": false, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gl5439/a_little_history_and_legacy_on_go/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://youtu.be/k0VsfTAqqEA?t=8", "subreddit_subscribers": 112903, "created_utc": 1589673158.0, "num_crossposts": 0, "media": {"type": "youtube.com", "oembed": {"provider_url": "https://www.youtube.com/", "version": "1.0", "title": "GoLab 2019 - Steve Francia - Day 3 Closing Talk: The Legacy of Go", "type": "video", "thumbnail_width": 480, "height": 338, "width": 600, "html": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/k0VsfTAqqEA?start=8&amp;feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "author_name": "GoLab conference", "provider_name": "YouTube", "thumbnail_url": "https://i.ytimg.com/vi/k0VsfTAqqEA/hqdefault.jpg", "thumbnail_height": 360, "author_url": "https://www.youtube.com/channel/UCMEvzoHTIdZI7IM8LoRbLsQ"}}, "is_video": false}}], "after": "t3_gl5439", "before": null}}