{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "", "author_fullname": "t2_kq1d5", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Ruby on Rails in a week", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": "", "downs": 0, "thumbnail_height": 82, "top_awarded_type": null, "hide_score": false, "name": "t3_jkpvwf", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.86, "author_flair_background_color": null, "subreddit_type": "public", "ups": 14, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Blog post", "can_mod_post": false, "score": 14, "approved_by": null, "author_premium": false, "thumbnail": "https://b.thumbs.redditmedia.com/bM1xZqvO8QYQGtT-MUduypoa9DlAH2p7YbYG-vvUSKc.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "link", "content_categories": null, "is_self": false, "mod_note": null, "created": 1604059311.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "simplethread.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://www.simplethread.com/ruby-on-rails-in-a-week/", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/cDRURsSHvscjpQp3mOBkbvNugVP2NnzVG_-260RrFZc.jpg?auto=webp&amp;s=549acc5d814a2e10d13636afbab159449aeb3eaf", "width": 2000, "height": 1182}, "resolutions": [{"url": "https://external-preview.redd.it/cDRURsSHvscjpQp3mOBkbvNugVP2NnzVG_-260RrFZc.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=a9535233b7bd504eff8dd7e9c6d0c4d0e16f5767", "width": 108, "height": 63}, {"url": "https://external-preview.redd.it/cDRURsSHvscjpQp3mOBkbvNugVP2NnzVG_-260RrFZc.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=286a4d1735f6a77bcd88188444120c756ced957c", "width": 216, "height": 127}, {"url": "https://external-preview.redd.it/cDRURsSHvscjpQp3mOBkbvNugVP2NnzVG_-260RrFZc.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=36b222efa53d827345593e0c151cf4f6b39afc98", "width": 320, "height": 189}, {"url": "https://external-preview.redd.it/cDRURsSHvscjpQp3mOBkbvNugVP2NnzVG_-260RrFZc.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=d683c4815d20228f9a59fa488f3bf5270c956d16", "width": 640, "height": 378}, {"url": "https://external-preview.redd.it/cDRURsSHvscjpQp3mOBkbvNugVP2NnzVG_-260RrFZc.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=2732358ef0c420d6838b24b2402ae6e3317bb31b", "width": 960, "height": 567}, {"url": "https://external-preview.redd.it/cDRURsSHvscjpQp3mOBkbvNugVP2NnzVG_-260RrFZc.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=408f5355b8796ae79a81cfcee0888ab9b2e89ee8", "width": 1080, "height": 638}], "variants": {}, "id": "PsjaQnHuRo2wblVqbjmpXSctGgve0Nr7kGHjm6vpT4k"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "c8896134-873c-11e9-8edb-0e1f22813c3e", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "jkpvwf", "is_robot_indexable": true, "report_reasons": null, "author": "ASIC_SP", "discussion_type": null, "num_comments": 0, "send_replies": false, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/jkpvwf/ruby_on_rails_in_a_week/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.simplethread.com/ruby-on-rails-in-a-week/", "subreddit_subscribers": 68080, "created_utc": 1604030511.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "", "author_fullname": "t2_wjv56", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Future of Ruby - The Journey to One Million Websocket Connections", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": 105, "top_awarded_type": null, "hide_score": false, "name": "t3_jki55j", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.98, "author_flair_background_color": null, "subreddit_type": "public", "ups": 48, "total_awards_received": 1, "media_embed": {"content": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/Dtn9Uudw4Mo?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "width": 600, "scrolling": false, "height": 338}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": {"type": "youtube.com", "oembed": {"provider_url": "https://www.youtube.com/", "version": "1.0", "title": "RubyConf Taiwan 2019 - The Journey to One Million by Samuel Williams", "type": "video", "thumbnail_width": 480, "height": 338, "width": 600, "html": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/Dtn9Uudw4Mo?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "author_name": "RubyConf Taiwan", "provider_name": "YouTube", "thumbnail_url": "https://i.ytimg.com/vi/Dtn9Uudw4Mo/hqdefault.jpg", "thumbnail_height": 360, "author_url": "https://www.youtube.com/channel/UCqw_z59yI24SivuD573FECA"}}, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {"content": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/Dtn9Uudw4Mo?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "width": 600, "scrolling": false, "media_domain_url": "https://www.redditmedia.com/mediaembed/jki55j", "height": 338}, "link_flair_text": null, "can_mod_post": false, "score": 48, "approved_by": null, "author_premium": false, "thumbnail": "https://a.thumbs.redditmedia.com/-cRg-hfkQH6djmX-A6BA1WgIS2aWlogdX71tM6tVhk4.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {"gid_1": 1}, "post_hint": "rich:video", "content_categories": null, "is_self": false, "mod_note": null, "created": 1604032529.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "youtube.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://www.youtube.com/watch?v=Dtn9Uudw4Mo", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/kEju71i3uYnEMc_vQrkPCLPGqN4t5xnWnTlhEiMUzH8.jpg?auto=webp&amp;s=c0b9602d9e2226c7edab7ae29e184d158ec6a4a6", "width": 480, "height": 360}, "resolutions": [{"url": "https://external-preview.redd.it/kEju71i3uYnEMc_vQrkPCLPGqN4t5xnWnTlhEiMUzH8.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=49971ff3c30cc7d75978e0a193a66058e43addc2", "width": 108, "height": 81}, {"url": "https://external-preview.redd.it/kEju71i3uYnEMc_vQrkPCLPGqN4t5xnWnTlhEiMUzH8.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=23bd9b3fde627d9ad24919c09ad1f31972aae646", "width": 216, "height": 162}, {"url": "https://external-preview.redd.it/kEju71i3uYnEMc_vQrkPCLPGqN4t5xnWnTlhEiMUzH8.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=85b1dee92e9397b578e31aa710d6a0ca7c1aa45c", "width": 320, "height": 240}], "variants": {}, "id": "p5BzTWmNlIm-YyT7SvqjacVYWEHszEHxbeImy4Y3b7E"}], "enabled": false}, "all_awardings": [{"giver_coin_reward": null, "subreddit_id": null, "is_new": false, "days_of_drip_extension": 0, "coin_price": 100, "id": "gid_1", "penny_donate": null, "award_sub_type": "GLOBAL", "coin_reward": 0, "icon_url": "https://www.redditstatic.com/gold/awards/icon/silver_512.png", "days_of_premium": 0, "tiers_by_required_awardings": null, "resized_icons": [{"url": "https://www.redditstatic.com/gold/awards/icon/silver_16.png", "width": 16, "height": 16}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_32.png", "width": 32, "height": 32}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_48.png", "width": 48, "height": 48}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_64.png", "width": 64, "height": 64}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_128.png", "width": 128, "height": 128}], "icon_width": 512, "static_icon_width": 512, "start_date": null, "is_enabled": true, "awardings_required_to_grant_benefits": null, "description": "Shows the Silver Award... and that's it.", "end_date": null, "subreddit_coin_reward": 0, "count": 1, "static_icon_height": 512, "name": "Silver", "resized_static_icons": [{"url": "https://www.redditstatic.com/gold/awards/icon/silver_16.png", "width": 16, "height": 16}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_32.png", "width": 32, "height": 32}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_48.png", "width": 48, "height": 48}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_64.png", "width": 64, "height": 64}, {"url": "https://www.redditstatic.com/gold/awards/icon/silver_128.png", "width": 128, "height": 128}], "icon_format": null, "icon_height": 512, "penny_price": null, "award_type": "global", "static_icon_url": "https://www.redditstatic.com/gold/awards/icon/silver_512.png"}], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "jki55j", "is_robot_indexable": true, "report_reasons": null, "author": "ahmad_musaffa", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/jki55j/future_of_ruby_the_journey_to_one_million/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.youtube.com/watch?v=Dtn9Uudw4Mo", "subreddit_subscribers": 68080, "created_utc": 1604003729.0, "num_crossposts": 0, "media": {"type": "youtube.com", "oembed": {"provider_url": "https://www.youtube.com/", "version": "1.0", "title": "RubyConf Taiwan 2019 - The Journey to One Million by Samuel Williams", "type": "video", "thumbnail_width": 480, "height": 338, "width": 600, "html": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/Dtn9Uudw4Mo?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "author_name": "RubyConf Taiwan", "provider_name": "YouTube", "thumbnail_url": "https://i.ytimg.com/vi/Dtn9Uudw4Mo/hqdefault.jpg", "thumbnail_height": 360, "author_url": "https://www.youtube.com/channel/UCqw_z59yI24SivuD573FECA"}}, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "", "author_fullname": "t2_zmb2u", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Packwerk at Shopify", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": 105, "top_awarded_type": null, "hide_score": true, "name": "t3_jkwp16", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 2, "total_awards_received": 0, "media_embed": {"content": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/olEA157z7kU?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "width": 600, "scrolling": false, "height": 338}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": {"type": "youtube.com", "oembed": {"provider_url": "https://www.youtube.com/", "version": "1.0", "title": "ShipIt! presents: Packwerk at Shopify", "type": "video", "thumbnail_width": 480, "height": 338, "width": 600, "html": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/olEA157z7kU?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "author_name": "Shopify Engineering", "provider_name": "YouTube", "thumbnail_url": "https://i.ytimg.com/vi/olEA157z7kU/hqdefault.jpg", "thumbnail_height": 360, "author_url": "https://www.youtube.com/channel/UCcSb55kxVx_euWDDRfWFxrA"}}, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {"content": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/olEA157z7kU?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "width": 600, "scrolling": false, "media_domain_url": "https://www.redditmedia.com/mediaembed/jkwp16", "height": 338}, "link_flair_text": null, "can_mod_post": false, "score": 2, "approved_by": null, "author_premium": false, "thumbnail": "https://b.thumbs.redditmedia.com/QVdWIvqzO1IAPmy3uP3BodyvOa1CWafblqgi3RqmIpw.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "rich:video", "content_categories": null, "is_self": false, "mod_note": null, "created": 1604093124.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "youtube.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://youtube.com/watch?v=olEA157z7kU", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/tHGuS6eawzCWo7aVvX6CCw8Mg6gbTu9KpCDN7Zz0__s.jpg?auto=webp&amp;s=4b1c38edc2481cc450133cdcc02ac7ccf259eb1e", "width": 480, "height": 360}, "resolutions": [{"url": "https://external-preview.redd.it/tHGuS6eawzCWo7aVvX6CCw8Mg6gbTu9KpCDN7Zz0__s.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=dcd0a744fdb71fb70bfd3ca06b844e3aaf03ae3d", "width": 108, "height": 81}, {"url": "https://external-preview.redd.it/tHGuS6eawzCWo7aVvX6CCw8Mg6gbTu9KpCDN7Zz0__s.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=4d27915e1e3773d2193623c7ca58ba629f90ebaf", "width": 216, "height": 162}, {"url": "https://external-preview.redd.it/tHGuS6eawzCWo7aVvX6CCw8Mg6gbTu9KpCDN7Zz0__s.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=807d211a10b3201d26418336564c61bad460ff93", "width": 320, "height": 240}], "variants": {}, "id": "iodSW3kiRWFrwMLjiDMVfkVc9__TBUPCw2xQaAk1tEA"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "jkwp16", "is_robot_indexable": true, "report_reasons": null, "author": "geospeck", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/jkwp16/packwerk_at_shopify/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://youtube.com/watch?v=olEA157z7kU", "subreddit_subscribers": 68080, "created_utc": 1604064324.0, "num_crossposts": 0, "media": {"type": "youtube.com", "oembed": {"provider_url": "https://www.youtube.com/", "version": "1.0", "title": "ShipIt! presents: Packwerk at Shopify", "type": "video", "thumbnail_width": 480, "height": 338, "width": 600, "html": "&lt;iframe width=\"600\" height=\"338\" src=\"https://www.youtube.com/embed/olEA157z7kU?feature=oembed&amp;enablejsapi=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;", "author_name": "Shopify Engineering", "provider_name": "YouTube", "thumbnail_url": "https://i.ytimg.com/vi/olEA157z7kU/hqdefault.jpg", "thumbnail_height": 360, "author_url": "https://www.youtube.com/channel/UCcSb55kxVx_euWDDRfWFxrA"}}, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "Suppose I have a method like this \n\n    def fun(a, options = {})\n      puts [a, options].inspect\n    end\n    fun(1, a: 3, b: 4) =&gt;  [1, {:a=&gt;3, :b=&gt;4}]\n\nI don't understand how this gets converted to a hash. Also, is it possible to have this in the middle somewhere? like this  \n\n\n    def fun(a, options = {}, c)\n      puts [a, options].inspect\n    end\n    fun(1, a: 3, b: 4, 10)\n\nwithout have to wrap \\`a: 3, b: 4\\` into  {}?", "author_fullname": "t2_7m8mv9r7", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "how is this converted to a hash in a function call?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": "", "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_jktr6s", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 3, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Question", "can_mod_post": false, "score": 3, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1604079610.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Suppose I have a method like this &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;def fun(a, options = {})\n  puts [a, options].inspect\nend\nfun(1, a: 3, b: 4) =&amp;gt;  [1, {:a=&amp;gt;3, :b=&amp;gt;4}]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I don&amp;#39;t understand how this gets converted to a hash. Also, is it possible to have this in the middle somewhere? like this  &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;def fun(a, options = {}, c)\n  puts [a, options].inspect\nend\nfun(1, a: 3, b: 4, 10)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;without have to wrap `a: 3, b: 4` into  {}?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "d3392e70-873c-11e9-af37-0eea3fce36a6", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "jktr6s", "is_robot_indexable": true, "report_reasons": null, "author": "prosperousdoggo", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/jktr6s/how_is_this_converted_to_a_hash_in_a_function_call/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/jktr6s/how_is_this_converted_to_a_hash_in_a_function_call/", "subreddit_subscribers": 68080, "created_utc": 1604050810.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "So this RPC system has some advantages...\n1. I programmed it as a toy (which was fun for me)\n2. It's simple, if there is a bug in 57 lines of code, it's easy to find and fix\n3. It uses redis, which I like, is simple, and fast\n4. It handles exceptions which is probably necessary if anyone ever wanted to actually use it\n5. there are no timeouts for long running code, cause sometimes timeouts are frustrating\n6. there are timeouts for return values because those should be fast anyway\n7. usage is simple so you don't have to understand what's going on to use it\n8. if it's not already obvious rrecv and rsend invocations can occur on different processes (or with a little more configuration on different machines)  (all classes used as arguments should be available to all processes since we're using Marshaling)\n\n```\nrrecv(:name_of_thing_that_can_be_called) do |args|\n#do whatever processing you want\n#whatever is returned by this block is returned to the caller\nend\n```\n```\nresult = rsend(:name_of_thing_that_can_be_called, &lt;whatever args you want&gt;, &lt;can be many&gt;)\n```\nevery time you define a new callable thing with rrecv, it will spin up a new thread to respond to those requests\n\nfuture work, add the ability to control how many workers rrecv creates, and possibly allow other types of workers other than just threads.\n\n\n\n```\nrequire 'securerandom'\nrequire 'redis'\n\nclass Message\n  attr_reader :payload, :guid\n\n  def initialize(*args)\n    @guid = SecureRandom.uuid\n    @payload = args\n  end\nend\n\nclass RPCExceptionContainer\n  attr_reader :saved_exception\n\n  def initialize(exception)\n    @saved_exception = exception\n  end\nend\n\ndef rsend(key, *args)\n  @r ||= Redis.new\n  Message.new(*args).tap do |message|\n    @r.rpush(key, Marshal.dump(message))\n    Marshal.load(@r.blpop(message.guid)[1]).tap do |return_value|\n      if return_value.class == RPCExceptionContainer\n        raise return_value.saved_exception\n      else\n        return return_value\n      end\n    end\n  end\nend\n\ndef rrecv(key)\n  @keys ||= Hash.new\n  if(!@keys.has_key?(key))\n    r = Redis.new\n    Thread.new do\n      loop do\n        Marshal.load(r.blpop(key)[1]).tap do |message|\n          begin\n            return_value = yield(message.payload)\n            r.rpush(message.guid, Marshal.dump(return_value))\n            r.expire(message.guid, 30)\n          rescue\n            r.rpush(message.guid, Marshal.dump(RPCExceptionContainer.new($!)))\n            r.expire(message.guid, 30)\n          end\n        end\n      end\n    end\n    @keys[key] = true\n  else\n    raise \"You Called rrecv twice on the same key, this is almost certainly not what you intended\"\n  end\nend\n\nrrecv(:hello) do |args|\n  puts \"Hello #{args.reduce(:+)}\"\n  raise \"what what\"\n  \"success\"\nend\nx = rsend(:hello, \"hi there\", \"nobody\") rescue \"bobby farquard\"\nputs x\n\nrrecv(:there) do |args|\n  puts \"There #{args.reduce(:+)}\"\n  \"success\"\nend\ny = rsend(:there, \"something else\")\nputs y\n\n\nx = rsend(:hello, \"hi there\", \"nobody\") rescue \"bobby farquard again\"\nputs x\n```", "author_fullname": "t2_finks", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Why I love ruby, a complete RPC system using redis in 57 lines of code :)", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_jki6b7", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.95, "author_flair_background_color": null, "subreddit_type": "public", "ups": 18, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 18, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1604032629.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;So this RPC system has some advantages...\n1. I programmed it as a toy (which was fun for me)\n2. It&amp;#39;s simple, if there is a bug in 57 lines of code, it&amp;#39;s easy to find and fix\n3. It uses redis, which I like, is simple, and fast\n4. It handles exceptions which is probably necessary if anyone ever wanted to actually use it\n5. there are no timeouts for long running code, cause sometimes timeouts are frustrating\n6. there are timeouts for return values because those should be fast anyway\n7. usage is simple so you don&amp;#39;t have to understand what&amp;#39;s going on to use it\n8. if it&amp;#39;s not already obvious rrecv and rsend invocations can occur on different processes (or with a little more configuration on different machines)  (all classes used as arguments should be available to all processes since we&amp;#39;re using Marshaling)&lt;/p&gt;\n\n&lt;p&gt;```\nrrecv(:name_of_thing_that_can_be_called) do |args|&lt;/p&gt;\n\n&lt;h1&gt;do whatever processing you want&lt;/h1&gt;\n\n&lt;h1&gt;whatever is returned by this block is returned to the caller&lt;/h1&gt;\n\n&lt;p&gt;end\n&lt;code&gt;\n&lt;/code&gt;\nresult = rsend(:name_of_thing_that_can_be_called, &amp;lt;whatever args you want&amp;gt;, &amp;lt;can be many&amp;gt;)\n```\nevery time you define a new callable thing with rrecv, it will spin up a new thread to respond to those requests&lt;/p&gt;\n\n&lt;p&gt;future work, add the ability to control how many workers rrecv creates, and possibly allow other types of workers other than just threads.&lt;/p&gt;\n\n&lt;p&gt;```\nrequire &amp;#39;securerandom&amp;#39;\nrequire &amp;#39;redis&amp;#39;&lt;/p&gt;\n\n&lt;p&gt;class Message\n  attr_reader :payload, :guid&lt;/p&gt;\n\n&lt;p&gt;def initialize(*args)\n    @guid = SecureRandom.uuid\n    @payload = args\n  end\nend&lt;/p&gt;\n\n&lt;p&gt;class RPCExceptionContainer\n  attr_reader :saved_exception&lt;/p&gt;\n\n&lt;p&gt;def initialize(exception)\n    @saved_exception = exception\n  end\nend&lt;/p&gt;\n\n&lt;p&gt;def rsend(key, &lt;em&gt;args)\n  @r ||= Redis.new\n  Message.new(&lt;/em&gt;args).tap do |message|\n    @r.rpush(key, Marshal.dump(message))\n    Marshal.load(@r.blpop(message.guid)[1]).tap do |return_value|\n      if return_value.class == RPCExceptionContainer\n        raise return_value.saved_exception\n      else\n        return return_value\n      end\n    end\n  end\nend&lt;/p&gt;\n\n&lt;p&gt;def rrecv(key)\n  @keys ||= Hash.new\n  if(!@keys.has_key?(key))\n    r = Redis.new\n    Thread.new do\n      loop do\n        Marshal.load(r.blpop(key)[1]).tap do |message|\n          begin\n            return_value = yield(message.payload)\n            r.rpush(message.guid, Marshal.dump(return_value))\n            r.expire(message.guid, 30)\n          rescue\n            r.rpush(message.guid, Marshal.dump(RPCExceptionContainer.new($!)))\n            r.expire(message.guid, 30)\n          end\n        end\n      end\n    end\n    @keys[key] = true\n  else\n    raise &amp;quot;You Called rrecv twice on the same key, this is almost certainly not what you intended&amp;quot;\n  end\nend&lt;/p&gt;\n\n&lt;p&gt;rrecv(:hello) do |args|\n  puts &amp;quot;Hello #{args.reduce(:+)}&amp;quot;\n  raise &amp;quot;what what&amp;quot;\n  &amp;quot;success&amp;quot;\nend\nx = rsend(:hello, &amp;quot;hi there&amp;quot;, &amp;quot;nobody&amp;quot;) rescue &amp;quot;bobby farquard&amp;quot;\nputs x&lt;/p&gt;\n\n&lt;p&gt;rrecv(:there) do |args|\n  puts &amp;quot;There #{args.reduce(:+)}&amp;quot;\n  &amp;quot;success&amp;quot;\nend\ny = rsend(:there, &amp;quot;something else&amp;quot;)\nputs y&lt;/p&gt;\n\n&lt;p&gt;x = rsend(:hello, &amp;quot;hi there&amp;quot;, &amp;quot;nobody&amp;quot;) rescue &amp;quot;bobby farquard again&amp;quot;\nputs x\n```&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "jki6b7", "is_robot_indexable": true, "report_reasons": null, "author": "pfharlockk", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/jki6b7/why_i_love_ruby_a_complete_rpc_system_using_redis/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/jki6b7/why_i_love_ruby_a_complete_rpc_system_using_redis/", "subreddit_subscribers": 68080, "created_utc": 1604003829.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "I am interested in using Ruby. My typical interaction with my OS is through the CLI. I'm not particularly interested in using shell scripts, thus Ruby would be a suitable replacement. I have the book as mentioned in the topic, which calls for Ruby 2.0 or 2.1. An Amazon review stated the code and gems in this book is outdated. Might there be a better resource regarding Ruby use as a shell replacement? Or will studying this code from 2013 really do me in a bad way until I'm more knowledgeable. Thank you", "author_fullname": "t2_f3j8i", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "[outdated?] Build Awesome Command-Line Applications in Ruby 2", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_jkhsa5", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 1.0, "author_flair_background_color": null, "subreddit_type": "public", "ups": 15, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 15, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1604031424.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I am interested in using Ruby. My typical interaction with my OS is through the CLI. I&amp;#39;m not particularly interested in using shell scripts, thus Ruby would be a suitable replacement. I have the book as mentioned in the topic, which calls for Ruby 2.0 or 2.1. An Amazon review stated the code and gems in this book is outdated. Might there be a better resource regarding Ruby use as a shell replacement? Or will studying this code from 2013 really do me in a bad way until I&amp;#39;m more knowledgeable. Thank you&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "jkhsa5", "is_robot_indexable": true, "report_reasons": null, "author": "Xexagon", "discussion_type": null, "num_comments": 5, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/jkhsa5/outdated_build_awesome_commandline_applications/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/jkhsa5/outdated_build_awesome_commandline_applications/", "subreddit_subscribers": 68080, "created_utc": 1604002624.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "Hey guys, I'm making a chess game and I'm having a lot of trouble. We are on the inheritance section of the course so each piece is a sub class of \"Piece\".\n\nIn the directions, it says:  Your Piece will need to (1) track its position and (2) hold a reference to the Board. Don't allow a piece to move into a square already occupied by the same color piece, or to move a sliding piece past a piece that blocks it.\n\nMy TA said that I am supposed to put board in the initialize method for piece, and pass the board when creating each piece\n\nI created all of the pieces in a board method where I iterated through each of the board spots in the first two and last two rows. However, I cant pass a fully formed board until the last piece has been created! So how do I do this?\n\nAlso, the board will change as pieces change spots, how do I update each piece's board attribute to be accurate???\n\nThank you!", "author_fullname": "t2_7lpnu5f5", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Need help on Chess Game", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": "", "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_jkmvoz", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.67, "author_flair_background_color": null, "subreddit_type": "public", "ups": 4, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Question", "can_mod_post": false, "score": 4, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1604047970.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hey guys, I&amp;#39;m making a chess game and I&amp;#39;m having a lot of trouble. We are on the inheritance section of the course so each piece is a sub class of &amp;quot;Piece&amp;quot;.&lt;/p&gt;\n\n&lt;p&gt;In the directions, it says:  Your Piece will need to (1) track its position and (2) hold a reference to the Board. Don&amp;#39;t allow a piece to move into a square already occupied by the same color piece, or to move a sliding piece past a piece that blocks it.&lt;/p&gt;\n\n&lt;p&gt;My TA said that I am supposed to put board in the initialize method for piece, and pass the board when creating each piece&lt;/p&gt;\n\n&lt;p&gt;I created all of the pieces in a board method where I iterated through each of the board spots in the first two and last two rows. However, I cant pass a fully formed board until the last piece has been created! So how do I do this?&lt;/p&gt;\n\n&lt;p&gt;Also, the board will change as pieces change spots, how do I update each piece&amp;#39;s board attribute to be accurate???&lt;/p&gt;\n\n&lt;p&gt;Thank you!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "d3392e70-873c-11e9-af37-0eea3fce36a6", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "jkmvoz", "is_robot_indexable": true, "report_reasons": null, "author": "MangoLads", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/jkmvoz/need_help_on_chess_game/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/jkmvoz/need_help_on_chess_game/", "subreddit_subscribers": 68080, "created_utc": 1604019170.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "", "author_fullname": "t2_4uc71l5j", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Right-hand assignment has been converted into a one-line pattern matching", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": 140, "top_awarded_type": null, "hide_score": false, "name": "t3_jk8icl", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.91, "author_flair_background_color": null, "subreddit_type": "public", "ups": 31, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 31, "approved_by": null, "author_premium": false, "thumbnail": "https://a.thumbs.redditmedia.com/vcgpQ8zVORQYnrasj5F2oaCNafQP4I2vas8viu1NE04.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "link", "content_categories": null, "is_self": false, "mod_note": null, "created": 1604000766.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://github.com/ruby/ruby/pull/3703", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/USQajWB9Kg4asjHIBPj9sKWWENjpzQtlC2KpRr1zE5s.jpg?auto=webp&amp;s=0788da4ddfac5adb8566527b4ae8997ed1902e85", "width": 400, "height": 400}, "resolutions": [{"url": "https://external-preview.redd.it/USQajWB9Kg4asjHIBPj9sKWWENjpzQtlC2KpRr1zE5s.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=996a241acbc85f56a5a962150c5394b41068618b", "width": 108, "height": 108}, {"url": "https://external-preview.redd.it/USQajWB9Kg4asjHIBPj9sKWWENjpzQtlC2KpRr1zE5s.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=b42d4473691f8c5b929b7d407b48da0b79c75f4b", "width": 216, "height": 216}, {"url": "https://external-preview.redd.it/USQajWB9Kg4asjHIBPj9sKWWENjpzQtlC2KpRr1zE5s.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=ef07605687d4ab09a05d05c25c77c71e55731a25", "width": 320, "height": 320}], "variants": {}, "id": "3SP7kqmMBLbFk1rxKTSH_9qrIEVO1CkoW6vTd7-_IBU"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "jk8icl", "is_robot_indexable": true, "report_reasons": null, "author": "matheusrich", "discussion_type": null, "num_comments": 15, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/jk8icl/righthand_assignment_has_been_converted_into_a/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/ruby/ruby/pull/3703", "subreddit_subscribers": 68080, "created_utc": 1603971966.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "[https://diffickens.com/rails/2020/10/02/back-your-enums-with-enums.html](https://diffickens.com/rails/2020/10/02/back-your-enums-with-enums.html)\n\nI haven't blogged since ages, but there was a discussion regarding how to store Rails enums, so I decided to give writing another try. :-)", "author_fullname": "t2_2vctkex", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Backing Rails enums with Postgres ENUM type", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": "", "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_jk77cb", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.93, "author_flair_background_color": null, "subreddit_type": "public", "ups": 20, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Blog post", "can_mod_post": false, "score": 20, "approved_by": null, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1603994160.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ruby", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;&lt;a href=\"https://diffickens.com/rails/2020/10/02/back-your-enums-with-enums.html\"&gt;https://diffickens.com/rails/2020/10/02/back-your-enums-with-enums.html&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;I haven&amp;#39;t blogged since ages, but there was a discussion regarding how to store Rails enums, so I decided to give writing another try. :-)&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "c8896134-873c-11e9-8edb-0e1f22813c3e", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "jk77cb", "is_robot_indexable": true, "report_reasons": null, "author": "drx3brun", "discussion_type": null, "num_comments": 4, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/jk77cb/backing_rails_enums_with_postgres_enum_type/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/ruby/comments/jk77cb/backing_rails_enums_with_postgres_enum_type/", "subreddit_subscribers": 68080, "created_utc": 1603965360.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ruby", "selftext": "", "author_fullname": "t2_8bmeca3t", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Designed a simple rails app that communicates with Google Drive API.", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ruby", "hidden": false, "pwls": 6, "link_flair_css_class": "", "downs": 0, "thumbnail_height": 140, "top_awarded_type": null, "hide_score": false, "name": "t3_jkavpd", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.9, "author_flair_background_color": null, "subreddit_type": "public", "ups": 8, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Show /r/ruby", "can_mod_post": false, "score": 8, "approved_by": null, "author_premium": false, "thumbnail": "https://b.thumbs.redditmedia.com/LN7tUDh284DUVWv30OKtTWQQsS6RqTf-o26a1czY27s.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "link", "content_categories": null, "is_self": false, "mod_note": null, "created": 1604010006.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://github.com/AbhishekSinhaCoder/Ruby-on-Rails-Challenge", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/WNn7aAVzo_ggiXOWRFI6PNriHL4h9xoViF_LL3wuHQM.jpg?auto=webp&amp;s=bb75b99ecd2085cc961af13b17e0e858c36b48e9", "width": 400, "height": 400}, "resolutions": [{"url": "https://external-preview.redd.it/WNn7aAVzo_ggiXOWRFI6PNriHL4h9xoViF_LL3wuHQM.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=ba28a66d7669cebc76a89ec683ef524ca3e9322e", "width": 108, "height": 108}, {"url": "https://external-preview.redd.it/WNn7aAVzo_ggiXOWRFI6PNriHL4h9xoViF_LL3wuHQM.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=a72d6d6cf43dd2230f6cbad9a9594429cd27a8f9", "width": 216, "height": 216}, {"url": "https://external-preview.redd.it/WNn7aAVzo_ggiXOWRFI6PNriHL4h9xoViF_LL3wuHQM.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=37b519c19dfb3f42de22ada212e27a88b6f0e8e3", "width": 320, "height": 320}], "variants": {}, "id": "qepAXSiUlPglY850-J2TIych-kvJcaU1OSESW2_DLbM"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "d57de81a-873c-11e9-9a25-0e18d14df676", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2qh21", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "jkavpd", "is_robot_indexable": true, "report_reasons": null, "author": "RoughAthlete3611", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ruby/comments/jkavpd/designed_a_simple_rails_app_that_communicates/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/AbhishekSinhaCoder/Ruby-on-Rails-Challenge", "subreddit_subscribers": 68080, "created_utc": 1603981206.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_jkavpd", "before": null}}