{"kind": "Listing", "data": {"modhash": "", "dist": 10, "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hello everybody!\n\nI'm very proud to release the new version of [DevDash](https://github.com/Phantas0s/devdash), which allows you to create very flexible terminal dashboards.\n\nWhat's the difference with the existing solutions, you might rightfully ask? You can personalize everything: what data you put in the widgets, from where, the color, the placement, and so on.\n\nYou can as well use very generic widgets to query yourself the APIs available!\n\nWith this new version, you can as well feed your nice dashboard widgets with data from command lines or scripts output, from your local host or from a remote host (via SSH).\n\nThe way to handle dashboard configurations has been simplified, too. I still think there is a lot of improvement to be made on that matter, so I will focus on that next.\n\nThe performance have been significantly improved, too.\n\nIf you like it, don't forget to give a sweet little Github star :)\n\n* [Github repo](https://github.com/Phantas0s/devdash) \n* [Documentation](https://thedevdash.com)\n\n&amp;#x200B;\n\nhttps://preview.redd.it/lluiebevyu351.png?width=1920&amp;format=png&amp;auto=webp&amp;s=678a6e016c5ff92c7c731ed651af5780a62bb011\n\nhttps://preview.redd.it/5zile4evyu351.png?width=1920&amp;format=png&amp;auto=webp&amp;s=88ad4abe600ca787fe0ab0b91c46ac1784b1c29a", "author_fullname": "t2_jv4edou", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "New release of DevDash, to create customizable dashboards in your terminal", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "media_metadata": {"5zile4evyu351": {"status": "valid", "e": "Image", "m": "image/png", "p": [{"y": 45, "x": 108, "u": "https://preview.redd.it/5zile4evyu351.png?width=108&amp;crop=smart&amp;auto=webp&amp;s=f061c8ec274842b392e659f3c77a38650d7926d7"}, {"y": 90, "x": 216, "u": "https://preview.redd.it/5zile4evyu351.png?width=216&amp;crop=smart&amp;auto=webp&amp;s=7f123bc5740cd3fec5048d76e6aa2e43a0571304"}, {"y": 133, "x": 320, "u": "https://preview.redd.it/5zile4evyu351.png?width=320&amp;crop=smart&amp;auto=webp&amp;s=24f9ee47672627387247378965b16c1fb3d98596"}, {"y": 267, "x": 640, "u": "https://preview.redd.it/5zile4evyu351.png?width=640&amp;crop=smart&amp;auto=webp&amp;s=2ef330af69fb8c2b1583421e19b2d5acc18936d5"}, {"y": 401, "x": 960, "u": "https://preview.redd.it/5zile4evyu351.png?width=960&amp;crop=smart&amp;auto=webp&amp;s=669b227807603be57ed5af0057b48dc51d347da0"}, {"y": 451, "x": 1080, "u": "https://preview.redd.it/5zile4evyu351.png?width=1080&amp;crop=smart&amp;auto=webp&amp;s=261b4301bac135dc94dcea1813e186f6826baca6"}], "s": {"y": 802, "x": 1920, "u": "https://preview.redd.it/5zile4evyu351.png?width=1920&amp;format=png&amp;auto=webp&amp;s=88ad4abe600ca787fe0ab0b91c46ac1784b1c29a"}, "id": "5zile4evyu351"}, "lluiebevyu351": {"status": "valid", "e": "Image", "m": "image/png", "p": [{"y": 64, "x": 108, "u": "https://preview.redd.it/lluiebevyu351.png?width=108&amp;crop=smart&amp;auto=webp&amp;s=2f6212031ee0303f340759a12397fb35ae1155a5"}, {"y": 128, "x": 216, "u": "https://preview.redd.it/lluiebevyu351.png?width=216&amp;crop=smart&amp;auto=webp&amp;s=da8e367b15f26e637bfa48ab1b6207ac684ef77b"}, {"y": 189, "x": 320, "u": "https://preview.redd.it/lluiebevyu351.png?width=320&amp;crop=smart&amp;auto=webp&amp;s=3723e972fa07080183595cf8394ae29151409534"}, {"y": 379, "x": 640, "u": "https://preview.redd.it/lluiebevyu351.png?width=640&amp;crop=smart&amp;auto=webp&amp;s=83255e302edf5f4c79ba98ca49adf7f9a1b46822"}, {"y": 569, "x": 960, "u": "https://preview.redd.it/lluiebevyu351.png?width=960&amp;crop=smart&amp;auto=webp&amp;s=e813eb96312a0e2c539f641ef9a93fa49b5842df"}, {"y": 640, "x": 1080, "u": "https://preview.redd.it/lluiebevyu351.png?width=1080&amp;crop=smart&amp;auto=webp&amp;s=516fe0773c7705f1698da81a9603ffcf99590f14"}], "s": {"y": 1138, "x": 1920, "u": "https://preview.redd.it/lluiebevyu351.png?width=1920&amp;format=png&amp;auto=webp&amp;s=678a6e016c5ff92c7c731ed651af5780a62bb011"}, "id": "lluiebevyu351"}}, "name": "t3_gzk5z3", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.93, "author_flair_background_color": null, "subreddit_type": "public", "ups": 29, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 29, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591725754.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hello everybody!&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m very proud to release the new version of &lt;a href=\"https://github.com/Phantas0s/devdash\"&gt;DevDash&lt;/a&gt;, which allows you to create very flexible terminal dashboards.&lt;/p&gt;\n\n&lt;p&gt;What&amp;#39;s the difference with the existing solutions, you might rightfully ask? You can personalize everything: what data you put in the widgets, from where, the color, the placement, and so on.&lt;/p&gt;\n\n&lt;p&gt;You can as well use very generic widgets to query yourself the APIs available!&lt;/p&gt;\n\n&lt;p&gt;With this new version, you can as well feed your nice dashboard widgets with data from command lines or scripts output, from your local host or from a remote host (via SSH).&lt;/p&gt;\n\n&lt;p&gt;The way to handle dashboard configurations has been simplified, too. I still think there is a lot of improvement to be made on that matter, so I will focus on that next.&lt;/p&gt;\n\n&lt;p&gt;The performance have been significantly improved, too.&lt;/p&gt;\n\n&lt;p&gt;If you like it, don&amp;#39;t forget to give a sweet little Github star :)&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://github.com/Phantas0s/devdash\"&gt;Github repo&lt;/a&gt; &lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://thedevdash.com\"&gt;Documentation&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://preview.redd.it/lluiebevyu351.png?width=1920&amp;amp;format=png&amp;amp;auto=webp&amp;amp;s=678a6e016c5ff92c7c731ed651af5780a62bb011\"&gt;https://preview.redd.it/lluiebevyu351.png?width=1920&amp;amp;format=png&amp;amp;auto=webp&amp;amp;s=678a6e016c5ff92c7c731ed651af5780a62bb011&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://preview.redd.it/5zile4evyu351.png?width=1920&amp;amp;format=png&amp;amp;auto=webp&amp;amp;s=88ad4abe600ca787fe0ab0b91c46ac1784b1c29a\"&gt;https://preview.redd.it/5zile4evyu351.png?width=1920&amp;amp;format=png&amp;amp;auto=webp&amp;amp;s=88ad4abe600ca787fe0ab0b91c46ac1784b1c29a&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gzk5z3", "is_robot_indexable": true, "report_reasons": null, "author": "phantaso0s", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gzk5z3/new_release_of_devdash_to_create_customizable/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/gzk5z3/new_release_of_devdash_to_create_customizable/", "subreddit_subscribers": 115317, "created_utc": 1591696954.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hello I am wondering if anyone is currently making any desktop applications using go. If so what frameworks? I really like go and I was looking to build a desktop Gui with it. Any advice or information as to why this may or may not be a good idea is appreciated.", "author_fullname": "t2_6o000ddi", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Question about making GUIs in go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_gzga4u", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.99, "author_flair_background_color": null, "subreddit_type": "public", "ups": 16, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 16, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591707314.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hello I am wondering if anyone is currently making any desktop applications using go. If so what frameworks? I really like go and I was looking to build a desktop Gui with it. Any advice or information as to why this may or may not be a good idea is appreciated.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gzga4u", "is_robot_indexable": true, "report_reasons": null, "author": "DaltonCodes", "discussion_type": null, "num_comments": 21, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gzga4u/question_about_making_guis_in_go/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/gzga4u/question_about_making_guis_in_go/", "subreddit_subscribers": 115317, "created_utc": 1591678514.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_51iu6ea3", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Phil Wadler: Featherweight Go - YouTube", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_gz19le", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.98, "author_flair_background_color": null, "subreddit_type": "public", "ups": 136, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 136, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1591658371.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "youtube.com", "allow_live_comments": true, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gz19le", "is_robot_indexable": true, "report_reasons": null, "author": "A-AronBrown", "discussion_type": null, "num_comments": 20, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gz19le/phil_wadler_featherweight_go_youtube/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.youtube.com/watch?v=Dq0WFigax_c", "subreddit_subscribers": 115317, "created_utc": 1591629571.0, "num_crossposts": 1, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_bgd6j", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Using gRPC to communicate between Go and Python programs - Ardan Labs", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_gz9kcr", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.97, "author_flair_background_color": null, "subreddit_type": "public", "ups": 35, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 35, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1591683231.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "ardanlabs.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gz9kcr", "is_robot_indexable": true, "report_reasons": null, "author": "Swaddit", "discussion_type": null, "num_comments": 0, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gz9kcr/using_grpc_to_communicate_between_go_and_python/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.ardanlabs.com/blog/2020/06/python-go-grpc.html", "subreddit_subscribers": 115317, "created_utc": 1591654431.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "I finally released a package which lets you map your SQL data onto Go structs while keeping track of has-one and has-many relationships. Feature requests, comments, stars greatly appreciated.  \n[https://github.com/jackskj/carta](https://github.com/jackskj/carta)", "author_fullname": "t2_2n4k43na", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Mapping complex SQL data in Go", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_gz7ar6", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.94, "author_flair_background_color": null, "subreddit_type": "public", "ups": 47, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 47, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591676880.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I finally released a package which lets you map your SQL data onto Go structs while keeping track of has-one and has-many relationships. Feature requests, comments, stars greatly appreciated.&lt;br/&gt;\n&lt;a href=\"https://github.com/jackskj/carta\"&gt;https://github.com/jackskj/carta&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gz7ar6", "is_robot_indexable": true, "report_reasons": null, "author": "jack_8080", "discussion_type": null, "num_comments": 3, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gz7ar6/mapping_complex_sql_data_in_go/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/gz7ar6/mapping_complex_sql_data_in_go/", "subreddit_subscribers": 115317, "created_utc": 1591648080.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "I am fairly new to Golang and I was creating an API to fetch commits from any Github repository using their API. I was then creating a frequency count, based on the date and then sending it to the frontend.\n\nCurrently, I only work in one main.go and I am not very aware of the programming pracices in Golang. I am using the Mux router to work with http.\n\n I have 2 routes.  \nThe '/' route is handled by getHome and '/updateRepository' is handled by updateRepository  \n handler.\n\nI maintain a currentRepository variable globally.  \nIn both handler methods, I first get the timestamps of all the commits for that repository using Github's API using getCommitTimeStamps.\n\nThen I parse the timestamps using parseTimeStamps, which first converts the RFC3339 date format to YYYY-MM-DD format and then basically create a map to store the frequency for each date.\n\nThe only extra method which updateRepository handler uses, is parseURL  \nwhich basically extracts the Github Owner Name and Repository name from any Github URL. \n\nI plan to update this using an input text element on my Frontend.\n\ninit() initialises a new Client for enabling access to Github's API.\n\nI have split everything into functions, what else can I do? What are the things I can clean?\n\n    package main\n    \n    import (\n        \"context\"\n        \"encoding/json\"\n        \"fmt\"\n        \"net/http\"\n        \"strings\"\n        \"time\"\n    \n        \"github.com/google/go-github/v31/github\"\n        \"github.com/gorilla/mux\"\n        \"golang.org/x/oauth2\"\n    )\n    \n    var client *github.Client\n    var ctx context.Context\n    \n    type Repository struct {\n        Owner string `json:\"owner\"`\n        Name  string `json:\"name\"`\n    }\n    \n    type Frequency struct {\n        Date  string `json:\"date\"`\n        Count int    `json:\"count\"`\n    }\n    \n    var currentRepository = Repository{\n        Owner: \"randomusername\",\n        Name:  \"foobar\",\n    }\n    \n    const GITHUB_AUTH_TOKEN string = \"MY_AUTH_TOKEN\"\n    \n    func init() {\n        ctx = context.Background()\n        ts := oauth2.StaticTokenSource(\n            &amp;oauth2.Token{AccessToken: GITHUB_AUTH_TOKEN},\n        )\n        tc := oauth2.NewClient(ctx, ts)\n        client = github.NewClient(tc)\n    }\n    \n    func parseURL(repoURL *string) Repository {\n        res := currentRepository\n        if *repoURL != \"\" {\n            index := strings.Index(*repoURL, \"github.com\")\n    \n            repo := *repoURL\n            repo = repo[index+11:]\n            var base []string\n            base = strings.Split(repo, \"/\")\n            var ans []string\n            for _, e := range base {\n                if e != \"\" {\n                    ans = append(ans, e)\n                }\n            }\n            res = Repository{\n                Owner: ans[0],\n                Name:  ans[1],\n            }\n        }\n    \n        return res\n    }\n    \n    func getCommitTimeStamps(repo Repository) []time.Time {\n        var commitTimeStamps []time.Time\n    \n        opt := &amp;github.CommitsListOptions{\n            ListOptions: github.ListOptions{PerPage: 50},\n        }\n    \n        var allRepositoryCommits []*github.RepositoryCommit\n        for {\n            repositoryCommits, resp, err := client.Repositories.ListCommits(ctx, repo.Owner, repo.Name, opt)\n            if err != nil {\n                fmt.Println(err)\n            }\n            allRepositoryCommits = append(allRepositoryCommits, repositoryCommits...)\n            if resp.NextPage == 0 {\n                break\n            }\n            opt.Page = resp.NextPage\n        }\n    \n        for _, e := range allRepositoryCommits {\n            commitTimeStamps = append(commitTimeStamps, *e.GetCommit().Author.Date)\n        }\n        return commitTimeStamps\n    }\n    \n    func parseTimeStamps(commitTimeStamps []time.Time) []Frequency {\n        const RFC3339FullDate = \"2006-08-06\"\n        timeSeries := make([]string, len(commitTimeStamps))\n        for i, t := range commitTimeStamps {\n            timeSeries[i] = fmt.Sprintf(\"%d-%02d-%02d\", t.Year(), t.Month(), t.Day())\n        }\n        m := make(map[string]int)\n        for _, t := range timeSeries {\n            m[t]++\n        }\n        var f []Frequency\n    \n        for k, v := range m {\n            f = append(f, Frequency{\n                Date:  k,\n                Count: v,\n            })\n        }\n        return f\n    }\n    \n    func getHome(w http.ResponseWriter, r *http.Request) {\n        commitTimeStamps := getCommitTimeStamps(currentRepository)\n        commitTimeObjects := parseTimeStamps(commitTimeStamps)\n    \n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type\")\n    \n        _ = json.NewEncoder(w).Encode(commitTimeObjects)\n    }\n    \n    func updateRepository(w http.ResponseWriter, r *http.Request) {\n        var url struct {\n            URL string `json:\"url\"`\n        }\n    \n        _ = json.NewDecoder(r.Body).Decode(&amp;url)\n        currentRepository = parseURL(&amp;url.URL)\n        fmt.Println(currentRepository)\n        // currentRepository looks like {bradtraversy reactcharts}\n        commitTimeStamps := getCommitTimeStamps(currentRepository)\n        commitTimeObjects := parseTimeStamps(commitTimeStamps)\n        // commitTimeObjects looks like [{2016-04-21 2} {2016-04-23 5} {2016-04-25 1}]\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"PUT\")\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type\")\n        fmt.Println(currentRepository)\n        _ = json.NewEncoder(w).Encode(commitTimeObjects)\n    }\n    \n    func main() {\n        router := mux.NewRouter()\n        router.Use(mux.CORSMethodMiddleware(router))\n        router.HandleFunc(\"/\", getHome).Methods(\"GET\", \"OPTIONS\")\n        router.HandleFunc(\"/updateRepository\", updateRepository).Methods(\"PUT\", \"OPTIONS\")\n    \n        http.ListenAndServe(\":8000\", router)\n    }", "author_fullname": "t2_yfg2o", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Creating an API: How can I refactor this code? [Beginner][Code Review]", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_gzip32", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.77, "author_flair_background_color": null, "subreddit_type": "public", "ups": 5, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 5, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": 1591691342.0, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591718464.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I am fairly new to Golang and I was creating an API to fetch commits from any Github repository using their API. I was then creating a frequency count, based on the date and then sending it to the frontend.&lt;/p&gt;\n\n&lt;p&gt;Currently, I only work in one main.go and I am not very aware of the programming pracices in Golang. I am using the Mux router to work with http.&lt;/p&gt;\n\n&lt;p&gt;I have 2 routes.&lt;br/&gt;\nThe &amp;#39;/&amp;#39; route is handled by getHome and &amp;#39;/updateRepository&amp;#39; is handled by updateRepository&lt;br/&gt;\n handler.&lt;/p&gt;\n\n&lt;p&gt;I maintain a currentRepository variable globally.&lt;br/&gt;\nIn both handler methods, I first get the timestamps of all the commits for that repository using Github&amp;#39;s API using getCommitTimeStamps.&lt;/p&gt;\n\n&lt;p&gt;Then I parse the timestamps using parseTimeStamps, which first converts the RFC3339 date format to YYYY-MM-DD format and then basically create a map to store the frequency for each date.&lt;/p&gt;\n\n&lt;p&gt;The only extra method which updateRepository handler uses, is parseURL&lt;br/&gt;\nwhich basically extracts the Github Owner Name and Repository name from any Github URL. &lt;/p&gt;\n\n&lt;p&gt;I plan to update this using an input text element on my Frontend.&lt;/p&gt;\n\n&lt;p&gt;init() initialises a new Client for enabling access to Github&amp;#39;s API.&lt;/p&gt;\n\n&lt;p&gt;I have split everything into functions, what else can I do? What are the things I can clean?&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n    &amp;quot;context&amp;quot;\n    &amp;quot;encoding/json&amp;quot;\n    &amp;quot;fmt&amp;quot;\n    &amp;quot;net/http&amp;quot;\n    &amp;quot;strings&amp;quot;\n    &amp;quot;time&amp;quot;\n\n    &amp;quot;github.com/google/go-github/v31/github&amp;quot;\n    &amp;quot;github.com/gorilla/mux&amp;quot;\n    &amp;quot;golang.org/x/oauth2&amp;quot;\n)\n\nvar client *github.Client\nvar ctx context.Context\n\ntype Repository struct {\n    Owner string `json:&amp;quot;owner&amp;quot;`\n    Name  string `json:&amp;quot;name&amp;quot;`\n}\n\ntype Frequency struct {\n    Date  string `json:&amp;quot;date&amp;quot;`\n    Count int    `json:&amp;quot;count&amp;quot;`\n}\n\nvar currentRepository = Repository{\n    Owner: &amp;quot;randomusername&amp;quot;,\n    Name:  &amp;quot;foobar&amp;quot;,\n}\n\nconst GITHUB_AUTH_TOKEN string = &amp;quot;MY_AUTH_TOKEN&amp;quot;\n\nfunc init() {\n    ctx = context.Background()\n    ts := oauth2.StaticTokenSource(\n        &amp;amp;oauth2.Token{AccessToken: GITHUB_AUTH_TOKEN},\n    )\n    tc := oauth2.NewClient(ctx, ts)\n    client = github.NewClient(tc)\n}\n\nfunc parseURL(repoURL *string) Repository {\n    res := currentRepository\n    if *repoURL != &amp;quot;&amp;quot; {\n        index := strings.Index(*repoURL, &amp;quot;github.com&amp;quot;)\n\n        repo := *repoURL\n        repo = repo[index+11:]\n        var base []string\n        base = strings.Split(repo, &amp;quot;/&amp;quot;)\n        var ans []string\n        for _, e := range base {\n            if e != &amp;quot;&amp;quot; {\n                ans = append(ans, e)\n            }\n        }\n        res = Repository{\n            Owner: ans[0],\n            Name:  ans[1],\n        }\n    }\n\n    return res\n}\n\nfunc getCommitTimeStamps(repo Repository) []time.Time {\n    var commitTimeStamps []time.Time\n\n    opt := &amp;amp;github.CommitsListOptions{\n        ListOptions: github.ListOptions{PerPage: 50},\n    }\n\n    var allRepositoryCommits []*github.RepositoryCommit\n    for {\n        repositoryCommits, resp, err := client.Repositories.ListCommits(ctx, repo.Owner, repo.Name, opt)\n        if err != nil {\n            fmt.Println(err)\n        }\n        allRepositoryCommits = append(allRepositoryCommits, repositoryCommits...)\n        if resp.NextPage == 0 {\n            break\n        }\n        opt.Page = resp.NextPage\n    }\n\n    for _, e := range allRepositoryCommits {\n        commitTimeStamps = append(commitTimeStamps, *e.GetCommit().Author.Date)\n    }\n    return commitTimeStamps\n}\n\nfunc parseTimeStamps(commitTimeStamps []time.Time) []Frequency {\n    const RFC3339FullDate = &amp;quot;2006-08-06&amp;quot;\n    timeSeries := make([]string, len(commitTimeStamps))\n    for i, t := range commitTimeStamps {\n        timeSeries[i] = fmt.Sprintf(&amp;quot;%d-%02d-%02d&amp;quot;, t.Year(), t.Month(), t.Day())\n    }\n    m := make(map[string]int)\n    for _, t := range timeSeries {\n        m[t]++\n    }\n    var f []Frequency\n\n    for k, v := range m {\n        f = append(f, Frequency{\n            Date:  k,\n            Count: v,\n        })\n    }\n    return f\n}\n\nfunc getHome(w http.ResponseWriter, r *http.Request) {\n    commitTimeStamps := getCommitTimeStamps(currentRepository)\n    commitTimeObjects := parseTimeStamps(commitTimeStamps)\n\n    w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)\n    w.Header().Set(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;)\n    w.Header().Set(&amp;quot;Access-Control-Allow-Methods&amp;quot;, &amp;quot;GET, OPTIONS&amp;quot;)\n    w.Header().Set(&amp;quot;Access-Control-Allow-Headers&amp;quot;, &amp;quot;Content-Type&amp;quot;)\n\n    _ = json.NewEncoder(w).Encode(commitTimeObjects)\n}\n\nfunc updateRepository(w http.ResponseWriter, r *http.Request) {\n    var url struct {\n        URL string `json:&amp;quot;url&amp;quot;`\n    }\n\n    _ = json.NewDecoder(r.Body).Decode(&amp;amp;url)\n    currentRepository = parseURL(&amp;amp;url.URL)\n    fmt.Println(currentRepository)\n    // currentRepository looks like {bradtraversy reactcharts}\n    commitTimeStamps := getCommitTimeStamps(currentRepository)\n    commitTimeObjects := parseTimeStamps(commitTimeStamps)\n    // commitTimeObjects looks like [{2016-04-21 2} {2016-04-23 5} {2016-04-25 1}]\n    w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)\n    w.Header().Set(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;)\n    w.Header().Set(&amp;quot;Access-Control-Allow-Methods&amp;quot;, &amp;quot;PUT&amp;quot;)\n    w.Header().Set(&amp;quot;Access-Control-Allow-Headers&amp;quot;, &amp;quot;Content-Type&amp;quot;)\n    fmt.Println(currentRepository)\n    _ = json.NewEncoder(w).Encode(commitTimeObjects)\n}\n\nfunc main() {\n    router := mux.NewRouter()\n    router.Use(mux.CORSMethodMiddleware(router))\n    router.HandleFunc(&amp;quot;/&amp;quot;, getHome).Methods(&amp;quot;GET&amp;quot;, &amp;quot;OPTIONS&amp;quot;)\n    router.HandleFunc(&amp;quot;/updateRepository&amp;quot;, updateRepository).Methods(&amp;quot;PUT&amp;quot;, &amp;quot;OPTIONS&amp;quot;)\n\n    http.ListenAndServe(&amp;quot;:8000&amp;quot;, router)\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gzip32", "is_robot_indexable": true, "report_reasons": null, "author": "awesumsingh", "discussion_type": null, "num_comments": 2, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gzip32/creating_an_api_how_can_i_refactor_this_code/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/gzip32/creating_an_api_how_can_i_refactor_this_code/", "subreddit_subscribers": 115317, "created_utc": 1591689664.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "I need a graph database for my project, which will feature friend / connection and group, like Facebook, and connection degree (like LinkedIn's shows 1st, 2nd or 3rd degree connection) and I'm not sure which one to use.\n\nPrimary requirements:\n1. Free and open sourced (must not be GPL).\n2. Should support Go (as my back-end is fully in go).\n3. Must be scalable.\n\nSecondary requirements:\n1. Should support backup, restore.\n2. Should support encryption.\n\nI tried neo4j, it's nice, but it's GPL.\n\nAs of now, considering Janusgraph, Dgraph (doesn't support backup, encryption for free version), Cayley.\n\nAny suggestion, advice, experience will be highly appreciated.\n\nThanks in advance!", "author_fullname": "t2_6mwodkjf", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Which Graph database to use?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_gzgjph", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.99, "author_flair_background_color": null, "subreddit_type": "public", "ups": 6, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 6, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591708440.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I need a graph database for my project, which will feature friend / connection and group, like Facebook, and connection degree (like LinkedIn&amp;#39;s shows 1st, 2nd or 3rd degree connection) and I&amp;#39;m not sure which one to use.&lt;/p&gt;\n\n&lt;p&gt;Primary requirements:\n1. Free and open sourced (must not be GPL).\n2. Should support Go (as my back-end is fully in go).\n3. Must be scalable.&lt;/p&gt;\n\n&lt;p&gt;Secondary requirements:\n1. Should support backup, restore.\n2. Should support encryption.&lt;/p&gt;\n\n&lt;p&gt;I tried neo4j, it&amp;#39;s nice, but it&amp;#39;s GPL.&lt;/p&gt;\n\n&lt;p&gt;As of now, considering Janusgraph, Dgraph (doesn&amp;#39;t support backup, encryption for free version), Cayley.&lt;/p&gt;\n\n&lt;p&gt;Any suggestion, advice, experience will be highly appreciated.&lt;/p&gt;\n\n&lt;p&gt;Thanks in advance!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gzgjph", "is_robot_indexable": true, "report_reasons": null, "author": "arpanbag001", "discussion_type": null, "num_comments": 17, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gzgjph/which_graph_database_to_use/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/gzgjph/which_graph_database_to_use/", "subreddit_subscribers": 115317, "created_utc": 1591679640.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_1w5x", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How to Write a CLI With \u201cJust Enough\u201d Architecture", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_gyxfvp", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.98, "author_flair_background_color": null, "subreddit_type": "public", "ups": 101, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 101, "approved_by": null, "author_premium": true, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1591643783.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "blog.carlmjohnson.net", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gyxfvp", "is_robot_indexable": true, "report_reasons": null, "author": "earthboundkid", "discussion_type": null, "num_comments": 7, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gyxfvp/how_to_write_a_cli_with_just_enough_architecture/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://blog.carlmjohnson.net/post/2020/go-cli-how-to-and-advice/", "subreddit_subscribers": 115317, "created_utc": 1591614983.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "Hello gophers!\n\nI've been studying Golang for quite some time and have some understanding of basic concepts now. Even had some experience writing applications which are being used already. However, I still feel like I lack some fundamental patterns and concepts of concurrent and parallel programming besides the stuff presented and described in Go stdlib (mutexes, coroutines, shared memory, etc.)\n\nSo, are there any great books describing such general concurrent/parallel computation concepts that you could recommend? Especially if it's not strictly tied to any language except C/C++/Golang and for anyone with 3-4 years of programming work experience? Thanks in advance!", "author_fullname": "t2_rebpg3b", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Good concurrent/parallel programming books", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_gz9cg2", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.92, "author_flair_background_color": null, "subreddit_type": "public", "ups": 13, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 13, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": true, "mod_note": null, "created": 1591682556.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.golang", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hello gophers!&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;ve been studying Golang for quite some time and have some understanding of basic concepts now. Even had some experience writing applications which are being used already. However, I still feel like I lack some fundamental patterns and concepts of concurrent and parallel programming besides the stuff presented and described in Go stdlib (mutexes, coroutines, shared memory, etc.)&lt;/p&gt;\n\n&lt;p&gt;So, are there any great books describing such general concurrent/parallel computation concepts that you could recommend? Especially if it&amp;#39;s not strictly tied to any language except C/C++/Golang and for anyone with 3-4 years of programming work experience? Thanks in advance!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gz9cg2", "is_robot_indexable": true, "report_reasons": null, "author": "grenhere", "discussion_type": null, "num_comments": 4, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gz9cg2/good_concurrentparallel_programming_books/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://www.reddit.com/r/golang/comments/gz9cg2/good_concurrentparallel_programming_books/", "subreddit_subscribers": 115317, "created_utc": 1591653756.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "golang", "selftext": "", "author_fullname": "t2_dctuo", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "iron-go-project: github go repo template with batteries included!", "link_flair_richtext": [], "subreddit_name_prefixed": "r/golang", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "top_awarded_type": null, "hide_score": false, "name": "t3_gzj599", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.4, "author_flair_background_color": null, "subreddit_type": "public", "ups": 0, "total_awards_received": 0, "media_embed": {}, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 0, "approved_by": null, "author_premium": false, "thumbnail": "", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "mod_note": null, "created": 1591720674.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": null, "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": true, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2rc7j", "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "gzj599", "is_robot_indexable": true, "report_reasons": null, "author": "nindustries", "discussion_type": null, "num_comments": 1, "send_replies": true, "whitelist_status": "all_ads", "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/golang/comments/gzj599/irongoproject_github_go_repo_template_with/", "parent_whitelist_status": "all_ads", "stickied": false, "url": "https://github.com/ironPeakServices/iron-go-project", "subreddit_subscribers": 115317, "created_utc": 1591691874.0, "num_crossposts": 0, "media": null, "is_video": false}}], "after": "t3_gzj599", "before": null}}